\documentclass {article}

%% ** Packages

\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsthm, amssymb, amsmath}
\usepackage{hyperref}

%% ** OCaml listings

\usepackage{xcolor}
\usepackage{listings}
\lstset{
  language=[Objective]Caml,
  %% emph={[2]Nil,Cons,FZe,FSu,ze,su,Ze,Su},
  %% emphstyle={[2]\Constructor},
  %% emph={[3]lookup,failwith},
  %% emphstyle={[3]\Function},
  %% emph={[4]vec,fin,nat,list,tree,completeTree},
  %% emphstyle={[4]\Canonical},
  morecomment=[s]{(*}{*)},
  rangeprefix=\(\*\=,
  rangesuffix=\ \*\),
  includerangemarker=false,
  extendedchars=\true,
  inputencoding=utf8,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  basicstyle=\ttfamily\small,
  framesep=4mm,
  moredelim=*[s][\itshape]{(*}{*)},
  moredelim=[is][\textcolor{darkgray}]{§}{§},
  escapechar=°,
  keywordstyle=\color[rgb]{0.627451, 0.125490, 0.941176},
  stringstyle=\color[rgb]{0.545098, 0.278431, 0.364706},
  commentstyle=\color[rgb]{0.698039, 0.133333, 0.133333},
  numberstyle=\color[rgb]{0.372549, 0.619608, 0.627451},
  boxpos=t,
  literate= {'a}{{$\alpha$}}1%
    {->}{{${\to}$}}2
    {*}{{${\times}$}}1
    {::}{{${:\::}$}}1
}

\newcommand{\codefrom}[3]
           {\lstinputlisting[linerange={#3}-End]{../#1/#2.ml}}


%% ** Theorem styles 


\newtheorem{theorem}{Théorème}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemme}

\theoremstyle{definition}
\newtheorem{definition}{Définition}
\newtheorem{example}{Exemple}

\theoremstyle{remark}
\newtheorem{remark}{Remarque}
\newtheorem{para}{} 


%% ** Title

\title{Implémentation de la théorie des types dépendants}
\author{Roman Delgado}
\date{}


\begin{document}

\maketitle


%% ** Abstract 


\begin{abstract} 
  Ce document représente l'ensemble du travail effectué durant l'unité d'enseignement 3I013 de l'upmc,
\end{abstract}

\tableofcontents

\clearpage

%% ** Main

\section{Introduction}

blablawsdsdfsdf


Voici du code :

%% \codefrom{dossier}{fichier}{tag}
%%   où 'dossier' est "no_type", ou "typed", ou "dependent"
%%      'fichier' est le chemin vers un fichier dans le dossier
%%      'tag' est une déclaration de la forme (*=tag *) (code) (*=End *) dans le source

\section{lambda calcul non typé}

En 1936, Alonzo Church introduit le lambda calcul non typé
(citation de church), c'est
un modèle de calcul universel tout comme les machines de Turing. Celui-ci repose
sur une syntaxe minimaliste et permet de formaliser le concept d'application 
de fonctions. Il est au coeur de nombreuses recherches dans le domaine de la 
programmation fonctionnelle. Le lambda calcul non typé a connu un formidable 
succès, donnant lieu à de multiples variantes dont on trouvera une présentation
 moderne et synthétique dans l'ouvrage de (citation pierce).

\subsection{Présentation formelle}

\subsubsection{Syntaxe}
Le lambda calcul est composé uniquement de \(\lambda\) termes dont voici la syntaxe

\begin{align*}
  t &::= & \mbox{(lambda terme)} \\
  &|\quad x & \mbox{(variable)} \\
  &|\quad \lambda x. t & \mbox{(abstraction)} \\
  &|\quad t\: t          & \mbox{(application)}
\end{align*}

Pour faire une analogie avec le modèle mathématique, une abstraction peut 
etre vue comme une fonction anonyme.
 
\begin{example}
 La fonction identité peut etre définie par le lambda terme suivant :
  %
  \[ 
  \lambda x. x
  \]
\end{example}

On peut constater avec cette syntaxe que les abstractions ne prennent qu'un
seul argument, mais d'après la théorie de Haskell Curry (la curryfication), 
l'ensemble des fonctions à plusieurs arguments peuvent etre représentées 
par une succession de fonctions à un seul argument.
\begin{example}
Le \(\lambda\)terme  \(\lambda xy.t\) peut etre représentée par le terme suivant
\(\lambda x.\lambda y.t\)   
\end{example} 
Dans la suite de cet article nous utiliserons des fonctions à un unique 
argument. 

\subsubsection{Variables libres et variables liées}

Une variable est liée lorsque celle ci est déclarée dans le corps d'un lambda, 
dans l'exemple précédent x était une variable liée. 
Si la variable n'a pas été déclarée elle sera dite libre. 

\begin{example}
  Dans le terme suivant \(\lambda x.\lambda y.x\:y\:z\) , les variables x et 
  y sont liées tandis que la variable z est libre 
\end{example}

Un terme ne contenant aucune occurrence de variable libre est dit `clos'.
\begin{example}
  Dans le lambda terme \((\lambda x. \lambda y. x\: y)\: y\), la
  variable \(x\) est liée ainsi que la première occurence de la
  variable \(y\). Cependant, la variable \(y\) à l'exterieur des
  parenthèse est libre.
\end{example}

Un des problèmes introduit par cette représentation des variables est qu'il devient assez compliqué de déterminer si une variable est libre ou non, comme on peut le constater dans l'exemple ci dessus(exemple 3). Il faut donc introduire la notion d'\(\alpha\) équivalence.

\subsubsection{Alpha equivalence}
On considère que deux termes sont alpha équivalents si et seulement si ils sont 
égaux au renommage de leur variables liées près. 
\begin{example}
  Voici deux termes alpha équivalents 
  \begin{align*}
    & \lambda x.x \leadsto \lambda y.y \\
  \end{align*}
\end{example}
  
\subsection{Calculer dans le lambda calcul}

Dans le lambda calcul pur, il n'existe pas de primitive pour effectuer des 
calculs. Le seul moyen de calculer de nouveaux termes est de les appliquer 
entre eux. Mais il nous faut d'abord étudier le mécanisme de substitution pour 
pouvoir effectuer nos calculs.

\subsubsection{Substitution}

La substitution est un mécanisme central dans le lambda calcul. Cela consiste 
à remplacer l'occurrence d'une variable liée par un \(\lambda\)terme.
On note généralement la substitution de la variable x dans le terme t par le 
terme u avec la notation suivante. 
\[ 
t[x:=u]
\]

\begin{example}
  Soit le terme \(\lambda\)x.x[x:=\(\lambda\)y.y], après avoir effectué la
  substitution nous obtenons le terme \(\lambda\)x.\(\lambda\)y.y
\end{example}


Nous avons analysé un cas de substitution cependant on peut etre confronté 
à devoir substituer dans une application ou une abstraction, voici donc 
les règles pour la substitution 

\begin{align*}
&(u v)[x := z]\leadsto(u[x := z] v[x := z]) \\
&(\lambda .t)[x := z]\leadsto\lambda .t[x := z] \\
\end{align*}

%je ne sais pas exactement quel titre donner a cette partie normalisation 
%ou reduction 
\subsubsection{Reduction}

Seules les applications dont le membre de gauche est une abstraction
peuvent etre réduites, on appelle cela une \emph{redex} . 
C'est à dire que l'application (t u) ne peut pas etre réduite à moins 
que le terme t ne s'évalue en une abstraction, (nous verrons ceci plus
en détail dans la section suivante).

\begin{example}
  Soit le terme ((\(\lambda\)x.\(\lambda\)y.y x) z), ici
  le terme est bien sous la forme d'une application ayant une abstraction comme 
  membre de gauche. La reduction va consister à substituer l'ensemble des 
  variables liées à la première application par le membre de droite de 
  l'application. Ce qui va donc nous donner \(\lambda\)x.\(\lambda\)y.z x
\end{example}

\begin{example}
  Voici un autre exemple de réduction
  \begin{align*}
    & ((\lambda x .\lambda y. z) w) \leadsto \lambda x.\lambda y.z \\
  \end{align*}
  Ici z étant une variable libre il n'y a rien à réduire.
\end{example}


\subsubsection{normalisation}

Un terme est dit sous forme normale si on ne peut plus lui appliquer 
de réduction. La normalisation consiste donc à reduire autant que possible
notre terme.
%changer les fleches 
\begin{example}
  le terme (((\(\lambda\)x.x) (\(\lambda\)y.y)) z) \(\leadsto\) ((\(\lambda\)y.y) y) 
\(\leadsto\) y %saut de ligne
  Ici y n'est plus réductible c'est donc la forme normale du terme.
\end{example}

Le lambda calcul étant un modèle de calcul universel, il permet de 
décrire des termes/programmes qui ne terminent pas : ceux-ci n'ont pas 
de forme normale.

\begin{example}
 
  Le terme suivant n'admet pas de forme normale :
  %
  \begin{align*}
  (\lambda x. x\: x) (\lambda x. x\: x) &\leadsto (x x)[x \mapsto \lambda x. x\: x] \\
                                        &\leadsto (\lambda x. x\: x) (\lambda x. x\: x) \\
                                        &\leadsto \ldots \\
  \end{align*}
\end{example}
%je sais pas si cette partie la est judicieuse je pense que oui ça permet d'
%introduire un peu la suite du rapport 
Nous verrons que dans les sections suivantes que lorsque nous introduirons 
les systèmes de type, nous n'aurons plus de termes qui ne réduisent pas vers 
une forme normale (c'est une des propriétés très intérressante offerte par 
les systèmes de type)

Il existe de nombreuses stratégies de normalisation des termes dans le lambda 
calcul non typé, pour les plus connus: \emph{full Beta-reduction}, \emph{normal order}, 
\emph{call by name}, \emph{call by value}.
Pour le lambda calcul non typé la stratégie la plus sure est la call by value.
En effet, elle consiste à réduire seulement le terme de gauche des redex, et où l'on 
ne reduit pas à l'intérieur des abstractions.
Pour certains termes on ne peut pas atteindre 
une forme normale, cependant celle ci a moins de risque de rentrer dans une boucle
d'évaluation infinie. Nous n'avons pas encore les proprités offertes par les
systèmes de types tel que un terme correctement typé se réduit toujours.

\begin{example}
  Voici un exemple d'évaluation avec la stratégie call bu value
  \begin{align*}
    & ((\lambda x.\lambda y. x\: y)\: \lambda w.w)  \\
    \leadsto & (\lambda y. (\lambda w.w)\: y) 
  \end{align*}
\end{example}





\subsection{Enrichire le lambda calcul}

Maintenant que le noyau de notre language a été défini nous pouvons introduire
de nouvelles constructions qui vont nous permettre d'exprimer des 'choses' %changer ça
telles que les entiers, les booléens ect...

\subsubsection{Les booléens de Church}

Nous allons ici voir une représentation des booléens accompagnée de la 
structure if then else.
Voici les termes correspondants aux constructeurs True et False
\begin{align*}
  &\lambda x.\lambda y. y \mbox{(true)} \\
  &\lambda x.\lambda y. x \mbox{(false)} 
\end{align*}

On assimile ces deux termes aux booléens True et False car leur calcul au sein
de l'application d'un Ifte reproduit le comportement attendu.
Nous pouvons désormais introduire le terme correspondant à la structure de 
controle IfThenElse.
\begin{align*}
  &\lambda x.\lambda y.\lambda z. x\: y\: z \mbox{(Ifte)} \\
\end{align*}

\begin{example}
  Voici un exemple de réduction du terme Ifte
  \begin{align*}
    &(\lambda .\lambda .\lambda . 2\: 1\: 0) \: (\lambda . \lambda . 0) \: x \: y  \\
<<<<<<< HEAD
    & TODO mettre les etapes intermediaires \\
    & x \\
=======
    & %TODO:mettre les étapes intermediaires \\
    % & x 
>>>>>>> 5cc165101157f81f98655e861cfee469c75b56ad
  \end{align*}
\end{example}

Ici nous n'avons aucun moyen de vérifier avant normalisation que le premier
argument de Ifte est un booléen. %broder un peu plus ?

\subsubsection{Les entiers de Church}

Ici, nous allons voir comment créer
les entiers naturels \textit{ex nihilo} en utilisant un \emph{codage à
  la Church}.

L'idée consiste à représenter le nombre \(n\) par une fonction d'ordre
supérieur prenant en argument une fonction \(f\) et l'appliquant \(n\)
fois. On définira donc 
%
\begin{align*}
\mathsf{zero} &= \lambda f. \lambda x. x \\
\mathsf{un}   &= \lambda f. \lambda x. f\: x \\
\mathsf{deux} &= \lambda f. \lambda x. f\: (f\: x)
\end{align*}

Afin de construire tous les entiers naturels, on s'inspire alors de la
définition des entiers de Peano et définit le successeur d'un nombre \(n\)
comme
%
\[
\mathsf{successeur} = \lambda n. \lambda f. \lambda x. n\: f\: (f\: x)
\]
%
c'est-à-dire \(n\) applications de \(f\) précédées d'une première
application de \(f\), soit \(n+1\) applications.

De la même manière, on construit l'addition de deux nombres \(m\) et
\(n\) en faisant \(m\) applications répétées de \(f\) précédées par
\(n\) applications :
%
\[
\mathsf{plus} = \lambda m. \lambda n. \lambda f. \lambda x. m f (n f x)
\]


\subsection{Implementation}

Nous nous attarderons ici sur les choix d'implémentations et il sera question
d'analyser certaines parties du code et non sa totalité.

\subsubsection{Représentation des lambda termes}
%ici j'ai enlever la partie indices de de bruijn je la met ici mais je ne sais pas si le titre est bien 
 
Pour pallier au problème que nous énoncions précédement, il existe une 
représentation pour les variables liées, les indices de de Bruijn.
Nous allons donc maintenant représenter les variables liées non pas par un 
nom mais par un entier naturel. 

\begin{example}
  Le lambda terme représentant l'identité que l'on écrivait \(\lambda x.x\) s'écrira donc maintenant \(\lambda.0\)
\end{example}
Pour représenter les types en Ocaml les types sommes sont très intéressants car 
ils offrent une manipulation souple à l'aide du pattern matching.

\codefrom{untyped}{lambda}{untyped_term}

Cette représentation se rapproche au plus de la spécification formelle, seule la distinction entre les
variables liées (BoundVar) et les variables libres (FreeVar) diffère du fait que l'on utilise désormais 
la représentation avec les indices de de Bruijn.


\subsubsection{Parsing et pretty printing}
Afin de permettre de construire des termes rapidement et le plus lisible 
possible la création d'un parseur s'imposait.
La notation choisie a été la notation préfixe (notation polonaise inversée),
une syntaxe très proche du langage lisp qui en plus d'etre simple à comprendre
est assez facile à parser (à l'aide des bibliothèques de S-expression)
\begin{example}
  Voici un exemple de correspondance entre les termes avant et après parsing
  \begin{align*}
    (lambda\: x \: x) & \leadsto Abs(BoundVar\: 0) \\
    (x\: y) & \leadsto Appl(FreeVar\: 'x',FreeVar\: 'y')       
  \end{align*}
\end{example}

Comme on peut le constater dans l'exemple pour alléger la redaction des termes,
on utilise une représentation des variables classiques, c'est dans le parseur que 
l'on determine la valeur de l'indice d'une variable si celle ci est liée et son 
nom si celle ci est libre.
%Changer la derniere formulation
Pour l'affichage de nos termes on effectue l'opération inverse, c'est à dire que
les chaines de caractères en sortie seront elle memes des S-expressions.



\subsubsection{substitution}

On découvre ici un nouvel avantage de notre représentation avec les indices de
de Bruijn, car il n'est pas nécessaire de prendre des précautions quant au
nom des variables de notre terme substituant % à changer
qui rendrait liée une variable qui était libre. Cela nous permet de ne pas 
avoir besoin d'introduire l'\(\alpha\) convertion

\begin{example}
  Avec la représentation classique: 
  \[ 
  \lambda x.x[x := \lambda y.x]\leadsto\lambda x.\lambda y.x
  \]
  Avec les indices de de bruijn
  \[ 
  \lambda.0[0 := \lambda.x]\leadsto\lambda.\lambda.x
  \]
  On constate bien que dans la première représentation on pense que la variable
  x est liée alors que celle ci devrait en réalité etre libre comme dans la 
  représentation avec les indices de de Bruijn.
\end{example}


\codefrom{untyped}{lambda}{substitution}

L'argument \emph{term} correspond au terme dans lequel on va substituer le terme \emph{tsub} et 
l'argument \emph{var} est un entier qui va nous permettre de compter le nombre de binder \(\lambda\)
traversés. Si l'on recontre une BoundVar avec comme indice var on retourne donc \emph{tsub} à la 
place de celle ci.


\subsubsection{Reduction et évaluation}
La fonction de réduction consiste donc à trouver des redex afin de substituer le 
membre de droite de l'application dans le membre de gauche. Nous appelons la fonction
de réduction avec la valeur 0 car on souhaite substituer l'ensemble des variables
du binder \(\lambda\) en cour.

\codefrom{untyped}{lambda}{reduction}

Nous disposons de l'ensemble des fonctions nécéssaires afin de faire une évaluation 
correspondant à la stratégie d'évaluation call bu value. En voici une implémentation
possible:

\codefrom{untyped}{lambda}{evaluation}

Si l'on trouve une redex on reduit puis l'on evalue le resultat de la reduction,
et si le membre de gauche n'est pas une variable on evalue celui ci pour determiner
si celui ci peut nous donner une abstraction afin de pouvoir effectuer une réduction.
Conformément à la stratégie on n'évalue jamais le membre de gauche d'une application
pour les raisons énoncées dans la section d'évaluation.


\subsubsection{Les booléens}
Afin d'implémenter les boléens dans notre language un choix d'implémentation 
possible est de simplement définir de nouveaux termes True,False et Ifte
comme nous l'avons vu dans la section précédente. Cependant nous avons choisi 
d'enrichir le noyau de notre language en créant trois nouveaux constructeurs.
Cela permet de ne pas alourdir l'écriture de certains termes ainsi que 
d'améliorer la représentation et d'automatiser des opérations d'évaluation.

\codefrom{untyped}{lambda}{bool_term}

Pour la substitution des termes \emph{True} et \emph{False} les règles 
sont triviales. Pour le terme \emph{IfThenElse} il faut rappeler la 
fonction de substitution sur l'ensemble des arguments du constructeur.
Il n'est pas nécéssaire d'incrémenter la valeur de \emph{var} étant donné
que ce constructeur ne lie aucune variables.

\codefrom{untyped}{lambda}{bool_substitution}

Pour la réduction il n'y à pas de réduction possible pour nos termes
ce qui reviens donc a retourner le terme sans aucunes modifications.


Voici enfin la section correspondant à l'évaluation des booléens.
Encore une fois True et False s'évaluant simplement en True et False ils
ne représentent aucune difficulté d'implémentation. En ce qui concerne
le terme \emph{IfThenElse} si le premier argument est \emph{True}
on retourne alors le second argument et on retourne le troisième argument 
dans le cas où la condition serait un \emph{False}. Dans le cas 
où le premier argument ne sera pas un booléens on evalue celui ci pour 
essayer d'obtenir un booléens qui nous permettrait d'évaluer notre 
terme.

\codefrom{untyped}{lambda}{bool_evaluation}


\subsubsection{Les entiers}

Tout comme pour les booléens nous allons ajouté les trois constructeurs 
\emph{Zero},\emph{Succ} et \emph{Iter} à notre language.

\codefrom{untyped}{lambda}{nat_term}

Pour ce qui est de la substitution et la réduction le comportement est très
similaire à celui des boléens et ne nécessite pas d'explications supplémentaires.
%mettre un petit saut a la ligne 
Substitution:

\codefrom{untyped}{lambda}{nat_substitution}

Reduction:

\codefrom{untyped}{lambda}{nat_reduction}

En revanche l'évaluation du terme \emph{Iter(n,f,a)} est déja plus intéressante.
Si le premier argument est \emph{Zero} alors il faut retourner le terme \emph{a}.
Si \emph{n} est un \emph{Succ(num)} alors il faut d'abord evaluer l'application 
\emph{(f a)}. puis rappeler la fonction d'évaluation avec le terme 
\emph{Iter} avec ces nouveaux arguments.

\codefrom{untyped}{lambda}{nat_evaluation}

\section{Le lambda calcul simplement typé}

Introduire la notion de type en règle générale.

\subsection{Les types}

Il est important avant tout de définir ce qu'est un type.
Considérons \emph{P} l'ensemble des types de base comme par exemple 
(\emph{int}) l'ensemble des entiers.
Et soit \emph{T} l'ensemble des types, on peut alors définir de façon inductive
ce qu'est un type.
\begin{align*}
  &\emph{int} \in T \\
  &\forall x,y \in T, x \rightarrow y \in T \\
  &\forall x,y \in T, (x * y) \in T   
\end{align*}

Le type \(\rightarrow\) correpond au type des fonctions et le type (a*b)
correspond au type des couples que nous allons désormais introduire dans notre language.

\begin{example}
  Voici des exemples de type:
  \begin{align*}
  & int \rightarrow int & \mbox{1} \\
  & (int * int) &\mbox{2} \\
  \end{align*}
  Le type (1) est celui d'une fonction prenant un argument de type \emph{int} et 
  retournant un résultat de type \emph{int}.
  Le second type correspond a une pair donc le membre de gauche est un \emph{int}
  et le membre de droit un \emph{int}
\end{example}

Comme nous l'avons vu précédement avec la curryfication qui consistait à exprimer une 
fonction avec plusieurs arguments en une succession de fonctions à un argument, cela 
se répercute aussi sur les types.

\begin{example}
  Soit la fonction \(\lambda\)x\:y.(x y) peut s'exprimer 
  \(\lambda\)x.\(\lambda\)y.(x y) qui pourrait donc avoir 
  le type int \(\rightarrow\) int \(\rightarrow\) int  
\end{example}

\subsection{Système de type}

Introduire le système de type en une ligne
\subsubsection{Système de type mono-directionnel}

Afin de faciliter la lecture et la compréhension nous allons nous intérésser dans 
un premier temps aux règles de typage pour les termes appartenants au noyau 
du language. Nous donnerons les autres règles dans les sections suivantes.

La vérification de type s'effectue dans un \emph{contexte} qui assigne
à chaque variable d'un programme son type. Le contexte est donc une
liste ordonnée de paires variable/type :
%
\begin{align*}
  \Gamma &::= &\mbox{(contexte)} \\
         &\quad . & \mbox{(contexte vide)} \\
         &\quad \Gamma, x : T & \mbox{(type de variable)} 
\end{align*}

Les règles de typage sont définies en Figure~\ref{fig:typage-simple}.

\begin{figure}

\begin{align*}
&  \cfrac{x:T\,\in\Gamma}
         {\Gamma\vdash x:T}\mbox{(Var)} 
  \\
&  \cfrac{\Gamma, x:A \vdash t:B}
         {\Gamma \vdash \lambda x. t \,:\, A\rightarrow B}\mbox{(Abs)} \\
&  \cfrac{\Gamma \vdash f : A\rightarrow B \quad
          \Gamma \vdash s : A}
         {\Gamma\vdash f\: s : B}\mbox{(App)} \\
&  \mathsf{bool}:\mathsf{true}|\mathsf{false}\mbox{(Bool)} \\
&  \cfrac{t1:\mathsf{bool}\,t2:T\,t3:T}
         {\Gamma\vdash if t1 then t2 else t3}\mbox{(If-else)} \\
\end{align*}

\caption{Typage (lambda calcul simplement typé)}
\label{fig:typage-simple}
\end{figure}   

La règle (Var) spécifie le typage des variables. Cette expression se
lit en partant du numérateur pour déduire le dénumérateur : supposons
que la variable x de type T est présente dans le contexte, alors on
conclut que le type de la variable x est T.

La règle (Abs) spécifie le typage des lambda
abstractions. L'abstraction construit un type de la forme \(A
\Rightarrow B\) : il faut donc que la variable associée au lambda
terme soit de type \(A\) et le résultat de type \(B\).

La règle (App) sécifie le typage de l'application. Une application pour etre 
considérée comme une redex doit avoir un membre de gauche une abstraction, 
donc un type A \(A\rightarrow B\) et pour le membre de droite un terme 
de type A. 

\begin{example}
  Voici donc quelques exemples de dérivations de type.
  Ces dérivations se lisent du bas vers le haut.
  
  
  JE PENSE QUE JE VAIS DEVOIR FAIRE DES CFRACS DE CFRACS ECT MAIS SI
  IL EXISTE UNE MEILLEUR SOLUTION JE PREFERE ATTENDRE
  %faire une application basique avec le lambda terme de l'identité a gauche appliqué a un truc nul et le tout de type entier cela 
  % va nous permettre de montrer que l'on doit faire de la magie sur le type de A
\end{example}

%ici je pourrais dire que l'on doit annoter tous les termes mais que c'est trop lourd
%syntaxiquement donc que on préfère introduire le bi-directionnel
Comme nous avons pu le constater dans le dernière exemple il nous manque des informations
afin de pouvoir type-checker une application dont le membre de gauche est une rédex.
Nous allons donc introduire une nouvelle représentation de nos termes afin de résoudre ce 
problème.

\subsubsection{Système de type bi-directionnel}

Les applications dont le membre de gauche est une abstractions posent problème 1
nous allons donc séparer nos \(\lambda\) termes en deux.
D'un coté les termes pouvant se trouver à gauche dans une application et les autres.

\begin{align*}
  ex &::= & \mbox{exTermes} \\
  &| (ex\: in) &\mbox{Appl}\\
  &| x &\mbox{Var} \\
  in &::= & \mbox{inTermes}\\
  &|\lambda x.in &\mbox{Abs}\\
  &|inv(ex) &\mbox{Inv}\\
\end{align*}

On constate tout d'abord qu'un nouveau terme à fait son apparition, \emph{inv}.
Celui ci permet de passer des inTermes aux exTermes. Pour l'instant on ne peut pas
encore faire le chemin inverse, c'est à dire passer des exTermes aux inTermes nous 
l'introduiront par la suite.
On a maintenant résolu notre problème d'avoir une application dont le membre de gauche
est une abstraction, cependant si l'on ne peut plus écrire des termes sous cette forme
cela retire tous les calculs de celui ci.
La principale raison pour laquel nous ne pouvions pas typechecker les abstractions 
dans le membre gauche de l'application était du au manque d'information quand au type 
de celle ci.
On va donc introduire un nouveau terme permettant de passer des exTermes aux inTermes 
mais en demandant de l'information quand à son type, l'annotation.

Voici donc notre nouvelle représentation des termes:

\begin{align*}
  ex &::= & \mbox{exTermes} \\
  &| (ex\: in) &\mbox{Appl} \\
  &| x &\mbox{Var} \\
  &| (in:Type)&\mbox{Ann} \\
  in &::= & \mbox{inTermes} \\
  &|\lambda x.in &\mbox{Abs} \\ 
  &|inv(ex) &\mbox{Inv} \\
\end{align*}

\begin{example}
Voici maintenant la dérivation qui nous possait problème précédement.
FAIRE LA DERIVATION ET CA MARCHE !!
\end{example}

Voici donc nos nouvelles règles de typage en Figure~\ref{fig:typage-simple-bi-direct}.

\begin{figure}

\center\(\Gamma\vdash T \ni t\)  

\begin{align*}
  &\cfrac{T = A \rightarrow B \: \Gamma, x:A \vdash B \ni t}
  {\Gamma \vdash T \ni \lambda x. t}\mbox{(Abs)}&\: \\
  &\cfrac{\Gamma \vdash t \in T' \:\: T=T'}
  {\Gamma\vdash T \ni inv(t)}\mbox{(Inv)} \\
\end{align*}

\center\(\Gamma\vdash t \in T\) 

\begin{align*}
  &\cfrac{x:T \in \Gamma}
  {\Gamma \vdash x \in T }\mbox{(Var)}&\: \\
  &\cfrac{\Gamma \vdash f \in A\rightarrow B \quad \Gamma\vdash A \ni s }
  {\Gamma\vdash f\:s\in B}\mbox{(App)} \\
  &\cfrac{\Gamma\vdash T \ni t}
    {\Gamma\vdash (t:T) \in T}\mbox{(Ann)} \\
\end{align*}

\caption{Typage (lambda calcul simplement typé Bi-directionnel)}
\label{fig:typage-simple-bi-direct} 
\end{figure}   

Les règles de la forme \(\Gamma\vdash T \ni t\) sont des règles de vérification (check),
celles de la forme \(\Gamma\vdash t \in T\) des règles de synthèse.
Pour la vérification on connait le type \emph{T} et l'on souhaite déterminer si le terme \emph{t}
est bien de ce type. Pour la synthèse, on ne connait pas le type de \emph{t} et l'on souhaite le
determiner.

\begin{example}
EXEMPLE DE DERIVATION AVEC LES NOUVELLES REGLES
\end{example}

\subsection{Safety and security anouncement}

\subsection{Operations sur les termes}

Nous avons désormais une nouvelle représentation de nos termes, il nous faut donc 
redéfinir les règles de substitution, de réduction et d'évaluation.
Certaines seront triviales mais 


\section{Les types dépendants}

% pour l'implémentation quand je parle du parser ne pas montrer le code 
% mais expliquer la syntaxe lisp

% pour la prochaine introduction d'implémentation dire que la grosse nouveauté
% c'est le type checker et le fait que on 


%pour le simplement typé quand on introduit la première réduction on peut faire l'analogie avec le compilateur qui une fois que les
%termes on été type checker on peut maintenant oublier les types et maintenant réduire 



%Il faudrait que pour les booléens et tout ce genre de choses je fasse dans la partie formelle des spec correspondants aux evaluations ect..

\end{document}
