\documentclass {article}

%% ** Packages

\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsthm, amssymb, amsmath}
\usepackage{hyperref}
\usepackage{mathpartir}

%% ** OCaml listings

\usepackage{xcolor}
\usepackage{listings}
\lstset{
  language=[Objective]Caml,
  %% emph={[2]Nil,Cons,FZe,FSu,ze,su,Ze,Su},
  %% emphstyle={[2]\Constructor},
  %% emph={[3]lookup,failwith},
  %% emphstyle={[3]\Function},
  %% emph={[4]vec,fin,nat,list,tree,completeTree},
  %% emphstyle={[4]\Canonical},
  morecomment=[s]{(*}{*)},
  rangeprefix=\(\*\=,
  rangesuffix=\ \*\),
  includerangemarker=false,
  extendedchars=\true,
  inputencoding=utf8,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  basicstyle=\ttfamily\small,
  framesep=4mm,
  moredelim=*[s][\itshape]{(*}{*)},
  moredelim=[is][\textcolor{darkgray}]{§}{§},
  escapechar=°,
  keywordstyle=\color[rgb]{0.627451, 0.125490, 0.941176},
  stringstyle=\color[rgb]{0.545098, 0.278431, 0.364706},
  commentstyle=\color[rgb]{0.698039, 0.133333, 0.133333},
  numberstyle=\color[rgb]{0.372549, 0.619608, 0.627451},
  boxpos=t,
  literate= {'a}{{$\alpha$}}1%
    {->}{{${\to}$}}2
    {*}{{${\times}$}}1
    {::}{{${:\::}$}}1
}

\newcommand{\codefrom}[3]
           {\lstinputlisting[linerange={#3}-End]{../#1/#2.ml}}


%% ** Theorem styles 


\newtheorem{theorem}{Théorème}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemme}

\theoremstyle{definition}
\newtheorem{definition}{Définition}
\newtheorem{example}{Exemple}

\theoremstyle{remark}
\newtheorem{remark}{Remarque}
\newtheorem{para}{} 

%% ** commands

\newcommand{\todo}[1]{\textcolor{red}{#1}}
\newcommand{\attention}[1]{\textcolor{orange}{#1}}
\newcommand{\etc}{\textit{etc.}}

\newenvironment{bnf}
               {\[\begin{array}{lcl@{\qquad}r}}
               {\end{array}\]}

\newcommand{\fun}[1]{\lstinline!#1!}
%% ** Title

\title{Théorie des Types Dépendants\\Conception et Implémentation}
\author{Roman Delgado}
\date{}


\begin{document}

\maketitle


%% ** Abstract 

\todo{Mettre un coup de ispell}

\begin{abstract} 
  Ce document représente l'ensemble du travail effectué durant l'unité d'enseignement 3I013 de l'\textsc{upmc}. \attention{Cet abstract n'apporte pas grand chose : le supprimer ?}
\end{abstract}

\setcounter{tocdepth}{2}
\tableofcontents

\clearpage

%% ** Main

\section{Introduction}


Un language de compilation est entièrement définis par son compilateur. En effet ce logiciel permet de traduire
des programmes écris dans un language en instructions pour le compilateur.... \todo{à terminer}

Il sera donc question dans ce rapport de comprendre le typage, une des étapes de la chaine de compilation.
Pour résumé brievement le compilateur 
traduit d'abord le texte écris par le programmeur en un arbre de syntaxe abstraite. Cette représentation est ensuite utilisable
dans un algorithme.
Si le compilateur ne génère pas d'erreur durant cette étape on dit que le programme est syntaxiquement correcte. Cependant 
le programmeur à pu écrire des instructions tels que \lstinline!x = 2 + true!. Meme si cette instruction est syntaxiquement correcte, celle ci 
n'a aucun sens. Il lui faut maintenant à partir de l'arbre de syntaxe abstraite générer du code assembleur, un code compréhensible 
par les microprocesseurs. Le compilateur peut très bien générer une suite d'instructions assembleurs correspondant à l'expression 
précédente, c'est durant l'execution du programme que le processeur va interompre le programme. Lorsque ces erreurs surviennent il est 
très compliqué de trouver la source de celle ci car l'instruction fautive ne correspond pas au code écrit par le programmeur. 
Pour évitez ce genre d'erreurs qui peuvent survenirs très longtemps après le lancement du programme (les serveurs par exemple), 
il nous faut donc vérifier la validité de celui ci. Il faut donc rajouter une étape dans la chaine de compilation grace au typage 
assuré par l'analyseur de type.
L'intéret du typage est donc de vérifier que le programme s'executera correctement, sans avoir besoins d'éxecuter celui ci. 
Il permet aussi d'obtenir des informations très précises sur la sources des erreurs.

\section{$\lambda$-calcul non typé}
\label{sec:untyped}

\todo{Il reste des ``lambda'' qui devraient être des $\lambda$.}

En 1936, Alonzo Church introduit le $\lambda$-calcul non typé
~\citep{church:lambda-calcul}. Le $\lambda$-calcul est
un modèle de calcul universel, tout comme les machines de Turing. Celui-ci repose
sur une syntaxe minimaliste capturant exactement la notion de fonction. Ce formalisme est au c\oe{}ur de nombreuses recherches dans le domaine de la 
programmation fonctionnelle. Le lambda calcul non typé a connu un formidable 
succès pratique, donnant lieu à de multiples variantes dont on trouvera une présentation
 moderne et synthétique dans l'ouvrage de ~\citet{pierce:tapl}.

\subsection{Syntaxe}
Le $\lambda$-calcul est composé uniquement de \(\lambda\)-termes dont voici la syntaxe

\newcommand{\Lam}[2]{\ensuremath{\lambda #1. #2}}
\newcommand{\App}[2]{\ensuremath{#1\:#2}}
\newcommand{\Var}[1]{\ensuremath{#1}}
\newcommand{\Fst}[1]{\ensuremath{#1.\pi_0}}
\newcommand{\Snd}[1]{\ensuremath{#1.\pi_1}}
\newcommand{\Pair}[2]{\ensuremath{(#1, #2)}}
\newcommand{\ifte}[3]{\ensuremath{\mathsf{if}\: #1\: \mathsf{then}\: #2\: \mathsf{else}\: #3}}
\newcommand{\true}{\ensuremath{\mathsf{true}}}
\newcommand{\false}{\ensuremath{\mathsf{false}}}
\newcommand{\zero}{\ensuremath{\mathsf{zero}}} 
\newcommand{\succs}{\ensuremath{\mathsf{succ}}}
\newcommand{\iter}{\ensuremath{\mathsf{iter}}}


\begin{bnf}
  t &::= & &\mbox{(lambda terme)} \\
  &|& \Var{x} & \mbox{(variable)} \\
  &|& \Lam{x}{t} & \mbox{(abstraction)} \\
  &|& \App{t}{t}          & \mbox{(application)}
\end{bnf}

Pour faire une analogie avec les mathématiques, une abstraction peut
être vue comme une définition de fonction anonyme.
 
\begin{example}
 La fonction identité est définie par le $lambda$-terme suivant : $\Lam{x}{\Var{x}}$
\end{example}

On peut constater avec cette syntaxe que les abstractions ne prennent
qu'un seul argument. Cependant, l'ensemble des fonctions à plusieurs
arguments peut etre représenté, par curryfication, à l'aide une
succession de fonctions à un seul argument.

\begin{example}
  \label{example:id}
  La fonction \Lam{\Pair{x}{y}}{t}, qui a deux arguments \Var{x} et \Var{y},
  correspond au $\lambda$-terme $\Lam{x}{\Lam{y}{t}}$
\end{example} 


\subsubsection{Variables libres et variables liées}

\newcommand{\IsFree}{\mathrm{isFree}}

\todo{Erreur courrante : celle ci $\to$ celle-ci, pareil au masculin, pluriel, \etc}

Une variable est \emph{liée} lorsque celle ci est déclarée dans le corps d'un
lambda. Dans l'Exemple~\ref{example:id}, $x$ était ainsi une variable \emph{liée}.
Si la variable n'a pas été déclarée, elle est dite
\emph{libre}. Formellement, l'ensemble des variables \emph{libres} d'un terme est
défini récursivement de la façon suivante
%
\begin{align*}
  \IsFree(x) &\triangleq \{x\} \\
  \IsFree(\lambda x. t) &\triangleq \IsFree(t) \backslash \{x\} \\
  \IsFree(f s) &\triangleq \IsFree(f) \cup \IsFree(s) \\
\end{align*}

Comme les abstractions lient les variables, elles sont comunéments appelées des \emph{lieurs}

\begin{example}
  Dans le terme \(\Lam{x}{\Lam{y}{\App{\App{\Var{x}}{\Var{y}}}{\Var{z}}}}\), 
  les variables $\Var{x}$ et $\Var{y}$ sont liées tandis que la variable $\Var{z}$ est libre 
\end{example}


Un terme ne contenant aucune occurrence de variable \emph{libre} est dit \emph{clos}.

\begin{example}  
  \label{example:ouvert-clos}  
  Dans le $\lambda$-terme
  \App{(\Lam{x}{\Lam{y}{\App{x}{y}}})}{\Var{y}}, la variable \Var{x}
  ainsi que la première occurence de la variable \Var{y} sont
  liées. Cependant, la seconde occurence de variable \Var{y} est
  libre.
\end{example}


\subsubsection{$\alpha$-équivalence}
\label{alpha_equiv}
\label{problemelibreliee}

\newcommand{\equivAlpha}{\mathop{\equiv_\alpha}}

Le problème avec cette représentation est que les termes
\Lam{\Var{x}}{\Var{x}} et \Lam{\Var{y}}{\Var{y}} sont \textit{a
  priori} distincts du fait des noms de variable utilisés. Or cette
distinction n'est pas souhaitable : ces deux termes représentent de
façon équivalente la fonction identité, indépendamment du choix de nom
de variable. Nous introduisons donc la notion d'$\alpha$-équivalence.

On considère que deux termes sont \(\alpha\)-équivalents si et seulement si ils sont 
égaux à renommage de leur variables liées près. 
\begin{example}
  Voici deux termes \(\alpha\)-équivalents 
  \begin{align*}
    & \Lam{x}{\Var{x}} \equivAlpha \Lam{y}{\Var{y}} \\
  \end{align*}
\end{example}

\subsubsection{Représentation concrète}
 
Pour pallier à la Remarque~\ref{problemelibreliee}, notre implémentation utilise une représentation
particulière pour les variables liées: les indices de de Bruijn.  Nous
allons ainsi représenter les variables liées non pas par un nom mais
par un entier naturel. Cette valeur est determiné à partir du nombre
d'abstractions entre la variable et l'abstraction qui l'introduit.

\begin{example}
  Le $\lambda$-terme représentant l'identité, que l'on écrivait \(\lambda x.x\), est représenté par \(\lambda.0\)
  et le terme $\Lam{x}{\Lam{y}{x}}$ est représenté par $\lambda.\lambda.1$ 
\end{example}

\todo{Ne pas trop utiliser emph dans le texte. On l'utilisera, par
  exemple, la première fois que l'on définit un terme.}

Tandis que les variables liées seront representées par des
indices de de Bruijn, les variables libres quant à elle seront
représentées par un (unique) nom de variable, comme dans la
présentation formelle. Une telle représentation est traditionnellement
appelée ``locally nameless''~\citep{chargueraud:locally-nameless}

\begin{example}
  \todo{Donner l'exemple de réduction sous un binder}
  Soit \Var{x} une variable libre.
  \todo{roman: je ne me suis jamais penché sur ce problème il faut que je lise pierce}
  En théorie :
  \(\App{(\Lam{\Var{y}}{\Var{y}})}{\Var{x}} \leadsto \Var{x}\)

  En pratique avec des de Bruijn : \todo{montrer le problème et parler des shifts}

  En pratique avec du locally nameless : \todo{montrer l'absence de problème}

\end{example}

Voici le code Ocaml traduisant cette définition inductive des termes :
%
\codefrom{untyped}{lambda}{untyped_term}

Cette représentation se rapproche au plus de la spécification formelle
: seule la distinction entre les variables liées (\lstinline!BoundVar!)
et les variables libres (\lstinline!FreeVar!) diffère.



  
\subsection{Calculer dans le lambda calcul}
\label{calculer_dans_le_lambda_calcul}

Dans le lambda calcul pur, il n'existe pas d'opérations primitives, comme l'addition ou la multiplication d'entiers par exemple. Le seul moyen de calculer de nouveaux termes est de les appliquer 
entre eux. Mais il nous faut tout d'abord définir le mécanisme de substitution par lequel se réalise la notion de calcul.

\subsubsection{Substitution}

\newcommand{\subst}[3]{#1[#2 := #3]}


La substitution est un mécanisme central dans le lambda calcul. Cela consiste 
à remplacer l'occurrence d'une variable liée par un \(\lambda\)-terme.
On note \(\subst{t}{x}{u}\) la substitution de la variable $\Var{x}$ dans le terme $\Var{t}$ par le 
terme u.

Formellement, la substitution est définie par récursion sur le $\lambda$-terme : 
\begin{align*}
    \subst{x}{x}{u} &\triangleq u \\
    \subst{x}{y}{u} &\triangleq x & (x \neq y)\\
    \subst{\lambda x.t}{x}{u} &\triangleq \lambda x.t \\
    \subst{\lambda y.t}{x}{u} &\triangleq \lambda y. (\subst{t}{x}{u}) & (x \neq y)\\
    \subst{(t\: v)}{x}{u} &\triangleq \subst{t}{x}{u}\: \subst{v}{x}{u}
\end{align*}

\begin{example}
  Considérons le terme $\subst{(\Lam{z}{x})}{x}{\Lam{y}{y}}$. Après substitution, nous obtenons le terme $\Lam{z}{\Lam{y}{\Var{y}}}$.
\end{example}


\paragraph{Implémentation :} 
La substitution de la variable liée \lstinline!var! par le terme
\lstinline!tsub! dans \lstinline!term! est implémentée par la fonction suivante:
\todo{Retirer le Let, au moins dans le code présenté. Caché DefVar du code présenté : c'est une source de complexité inutile.}
%
\codefrom{untyped}{lambda}{substitution}

L'argument \fun{var} compte le nombre de \emph{lieurs} traversés.
Cette valeur correspond donc à la valeur de la variable liée à substituer. C'est pour cette
raison que dans le cas où \fun{terme} est une variable liée d'indice \fun{x} on test l'égalité entre 
\fun{var} et \fun{x} et effectue la substitution le cas échéant.


\begin{example}
  Soit le terme t = \Lam{y}{\App{x}{y}} où \Var{x} est liée à
  l'abstraction la plus proche (indice 0).

  En OCaml, ce terme est représenté par 
  %
  \begin{lstlisting}
    Abs ("y", Appl (BoundVar 1, BoundVar 0))
  \end{lstlisting}

  Voici le déroulement de l'appel à la fonction de substitution sur \Var{x} :
  \begin{lstlisting}
      substitution t 0 (FreeVar "z")
  ->  substitution (Abs ("y", Appl (BoundVar 1, BoundVar 0))) 0 (FreeVar "z")
  ->  Abs("y", substitution (Appl (BoundVar 1,BoundVar 0)) 1 (FreeVar "z"))
  ->  Abs("y", Appl(substitution (BoundVar 1) 1 (FreeVar "z"), 
                    substitution (BoundVar 0) 1 (FreeVar "z")))
  ->  Abs("y", Appl(FreeVar "z", 
                    substitution (BoundVar 0) 1 (FreeVar "z")))
  ->  Abs("y", Appl(FreeVar "z", BoundVar 0))
  \end{lstlisting}

  Nous obtenons donc le terme attendu, soit \Lam{\Var{y}}{\App{\Var{z}}{\Var{y}}}.
\end{example}

\subsubsection{$\beta$-réduction}
\label{reduction}


Seules les applications de la forme \(\App{(\Lam{\Var{x}}{t})}{u}\),
dont le membre de gauche est une abstraction, peuvent être réduites :
un tel terme s'appelle un
\emph{redex}~\citep{krivine:lambda-calculus}. Le terme
\(\subst{t}{x}{u}\), obtenu après réduction, est appelé son
\emph{contracté}.

\begin{example}
  Le terme \(\App{(\Lam{x}{x})}{u}\) est  un redex tandis que le terme
  \(\App{x}{u}\) n'en est pas un.
\end{example}

\newcommand{\Red}{\leadsto}
\newcommand{\Conv}{\leadsto^{*}}

Formellement, on définit la \(\beta\)-réduction par induction sur les
termes :
\[\begin{array}{c}
  \inferrule{{}}
            {\App{(\Lam{\Var{x}}{t})}{u} \Red \subst{t}{x}{u}}
  \medskip\\
  \inferrule{t \Red t'}%
            {\Lam{\Var{x}}{t} \Red \Lam{\Var{x}}{t'}}
  \medskip\\
  \inferrule{t \Red t'}
            {\App{t}{u} \Red \App{t'}{u}}
  \medskip\\
  \inferrule{u \Red u'}
            {\App{t}{u} \Red \App{t}{u'}}
\end{array}\]

On obtient la \(\beta\)-conversion en prenant la clôture reflexive et
transitive \(t \Conv t'\) de la \(\beta\)-réduction : on a \(t \Conv
t'\) s'il existe une suite de \(\beta\)-réductions telles que \(t \Red
\ldots \Red t'\).

\begin{example}
  Soit le terme \(\App{(\Lam{x}{\Lam{y}{\App{y}{x}}})}{z}\).  Ce terme
  contient un redex : il est composé d'une application ayant une
  abstraction comme membre de gauche. La réduction consiste à
  substituer la variable liée dans la première abstraction par le
  membre droit de l'application. Son contracté est
  \(\Lam{y}{\App{y}{z}}\)
\end{example}

\begin{example}
  Voici un autre exemple de réduction
  \begin{align*}
    & \App{(\Lam{x}{\Lam{y}{y}})}{w} \leadsto \Lam{y}{y} \\
  \end{align*}
  \Var{x} n'étant pas utilisé dans la fonction, l'argument \Var{w} disparaît complètement.
\end{example}


\subsubsection{Stratégie de réduction : appel par nom}

\label{reduction:call_by_name}
Un terme est dit en \emph{forme
  normale} si on ne peut plus lui
appliquer de réduction: il ne contient aucun redex. La \emph{normalisation}
consiste à reduire autant que possible notre terme. En
particulier, on caractérise inductivement les formes normales de la
façon suivante :
%
\begin{itemize}
\item Une variable \(\Var{x}\) est en forme normale ;
\item Si \(t\) est en forme normale, alors \(\Lam{\Var{x}}{t}\) est en
  forme normale ;
\item Si \(t\) et \(u\) sont en forme normale et que \(u\) n'est pas
  une abstraction, alors \(\App{t}{u}\) est en forme normale.
\end{itemize}

On en déduit qu'un terme est en forme normale si et seulement s'il est
de la forme
\(\Lam{\Var{x_0}}\ldots\Lam{\Var{x_k}}\App{\App{\App{x_i}{t_0}}{\ldots}}{t_l}\)
où les \(t_j\) sont eux-mêmes des termes normaux.

\begin{example}[Terme en forme normale]
  \todo{\(\Lam{\Var{x}}{\Var{x}}\)}
\end{example}

On dira qu'un terme \(t\) est \emph{normalisable} s'il existe un terme
normal \(t'\) tel que \(t \Conv t'\). Un terme \(t\) est
\emph{fortement normalisable} s'il n'existe aucune suite infinie de
réduction à partir de \(t\). Un terme fortement normalisable est,
\textit{a fortiori}, un terme normalisable.

\begin{example}
 \label{paradoxe}
  Le terme suivant n'admet pas de forme normale :
  %
  \begin{align*}
    \omega &\triangleq (\lambda x. x\: x) (\lambda x. x\: x) \\
           &\leadsto (x x)[x \mapsto \lambda x. x\: x] \\
           &\leadsto (\lambda x. x\: x) (\lambda x. x\: x) \\
           &\leadsto \ldots \\
  \end{align*}
\end{example}

\begin{example}[Terme normalisable mais pas fortement normalisable]
  \todo{\(\App{(\Lam{\Var{x}}{0})}{\omega}\)}
\end{example}

Un terme normalisable (mais pas \emph{fortement} normalisable) pourra
donc diverger ou retourner une forme normale selon les réductions
effectuées lors de la conversion : l'ordre dans lequel sont effectuées
ces réductions est donc important. Nous considérons ici une
\emph{stratégie} de réduction qui, pour tout terme normalisable, est assurée d'obtenir une forme
normale : il s'agit de la réduction en
\emph{appel par nom}.

On remarque tout d'abord que tout terme \(t\) du \(\lambda\)-calcul
s'écrit sous la forme
%
\[
\Lam{\Var{x_0}}\Lam{\Var{x_m}}\App{\App{\App{k}{t_0}}{\ldots}}{t_n}
\]
%
où \(k\) est soit une variable soit un redex (le \emph{redex de tête})
tandis que les \(t_i\) sont des termes quelconques (et donc eux-même
de cette forme).


Un terme est en \emph{forme normale de tête} lorsque \(k\) est
nécessairement une variable : le redex le plus à gauche du terme est
``bloqué'' sur une variable et ne peut donc réduire.

La stratégie d'\emph{appel par nom} consiste à contracter
successivement le redex de tête (et uniquement ce redex). 

\newcommand{\CBN}{\mathop{\leadsto_N}}

\[\begin{array}{c}
\inferrule{{}}
          {\App{(\Lam{\Var{x}}{t})}{u} \CBN \subst{t}{x}{u}}
          \medskip\\
          \inferrule{t \CBN t'}
                    {\App{t}{u} \CBN \App{t'}{u}}
                    \medskip\\
                    \inferrule{{}}
                              {\Lam{x}{t}\Red \Lam{x}{t}}
                              \medskip\\
                              \inferrule{{}}
                                        {x\Red x}
                                        
\end{array}\]



Crucialement, nous avons la propriété suivante~\citep[th.3,
  p.62]{krivine:lambda-calculus} :
%
\begin{proposition}
  Un terme \(t\) normalise vers une forme normale de tête si et
  seulement la stratégie d'appel par nom termine (donnant un terme en
  forme normale de tête).
\end{proposition}


Il existe d'autres stratégies de réduction comme par exemple
\emph{l'appel par valeur}, qu'implémente OCaml. Bien que plus
efficace, l'appel par valeur diverge pour certains termes normalisant.
Dans le contexte du \(\lambda\)-calcul non typé, où les termes ne sont
pas tous fortement normalisable, on privilégiera la réduction en appel
par nom.

\todo{Utiliser les macros Lam, etc.}
\begin{example}
  \begin{align*}
    (((\lambda x.x) (\lambda y.y)) z) &\leadsto ((\lambda y.y) z) \\
    & \leadsto z
  \end{align*}
  Ici \Var{z} n'est plus réductible, c'est donc la forme normale du terme.
\end{example}


\begin{example}
  Voici une réduction en appel par nom:
  \begin{align*}
    & \App{(\Lam{x}{\Var{x}})}({\App{(\Lam{y}{\Var{y}})}({\Lam{z}{\App{(\Lam{x}{\Var{x}})}{\Var{z}}}}})) \\
    \rightarrow & \App{(\Lam{y}{\Var{y}})}({\Lam{z}{\App{(\Lam{x}{\Var{x}})}{\Var{z}}}})\\
    \rightarrow & \Lam{z}{\App{(\Lam{x}{\Var{x}})}{\Var{z}}}
  \end{align*}
  Le terme obtenu est en forme normale de tête.
\end{example}

Dans les sections suivantes, nous verrons lorsque nous introduirons
les systèmes de type que l'on peut statiquement garantir que les
termes acceptés par l'analyse de type sont fortement normalisants.

\attention{Question classique : si tu ne peux plus écrire de
  programmes qui ne terminent pas, tu n'es plus Turing complet donc tu
  es strictement moins expressif que tous les langages de
  programmation existants. Est-ce gênant ?}


\paragraph{Implémentation :}
La fonction de $\beta$-réduction consiste donc à contracter une
application dont le membre de gauche est une abstraction. Le cas
échéant, l'opération échoue. Pour ce faire, nous appelons la fonction
de substitution pour substituer la première variable (d'indice \(0\))
par l'argument dans le corps de la fonction :
%
\codefrom{untyped}{lambda}{reduction}

Les seuls termes pouvant se réduire étant les redex, nous effectuons la substitution sur celle ci,
sinon le terme est retourné sans modifications.
Passons maintenant à l'évaluation:

\codefrom{untyped}{lambda}{evaluation}

La fonction \fun{eval} nous permet de détecter les applications afin den évaluer le membre de gauche.
Nous .......... \todo{à finir.}

\subsection{Encodages à la Church}

Bien que le $\lambda$-calcul soit un language minimaliste, Church~\citet{church:lambda-calcul} a montré que l'on peut
y \emph{encoder} de nombreux types de donnés familiers aux développeurs, tels que
les entiers et les booléens.


\subsubsection{Les booléens de Church}
\label{church-bool}

\newcommand{\True}{\ensuremath{\mathit{true}}}
\newcommand{\False}{\ensuremath{\mathit{false}}}
\newcommand{\Ifte}{\ensuremath{\mathit{ifte}}}

Nous allons ici voir une représentation des booléens accompagnée de la 
structure de contrôle \texttt{if ... then ... else ...}.
Voici les termes correspondants aux constructeurs \True{}, \False{} et 
\Ifte{} :
\begin{align*}
  \True &\triangleq  \Lam{x}{\Lam{y}{\Var{y}}} \\
  \False &\triangleq \Lam{x}{\Lam{y}{\Var{x}}} \\
  \Ifte &\triangleq \Lam{l}{\Lam{m}{\Lam{n}{\App{\Var{l}}{\App{\Var{m}}{\Var{n}}}}}}  \\
\end{align*}

On assimile ces deux termes aux booléens \True{} et \False{} car leur calcul au sein
de l'application d'un \Ifte{} reproduit le comportement attendu.

\begin{example}
  Voici un exemple de réduction du terme \Ifte{} appliqué à la condition \False{} :
  \begin{align*}
    \App{\App{\App{\Ifte}{\False{}}}{\Var{v}}}{\Var{w}}  \triangleq&\: \App{\App{\App{(\Lam{l}{\Lam{m}{\Lam{n}{\App{\App{l}{m}}{n}}}}})({\Lam{x}{\Lam{y}{y}}}}){v}}{w} \\
    \rightarrow &\: \App{\App{({\Lam{m}{\Lam{n}{\App{\App({\Lam{x}{\Lam{y}{y}}}){m}}{n}}}}}){v}}{w} \\
    \rightarrow &\: \App{(\Lam{n}{\App{\App({\Lam{x}{\Lam{y}{y}}}){v}}{n}})}{w} \\
    \rightarrow &\: \App{\App({\Lam{x}{\Lam{y}{y}}}){v}}{w}) \\
    \rightarrow &\: \App({\Lam{y}{y}}){w}) \\
    \rightarrow &\: \Var{w}
  \end{align*}
\end{example}

Ici nous n'avons aucun moyen de vérifier avant normalisation que le
premier argument de \Ifte{} est effectivement un booléen : nous ne
pouvons donc pas garantire la bonne évaluation de notre terme.

\begin{remark}
  Les languages orientés objets permettent de représenter ce type d'encodage d'une manière particulière.
  Voici la représentation avec le language Java:
  \begin{lstlisting}[language=java]
    class foo {
      String bar(int x, int y){
        return 0;
      }
    }
  \end{lstlisting}

  \todo{Roman: je ne sais pas encore avec quel moyen je vais le rediger}
\end{remark}


\subsubsection{Les entiers de Church}

\newcommand{\Zero}{\mathit{zero}}
\newcommand{\Un}{\mathit{un}}
\newcommand{\Deux}{\mathit{deux}}
\newcommand{\Succ}{\mathit{successeur}}
\newcommand{\Plus}{\mathit{plus}}


Ici, nous allons voir comment créer les entiers naturels \textit{ex
  nihilo} en utilisant un encodage à la Church. L'idée consiste à
représenter le nombre \(n\) par une fonction d'ordre supérieur prenant
en argument une fonction \Var{f} et l'appliquant \(n\) fois à un
argument \Var{x}. On définira donc
%
\begin{align*}
\Zero &\triangleq \Lam{f}{\Lam{x}{x}}\\ 
\Un   &\triangleq \Lam{f}{\Lam{x}{\App{f}{x}}} \\
\Deux &\triangleq \Lam{f}{\Lam{x}{\App{f}{(\App{f}{x}})}}
\end{align*}

Afin de construire tous les entiers naturels, on s'inspire alors de la
définition des entiers de Peano et définit le successeur d'un nombre \(n\)
comme
%
\[
\Succ \triangleq \Lam{n}{\Lam{f}{\Lam{x}{\App{\App{n}{f}}{(\App{f}{x})}}}}
\]
%
c'est-à-dire \(n\) applications de \(f\) précédées d'une première
application de \(f\), soit \(n+1\) applications.

De la même manière, on construit l'addition de deux nombres \(m\) et
\(n\) en faisant \(m\) applications répétées de \(f\) précédées par
\(n\) applications :
%
\[
\Plus \triangleq \Lam{m}{\Lam{n}{\Lam{f}{\Lam{x}{\App{\App{m}{f}}{(\App{\App{n}{f}}{x}})}}}}
\]


\subsection{Extensions}

Nous nous attardons ici sur quelques choix d'implémentation et il
sera question d'analyser certaines parties du code et non sa totalité.

\subsubsection{Les booléens}

\newcommand{\NTrue}{\lstinline!True!}
\newcommand{\NFalse}{\lstinline!False!}
\newcommand{\NIfte}{\lstinline!IfThenElse!}

Afin d'implémenter les boléens dans notre language, une possibilité
consiste à exporter l'encodage à la Church des termes \True{},
\False{} et \Ifte{} définis en Section~\ref{church-bool}. Cependant
nous avons choisi d'enrichir le noyau de notre language afin de
supporter, de façon primitive, les booléens. Cela permet d'alléger
l'écriture des termes mais surtout de faciliter la représentation et,
par la suite, la compilation des programmes manipulant des expressions
booléennes.


Nous allons donc étendre la grammaire de nos $\lambda$-termes
\begin{bnf}
  t &::= & (\ldots) &\mbox{(lambda terme)} \\
  &|& \true & \mbox{(true)} \\
  &|& \false & \mbox{(false)} \\
  &|& \ifte{t}{t}{t} & \mbox{(ifte)}
\end{bnf}
%
ainsi que notre implémentation
%
\codefrom{untyped}{lambda}{bool_term}

Pour la substitution des constructeurs \NTrue{} et \NFalse{}, les règles
sont triviales. Pour le terme \NIfte{}, il faut rappeler la fonction de
substitution sur l'ensemble des arguments du constructeur.  En
particulier, il n'est pas nécéssaire d'incrémenter la valeur de
\lstinline!var! étant donné que ce constructeur ne lie aucune
variables.


La réduction est étendue au-delà de la \(\beta\)-réduction par une
relation de \(\iota\)-réduction, correspondant à la réduction du test
conditionnel \ifte{\ldots}{\ldots}{\ldots} face aux booléens \true{}
ou \false{} :
%
\[\begin{array}{c}
  \inferrule{{}}
            {\ifte{\true}{u}{v} \Red u}
  \medskip\\
  \inferrule{{}}
            {\ifte{\false}{u}{v} \Red v}
  \medskip\\
  \inferrule{t \Red t'}
            {\ifte{t}{u}{v} \Red \ifte{t'}{u}{v} }
\end{array}\]


L'implémentation de cette réduction ne présente pas de difficulté
particulière :
\codefrom{untyped}{lambda}{bool_evaluation}


\subsubsection{Les entiers}

\newcommand{\nat}{\ensuremath{\mathit{nat}}}
\newcommand{\NZero}{\lstinline!Zero!}
\newcommand{\NSucc}{\lstinline!Succ!}
\newcommand{\NIter}{\lstinline!Iter!}

Tout comme pour les booléens, il nous faut enrichire la grammaire
formelle du $\lambda$-calcul
%
\begin{bnf}
  t &::= & (\ldots) &\mbox{(lambda terme)} \\
  &|& \zero & \mbox{(zero)} \\
  &|& \succs\: t & \mbox{(succ)} \\
  &|& \iter\: t\:t\:t & \mbox{(iter)}
\end{bnf}
%
ainsi que sa réalisation dans l'implémentation
%
\codefrom{untyped}{lambda}{nat_term}

Ces trois constructeurs n'étant pas des lieurs, l'implémentation de la
substitution est triviale.

La \(\iota\)-réduction du terme \NIter se définit ainsi:
%
\[\begin{array}{c}
  \inferrule{{}}
            {\iter\:(\succs\:n)\:f\:a\Red \iter\:n\:f\:(\App{f}{a})}
  \medskip\\
  \inferrule{{}}
            {\iter\:\zero\:f\:a\Red a}
  \medskip\\
  \inferrule{t \Red t'}
            {\iter\:t\:f\:a\Red \iter\:t'\:f\:a}
\end{array}\]



Voici l'implémentation de l'évaluation de iter:
\codefrom{untyped}{lambda}{nat_evaluation}
Nous rappelons donc la fonction avec cette fois ci \fun{(f a)} et le prédécesseur de \fun{n}.

\subsubsection{Les paires}
\label{paires}

\todo{Utiliser les macros Fst et Snd pour écrire les projections, et
  Pair pour construire des paires.}

La paire est une construction très répandue dans les languages fonctionnelles, 
cela nous permet de crée un ensemble de deux éléments. Afin d'utiliser nos paires 
nous utiliserons les projections $\pi0$ et $\pi1$. Celles ci nous permettent 
d'obtenir respectivement le premier élément ou le second de la paire.

\begin{bnf}
  t &::= &....... &\mbox{(lambda terme)} \\
  &|& (t,t) & \mbox{(pair)} \\
  &|& \pi0\:t & \mbox{($\pi$0)} \\
  &|& \pi1\:t & \mbox{($\pi$1)} 
\end{bnf}

\codefrom{untyped}{lambda}{pair_term}

La substitution s'éffectue sans incrémenter \fun{var} car aucuns de ces constructeurs 
ne sont des lieurs.
L'évaluation d'une paire ainsi que celle des projections est la suivante:
\[\begin{array}{c}
  \inferrule{{t\Red t'\:\:\:\:u\Red u'}}
            {(t,u)\Red (t',u')}
  \medskip\\
  \inferrule{{t \Red (u,v)}}
            {\pi0 t\Red u}
  \medskip\\
  \inferrule{{t \Red (u,v)}}
            {\pi1 t\Red v}
\end{array}\]

Implémentons donc ces règles:
\codefrom{untyped}{lambda}{pair_evaluation}
La réduction des membres de la paire se fera dans la fonction d'évaluation.

\todo{Roman: implémenter les paires dans le prog}

\section{Le $\lambda$-calcul simplement typé}

Nous allons maintenant enrichire notre $\lambda$-calcul non typé avec des types. Cela va nous donner des propriétés quand
à l'évaluation de nos termes et leur utilisation. Nous verrons que dans le $\lambda$-calcul simplement typé il
n'existe plus de paradoxes comme dans l'exemple \ref{paradoxe}. Dans un premier temps nous introduirons les 
types, puis nous verrons comment les utiliser en définissant des règles de typage pour nos termes.


\subsection{Les types}
\label{simple_type}


\newcommand{\intg}{\ensuremath{\mathit{int}}}
\newcommand{\bool}{\ensuremath{\mathit{bool}}}

Il est important avant tout de définir ce qu'est un type. Les types
que nous considérons dans cette partie sont décrits par la grammaire
suivante :
%
\begin{bnf}
  T &::=& &\mbox{(type)}\\
  &|& \intg{} &\mbox{(entiers)}\\ 
  &|& \bool{} &\mbox{(booléens)}\\
  &|& T \rightarrow T &\mbox{(fonction)}\\
  &|& T \times T &\mbox{(produit)}\\
\end{bnf}

\begin{example}
  Voici des exemples de type:
  \begin{eqnarray}
    \intg \rightarrow \bool  \label{eq_1}  \\
    \bool \times \intg \label{eq_2} 
  \end{eqnarray}
  Le type (\ref{eq_1}) est celui d'une fonction prenant un argument de type entier et 
  retournant un résultat de type booléen.
  Le second type (\ref{eq_2}) correspond a une paire donc le membre de gauche est un booléen
  et le membre de droite un entier.
\end{example}

\paragraph{Implémentation :}

La spécification des types se traduit naturellement en OCaml :
%
\codefrom{typed}{lambda}{Type}


\subsection{Système de type}

Il est maintenant temps d'introduire notre système de type. Celui-ci va nous permettre de vérifier que nos termes 
sont normalisables. Le but est donc de formaliser une règle de typage pour chacuns de nos termes.

\subsubsection{Spécification}

Afin de faciliter la lecture et la compréhension nous allons dans 
un premier temps donner les règles de typage pour les termes appartenants au noyau 
du language. Nous donnerons les autres règles dans les sections suivantes.

La vérification de type s'effectue dans un \emph{contexte} qui assigne
à chaque variable d'un programme son type. Le contexte est donc une
liste ordonnée de paires variable/type :
%

\begin{bnf}
  \Gamma &::=& &\mbox{(contexte)} \\
         &|& . & \mbox{(contexte vide)} \\
         &|& \Gamma, x : T & \mbox{(type de variable)} 
\end{bnf}


\begin{figure}
\[
\begin{array}{c}
\inferrule[(Var)]%
             {x:T\,\in\Gamma}%
             {\Gamma\vdash x:T} 
\medskip\\
\inferrule[(Abs)]%
          {\Gamma, x:A \vdash t:B}%
          {\Gamma \vdash \Lam{\Var{x}}{t} \,:\, A\rightarrow B}
\qquad
\inferrule[(App)]%
          {\Gamma \vdash f : A\rightarrow B \\
           \Gamma \vdash s : A}%
          {\Gamma\vdash \App{f}{s} : B}
\end{array}
\]

\caption{Lambda calcul simplement typé}
\label{fig:typage-simple}
\end{figure} 


Les règles de typage sont définies en
Figure~\ref{fig:typage-simple}. La règle (\textsc{Var}) spécifie le typage
des variables. Cette expression se lit en partant du numérateur pour
déduire le dénumérateur : supposons que la variable \Var{x} de type
\Var{T} soit présente dans le contexte, alors on conclut que le type
de la variable \Var{x} est \Var{T}.  La règle (\textsc{Abs}) spécifie
le typage des lambda abstractions. L'abstraction construit un type de
la forme \(A \Rightarrow B\) : il faut donc que la variable associée
au lambda terme soit de type \(A\) et le résultat de type \(B\).  La
règle (\textsc{App}) spécifie le typage de l'application.  Dans la
Section~\ref{reduction:call_by_name}, nous avions vu que seul les
redex étaient réductible. Dans un language de programmation appliquer
un terme n'étant pas une fonction n'a pas de sens. C'est pour cette
raison qu'il nous faut vérifier que le membre gauche de notre application
est bien est bien une abstraction de type $A\rightarrow B$.
De plus on vérifie que le membre droit est bien du type $A$ afin de
vérifier si celui ci est applicable à notre fonction.


\begin{example}
  \label{probleme:type_simple}
  Voici donc quelques exemples de dérivations de type.  Ces
  dérivations se lisent du bas vers le haut.
  
  %% \todo{avec cfrac}
  %% \begin{align*}
  %%   \cfrac{
  %%     \cfrac{
  %%       \cfrac{
  %%         \cfrac{x:Int\rightarrow Bool \in \Gamma}{\Gamma,x:Int\rightarrow Bool,y:Int\vdash x:Int\rightarrow Bool}\:\:\:\:%level3gaucheApp
  %%         \cfrac{y:Int\in \Gamma}{\Gamma,x:Int\rightarrow Bool,y:Int\vdash y:Int}%level3droitApp
  %%       }{\Gamma,x:Int\rightarrow Bool,y:Int\vdash \App{x}{y} : bool}%level2
  %%     }{\Gamma,x:Int\rightarrow Bool\vdash \Lam{y}{\App{x}{y}}:Int \rightarrow Bool}%level1
  %%   }{\Gamma\vdash \Lam{x}{\Lam{y}{\App{x}{y}}}:(\intg\rightarrow \bool) \rightarrow \intg \rightarrow \bool} %level0
  %% \end{align*}

  \[
  \begin{array}{c}    
\inferrule[]%
          {\inferrule[]%
            {\inferrule[]              
              {\inferrule[]{x:\intg\rightarrow \bool \in \Gamma}{\Gamma,x:\intg\rightarrow \bool,y:\intg\vdash x:\intg\rightarrow \bool} %level3gaucheApp
               \inferrule[]{y:\intg\in \Gamma}{\Gamma,x:\intg\rightarrow \bool,y:\intg\vdash y:\intg} %level3droitApp
              }
              {\Gamma,x:\intg\rightarrow \bool,y:\intg\vdash \App{x}{y} : \bool}%level2
            }            
            {\Gamma,x:\intg\rightarrow \bool\vdash \Lam{y}{\App{x}{y}}:\intg \rightarrow \bool}%level1
            }
             {\Gamma\vdash \Lam{x}{\Lam{y}{\App{x}{y}}}:(\intg\rightarrow \bool) \rightarrow \intg \rightarrow \bool}%level0 
\end{array}
\]


  Ce terme est donc correctement typé.

  Voici un second exemple de typage
  \[
  \begin{array}{c}
    \inferrule[]
              {\inferrule[]{}{\Gamma\vdash (\Lam{x}{x}):A\rightarrow \bool }%level1gauche
               \:\:\:\inferrule[]{}{\Gamma\vdash true:A}%level1droit 
              }
              {\Gamma\vdash \App{(\Lam{x}{x})}{\true}:\bool}%level0
              
  \end{array}  
  \]  

\end{example}

Comme nous avons pu le constater dans le dernier exemple, il nous
manque des informations sur le type de $f$. Avec la specification ce n'est pas génant
car celle ci est manipulée par des êtres humains qui peuvent chercher cette information
sans savoir précisément où elle se trouve.
Pour un algorithme c'est déja beaucoup plus compliqué de trouver le type
de la fonction, celui ci ne peut chercher que dans le contexte pour
trouver de l'information.
En effet lorsque l'on vérifie une application il faut vérifier que le
membre de gauche est de type $A \rightarrow B$ alors que l'on ne
connait que \emph{B}. Nous allons donc introduire une nouvelle
représentation de nos termes afin de résoudre ce problème.

\subsubsection{Syntaxe bi-directionnel}

Les applications dont le membre de gauche est une abstractions posent
problème, comme vu dans l'Exemple~\ref{probleme:type_simple}.  Nous
allons donc partitionner les \(\lambda\)-termes en deux catégories :
d'une part, les termes dont on peut automatiquement synthétiser le
type (et que l'on peut donc placer à gauche d'une application) et ceux
pour lesquels il faudra fournir une annotation de type.


Nous nomerons les termes pouvant se trouver à gauche d'une application
les termes \emph{synthétisables} et les autres termes
\emph{vérifiables}.  Le problème étant le manque d'information quant
au type des termes inférables nous allons étendre le langage des
termes avec une \emph{annotation} permettant de spécifier cette
information.

\newcommand{\Inv}[1]{\ensuremath{\mathit{inv}(#1)}}
\newcommand{\Ann}[2]{\ensuremath{(#1\: :\: #2)}}

Voici donc notre représentation des termes:
 
\begin{bnf}
  ex &::= &&\mbox{(termes synthétisables)} \\
  &|& \App{ex}{in} & \mbox{(Application)} \\
  &|& \Var{x} & \mbox{(variable)} \\
  &|& \Ann{in}{T} & \mbox{(Annotation)} \\
  in &::= &&\mbox{(termes vérifiables} \\
  &|& \Lam{x}{in} & \mbox{(Abstraction)} \\
  &|& \Inv{ex} & \mbox{(Inversion)}
\end{bnf}

Les deux nouveaux termes sont donc l'inversion \Inv{-} qui permet d'inclure les 
\emph{termes synhtétisables} dans le monde des \emph{termes inférables}, l'annotation 
effectue la meme opération en fournissant l'information de typage manquante.

\newcommand{\verif}{vérification de type}
\newcommand{\synth}{synthèse de type}
\newcommand{\verifterme}{termes vérifiables}
\newcommand{\synthterme}{termes synthétisables}


\paragraph{Implémentation :}


Commençons par implémenter nos termes bidirectionnels dans notre programme:
\codefrom{typed}{lambda}{inTm}
\codefrom{typed}{lambda}{exTm}

Le type \lstinline!name! permet ci dessous nous permettra de mettre des entiers à la place 
d'une chaîne de caractère, nous en reparlerons dans l'implémentation de l'évaluation.
\codefrom{typed}{lambda}{name}


\subsubsection{Système de type bi-directionnel}

À partir de cette nouvelle présentation de la syntaxe, on adapte
aisément les règles de typage
(Figure~\ref{fig:typage-simple-bi-direct}), qui sont désormais
entièrement dirigées par la syntaxe et donc purement algorithmique.


\begin{figure}
\label{regles typage bidirectionnel}

\[\begin{array}{c}
\boxed{\Gamma\vdash T \ni t}
\bigskip\\
\inferrule[(Abs)]
          {T = A \rightarrow B \: \Gamma, x:A \vdash B \ni t}
          {\Gamma \vdash T \ni \Lam{x}{t}}
\medskip\\
\inferrule[(Inv)]
          {\Gamma \vdash t \in T' \:\: T=T'}
          {\Gamma\vdash T \ni inv(t)}
\bigskip\\
\boxed{\Gamma\vdash t \in T}
\bigskip\\
\inferrule[(Var)]
          {x:T \in \Gamma}
          {\Gamma \vdash x \in T }
\medskip\\
\inferrule[(App)]
          {\Gamma \vdash f \in A\rightarrow B \quad \Gamma\vdash A \ni s}
          {\Gamma\vdash \App{f}{s}\in B}
\medskip\\
\inferrule[(Ann)]
          {\Gamma\vdash T \ni t}
          {\Gamma\vdash \Ann{t}{T} \in T}
\end{array}\]


\caption{Lambda calcul  bidirectionnel simplement typé}
\label{fig:typage-simple-bi-direct} 
\end{figure}   


Les règles de la forme \(\Gamma\vdash T \ni t\) sont des règles de
vérification, celles de la forme \(\Gamma\vdash t \in T\) des règles
de synthèse.  Lors de la vérification, on connait le type $T$ et
l'on souhaite déterminer si le terme $t$ est bien de ce
type. Lors de la synthèse, on est en mesure, à partir d'un terme
$t$ quelconque, de déterminer son type sans ambiguïté.  On vérifie
aisément que ce système de type bi-directionnel est équivalent à celui
présenté en Figure~\ref{fig:typage-simple}.

\begin{example}
  Voici maintenant la même dérivation mais avec notre système de type bi-directionnel:
  problème précédement.
  \todo{roman: faire l'exemple de fred avec le new système}
  On constate maintenant qu'il ne manque plus d'informations, il sera donc beaucoup plus simple
  de faire un algorithme implémentant notre système bi-directionnel.
\end{example}

\paragraph{Implémentation :}

\todo{Dans cette section, importer le code du type-checker ``rapide'', ie. sans traitement des erreurs.}

\begin{itemize}
  
\item[$\bullet$] \boxed{\boxed{\Gamma\vdash T \ni t}}\\
  
  Nous disposons d'une fonction de vérification \lstinline!check!
  permettant d'éffectuer la vérification de type du terme \fun{inT}.
  où \fun{contexte} nous permet de stocker
  des paires associants une variable à son type. Il nous faut aussi
  donner le type d'entrée \fun{ty}.
    
  %
  \todo{Permuter \lstinline!inT! et \lstinline!ty! dans la définition de
    \lstinline!check! de telle sorte que cela corresponde à l'ordre du
    jugement de typage.}
  %
  \codefrom{typed}{lambda}{check_def} 
  
\item[$\bullet$] \boxed{\cfrac{T = A \rightarrow B \: \Gamma, x:A \vdash B \ni t}
  {\Gamma \vdash T \ni \lambda x. t}\mbox{(Abs)}} \\
  
  Une fois que l'on veut vérifier le terme cotnenus dans une abstraction il nous libérer l'ensemble des variables
  qui lui sont associées. Avec notre représentation ``locally nameless'' nous somme obliger d'effectuer une substitution
  contrairement à une représentation composé uniquement des indices de de Bruijn.
  
  C'est pour cette raison que l'on génère une nouvelle variable libre et que l'on substitue les variables liées 
  au $\lambda$ par celle ci. On insère donc dans le contexte l'association variable type.
  La fonction de synthèse \lstinline!synth! prend un contexte et un
  \emph{terme synthéthisable} et renvoie le type de celui-ci.
  La fonction gensym utilisée ici permet de crée un nom de variable frais, garantissant que celui n'a encore jamais
été utilisé. 
%
 \codefrom{typed}{lambda}{check_abs}

\item[$\bullet$] \boxed{\cfrac{\Gamma \vdash t \in T' \:\: T=T'}
                              {\Gamma\vdash T \ni inv(t)}\mbox{(Inv)}} \\


Afin de tester l'égalité de type, l'égalité structurelle de OCaml est
suffisante puisque les types sont purement statiques (contrairement
aux types dépendants qui, eux, calculent).
%
\codefrom{typed}{lambda}{check_inv}
  

\item[$\bullet$] \boxed{\boxed{\Gamma\vdash t \in T}}\\

La fonction de synthèse \lstinline!synth! prend un contexte, un
terme synthétisable et renvoie le type de celui-ci.

 \codefrom{typed}{lambda}{synth_def}

\item[$\bullet$] \boxed{\cfrac{\Gamma\vdash T \ni t}
                              {\Gamma\vdash (t:T) \in T}\mbox{(Ann)}} \\

  Nous somme ici en synthèse c'est à dire que nous devons retourner un type.
  Essayons de traduire la spécification de façon algorithmique. Si la vérification
  de $t$ de type $T$ est vraie alors il nous faut retourner $T$
  
\codefrom{typed}{lambda}{synth_ann}



\item[$\bullet$] \boxed{\cfrac{x:T \in \Gamma}
                               {\Gamma \vdash x \in T }\mbox{(Var)}}\\

Dans la spécification formelle on ne fait pas de distinction entre les variables libres et liées.
Comme nous l'avons vu dans la règle de typage de l'abstraction, l'ensemble des variables
liées à chaqu'un des lieurs sont libérées. La spécification parle donc bien des variables libres,
et il n'est pas donc possible synhtéthiser le type d'une variable liée. Si l'on rencontre une variable
le terme n'est pas bien formé, il faut donc le rejeter.

\codefrom{typed}{lambda}{synth_var}

\item[$\bullet$] \boxed{\cfrac{\Gamma \vdash f \in A\rightarrow B \quad \Gamma\vdash A \ni s }
         {\Gamma\vdash f\:s\in B}\mbox{(App)}}\\

  
  Comme la spécification nous l'indique il est d'abord nécéssaire de synthétiser le type de $f$.
  Il faut ensuite s'assurer que le type retourné par la synthèse est bien de la forme $A\rightarrow B$
  puis en extraire le type $A$ pour pouvoir cette fois ci vérifier $s$. Si cette vérification réussi
  on retourne le type $B$.
 
\codefrom{typed}{lambda}{synth_appl}

\end{itemize}

Pour cette implémentation nous avons choisi de générer des exceptions lorsque le terme
n'était pas correctement typé. Cela permet de terminer le programme directement car de toute
façon le terme serait refusé. Nous reviendrons cependant sur certains points négatifs de cette
méthode dans l'implémentation des types dépendants.



\subsection{Normalisation} %en gros calculer dans le lambda calcul non typé

Dans cette section nous verrons certaines propriétés offertent par les systèmes de type, et nous parlerons 
de l'évaluation. Nous ne reviendrons pas sur la substitution ni la $\beta$-réduction car cela reste identique par 
rapport à la Section~\ref{calculer_dans_le_lambda_calcul}.

\subsubsection{Méta-théorie}

Le typage permet d'obtenir, à la compilation, des garanties quant à la
bonne exécution des programmes.  Formellement, ces garanties se traduisent en deux propriétés complementaires d'un système de type :
\begin{description}
\item[Progrès :] si un terme \(t\) est correctement typé alors soit \(t\) est une valeur, soit il
 existe une réduction telle que \(t \leadsto t'\)
\item[Préservation :] si un terme \emph{t} a le type \emph{T}
et que \emph{t} $\leadsto$ \emph{t'} alors \emph{t'} est de type \emph{T}
\end{description}

La conjonction de ces deux propriétés donne le slogan ``un programme
bien typé ne plante jamais'' \todo{(citation Milner)} tout programme
bien typé réduit vers une valeur de ce type.

\begin{example}
  Un programme de type \bool{} réduit vers une valeur de type \bool{}
  et donc ce programme réduit \emph{nécessairement} vers le
  constructeur \true{} ou le constructeur \false{}.
\end{example}

Nous avons désormais des garanties quant à la terminaison de nos programme.
Cela se traduit par le fait que l'on pourra systématiquement obtenir une 
forme normale forte pour nos termes contrairement au \(\lambda\)-calcul non typé.


\subsubsection{Reduction forte}

\label{reduction_forte}
Dans le \(\lambda\)-calcul non typé nous avions utilisé une stratégie d'évaluation en appel par nom
car nous n'avions pas la garantie qu'une forme normale forte existait.
D'après les propriétés de la section précédente nous disposons de la certitude que les termes acceptés  par le type-checker sont fortement normalisants. De plus, les types ne sont plus utiles lors de l'évaluation. 
Nous allons donc implémenter une stratégie de réduction forte sur les \(\lambda\)-termes non typés de la Section~\ref{sec:untyped}.

\begin{align*}
  &\cfrac{}
  {x \Downarrow x}&\mbox{Var} \\
  &\cfrac{t \Downarrow \: \lambda x.v \:\: \subst{v}{x}{t'}\Downarrow v'}
  {t\:t'\Downarrow \: v'}&\mbox{Appl redex} \\
  &\cfrac{t \Downarrow \: n \:\: v \Downarrow v'}
  {t\:t'\Downarrow \: n \: v'}&\mbox{Appl} \\
  &\cfrac{e \Downarrow \: v}
  {\lambda x.t \Downarrow \: \lambda x.v}&\mbox{Abs}
\end{align*}

La traduction de nos termes bidirectionnels vers les termes non typés
est transparente : il suffit d'effacer les annotations de type.

\begin{example}
  \todo{Roman: j'ai l'exemple sur papier faut juste que le mette dans le rapport}
\end{example}

\paragraph{Implémentation:}
\label{reduction_petits_pas}

\codefrom{untyped}{lambda}{reduction_forte}

La fonction de réduction forte est très similaire à la fonction d'évaluation précédente.
Avec les garanties offertes par notre système de type nous pouvons à présent évaluer l'ensemble du
terme. 



\subsection{Extensions} 

Dans notre précédent language nous avions introduit les booléens ainsi que les entiers,
nous verrons ici la façon de les représenter ainsi que leurs règles de typage.
Nous introduirons aussi un nouveau type, le produit cartésien.

\subsubsection{Les entiers}
\label{entier_type}

Commençons cette fois-ci par les entiers étant donné que le type \emph{int}
est déja présent dans notre language.
Les constructeurs sont les memes que dans le \(\lambda\)-calcul non typé 
cependant, maintenant que nous disposons de termes bi-directionnels, il est important
de préciser leur phase.

%alors la il me faut une justification peut etre plus précise car j'en vois une pour les types dépendants mais pas pour ici
%Pour les types dépendants je dirais que ceux dans les exTm c'est parceque on veut pouvoir avoir de la dépendance
%sur eux mais je sais pas si ici je peux en parler
\emph{Succ} et \emph{Zero} sont des termes inférables étant donné que
leur type sera toujours \emph{Nat} contrairement à \emph{iter}.
Celui ci est un terme synthétisable étant donné que son type diffère en fonction de ses arguments.
Les règles de typage bidirectionnelles sont donc:
\begin{align*}
  &\cfrac{\:}
  {\Gamma\vdash Nat \ni \mathrm{Zero}}&\mbox{(Zero)} \\
  &\cfrac{\Gamma\vdash Nat \ni t}
  {\Gamma\vdash Nat \ni \mathrm{Succ(t)}}&\mbox{(Succ)} \\
  &\cfrac{\Gamma\vdash Nat \ni n \:\: \Gamma\vdash A \ni a \:\: \Gamma\vdash A\rightarrow A \ni f}
  {\Gamma\vdash \mathrm{iter}\: A\: n\: f\: a \in A}&\mbox{(Iter)} \\
\end{align*}
Les arguments de \emph{Iter} sont composés d'un type $A$ qui correspond au type de retour et de termes vérifiables.
Les règles d'évaluations restent inchangés. 

\subsubsection{Les booléens}


Afin de pouvoir typer nos termes, il nous faut introduire le type \bool{}.
En suivant la meme demarche que  pour les entiers les 
constructeurs \emph{True} et \emph{False} sont désormais des \emph{termes inférables}
et le constructeur \emph{Ifte} un \emph{terme synthétisable}

Nous pouvons désormais typer nos booléens de la manière suivante: 
\[
\begin{array}{c}
\inferrule[(true)]
          {{}}
          {\Gamma\vdash \true{} : \bool{}}
\qquad
\inferrule[(false)]
          {{}}
          {\Gamma\vdash \false{} : \bool{}}
\medskip\\
\inferrule[(If-else)]
          {\Gamma\vdash \bool\ni t1{} \\
           \Gamma\vdash t2\in T \\
           \Gamma\vdash t3\in T}
         {\Gamma\vdash \ifte{t1}{t2}{t3} : T}
\end{array}
\]

\subsubsection{Le produit cartésien}
\label{produit_cartesien}

\todo{Roman :changer ces commandes elles sont nuls mais ça bugue}
\newcommand{\pair}[2]{\ensuremath{#1,#2}}
\newcommand{\produit}[2]{\ensuremath{#1\times#2}}
\newcommand{\projun}[1]{\ensuremath{\pi0.#1}}
\newcommand{\projdeux}[1]{\ensuremath{\pi1.#1}}


Nous ne disposons actuellement pas d'un type permettant de caractériser nos \emph{paires},
introduisons donc un type \emph{produit cartésien} \produit{A}{B}.
\begin{bnf}
  T &::= &....... &\mbox{(Types)} \\
  &|& T\times T & \mbox{(Produit cartésien)} \\
\end{bnf}

Pour l'évaluation les règles sont les mêmes que en section~\ref{paires}.

Règle de typages des paires: 
\begin{align*}
  &\cfrac{\Gamma\vdash A\ni a \:\: \Gamma\vdash B\ni b}
  {\Gamma\vdash A\times B \ni a,b}&\mbox{(Paire)} \\
  &\cfrac{\Gamma\vdash p \in A\times B} 
  {\Gamma\vdash p.\pi 0 \in A}&\mbox{($\pi 0$)} \\
  &\cfrac{\Gamma\vdash p \in A\times B} 
  {\Gamma\vdash p.\pi 1 \in B}&\mbox{($\pi 1$)} \\
\end{align*}
Pour les \emph{projections} il nous faut vérifier le fait que l'argument est bien de type \emph{produit} afin de
retourner le type du membre de gauche ou droit.

\paragraph{Implémentation :}
Nous allons maintenant implémenté le produit cartésien afin d'enrichir
notre language. Il nous faut rajouter le type \emph{produit} ainsi que la \emph{paire}
et les \emph{projection}.
Les projections sont des \emph{termes synthétisables} étant donné que leur type dépend de la paire
sur laquelle ils sont appliqués. La paire un \emph{terme vérifiable} car chaque paire à un type statique.

\emph{Type}
\codefrom{typed}{lambda}{type_pair}
\emph{inTermes}
\codefrom{typed}{lambda}{inTm_pair}
\emph{exTermes}
\codefrom{typed}{lambda}{exTm_pair}
\emph{value}
\codefrom{typed}{lambda}{value_pair}

Il nous faut maintenant implémenter les règles de typage au sein de notre algotithme:

\emph{check}
\codefrom{typed}{lambda}{check_pair}
\emph{synth}
\codefrom{typed}{lambda}{synth_pair}



\subsection{Réduction forte à grands pas}


Dans cette section, nous décrivons une implémentation alternative de
la réduction forte qui permet d'exploiter certaines fonctionnalités des languages de programmation fonctionnelle.
Etant donné que nous utilisons un language de programmation utilisant déja
des mechanismes de définition de fonction ou d'application .Il est
intéressant de les exploiter afin de crée un interpréteur pour nos termes
en utilisant les termes Ocaml ce qui nous permettra de ne pas à
gérer certains méchanismes.

Nous allons donc devoir définir de nouveaux termes et un moyen de
faire une bijection entre notre ancien ensemble de terme et le nouveau.

Comme nous l'avons vu dans la Section~\ref{reduction_forte} \if 0 peut
etre dans la partie safety je ne me souviens plus a voir \fi la
réduction forte aboutie forcément à une forme normale, les termes que
nous obtenons par la réduction à grand pas seront donc les memes que
ceux obtenus avec la réduction à petits pas
(Section~\ref{reduction_petits_pas}).

\todo{Traditionnellement, la fonction que tu appelles
  \lstinline!big_step_eval_*! est appelée \lstinline!eval_*! :
  utiliser cette terminologie (et changer le texte si besoin). On
  parle de la ``fonction d'évaluation'' pour aller des termes aux
  valeurs, puis de la ``fonction de réification'' pour aller des
  valeurs aux formes normales.}

\newcommand{\VLam}{\lstinline!VLam!}
Voici donc le code correspondant en Ocaml:

\codefrom{typed}{lambda}{value}
\codefrom{typed}{lambda}{neutral}

Le terme \fun{VLam} correspond à l'abstraction.
Cette représentation nous permet de reconsidérer la façon de voir la 
réduction d'une abstraction. En effet lorsque l'on applique une abstraction
à un terme, nous avions introduit la substitution, qui consiste à remplacer les occurences 
des variables liée à ce terme. La transformation d'une abstraction consiste donc à 
créer une fonction anonyme puis à évaluer le terme contenu dans celle-ci en ajoutant dans le 
contexte la variable liée à cette fonction. Lors de l'évaluation d'une variable liée, on va
retrouver dans le contexte l'argument correspondant. On aura donc bien le comportement attendu
lors de l'application de cette fonction anonyme car cela va remplacer les occurences de la 
variable.

\begin{example}
  Soit le terme \(\App{\Lam{x}{\Var{x}}}{u}\), avec la méthode
  d'évaluation à petit pas, on évalue en effectuant $\subst{x}{x}{u}$
  ce qui nous donne comme résultat \emph{u}.  Avec l'évaluation à
  grands pas on évalue le terme $\Lam{x}{x}$ en la fonction OCaml
  \lstinline!fun arg -> arg! ce qui appliqué à la traduction $v_u$ de
  $u$, retournant ainsi $v_u$ comme souhaité.
\end{example}


\codefrom{typed}{lambda}{big_step_eval_exTm_ann}
Comme nous l'avons vu précédement le type contenue dans une \emph{annotation} n'est pas utile lors de l'évaluation.
Il nous faut simplement évalué le terme \fun{x} contenue dans celle ci.

\codefrom{typed}{lambda}{big_step_eval_exTm_var}

La fonction \emph{VFree} permet simplement à partir d'un nom de créer
une \emph{NFree} à l'intérieure d'un \emph{VNeutral}. Nous avons besoins
de crée des \fun{neutral} pour tous les termes dont l'évaluation est terminé.
Cette opération pouvant être utile assez régulièrement on décide d'implémenter
une fonction à part entière dont voici le code:
\codefrom{typed}{lambda}{vfree}

Pour les variables liées il faut retrouvé dans le contexte la variable à laquel elle est associé.
Cela nous permettra de définire cette variable comme un argument de la fonction anonyme que nous avons
crée avec l'évaluation de l'abstraction.

\codefrom{typed}{lambda}{big_step_eval_exTm_app}

Pour évaluer l'application d'un coup, il est nécessaire de créer une fonction externe \emph{vapp}.
Nous appelons donc cette fonction avec le couple formé de l'évaluation des deux membres de l'application.
Si le membre de gauche est une \emph{VLam}, il nous suffit d'appliquer celle-ci \emph{dans Ocaml},
étant donné qu'elle est encodée par une fonction anonyme OCaml. Sinon l'évaluation ne peut pas continuer
il faut donc crée un terme neutre \fun{NApp} contenant nos deux arguments. Voici donc le code de
la fonction \fun{vapp}:

\codefrom{typed}{lambda}{vapp}

\codefrom{typed}{lambda}{big_step_eval_inTm_inv}
Pour \emph{l'inversion} il nous faut évaluer le \emph{terme synthétisable} que ce constructeur contient.

\codefrom{typed}{lambda}{big_step_eval_inTm_abs}
Comme nous l'avons vu précédement, nous avons crée une \fun{value} correspondant
à l'abstraction, \fun{VLam}. Nous avons déja vu son rôle, ici il sera simplement question
de crée une fonction anonyme Ocaml dont le corp correpond à l'évaluation du terme
contenu dans l'abstraction.

Une fois nos termes évaluées dans OCaml, il nous faut maintenant les
\emph{réifier} sous forme de termes de notre
$\lambda$-calcul. Cette fonction doit nécéssairement prendre un argument de
type{value} afin de nous retourner un \emph{terme synthétisable}.

\codefrom{typed}{lambda}{value_to_inTm}
\codefrom{typed}{lambda}{neutral_to_exTm}



Le type \fun{name} nous permet de faire la distinction entre les
variables réellement libre et celles que nous souhaitons liée.
Afin de transformer une value \emph{VLam} en
\emph{Abs} il nous faut appliquer la fonction \emph{f} à une variable
libre, et celle ci se distinguera des autres variables libres car elle
possède un indice grace au type \fun{name}.
Nous avons un problème quand au nom de la variable de l'abstraction, lorsque nous
avons transformé celle ci en fonction anonyme nous avons perdu cette information.
Nous somme donc forcé d'introduire des variables artificielles grâce \fun{gensym}.
Nous allons pouvoir exploiter ceci avec l'aide de
la fonction \fun{boundfree} dont voici le code:
\codefrom{typed}{lambda}{boundfree}



\section{Les types dépendants}

Maintenant que les bases du $\lambda$-calcul ainsi que du typage à été présenté 
nous allons découvrir les types dépendants. 
 
\subsection{Automatisation de démonstration de preuve}
Durant les deux premières parties du rapport nous avons présenté le $\lambda$-calcul
qui nous à permis d'introduire un système de type. Cependant nous avions une vision 
informatique des type. En effet notre seul but était de vérifier que nos $\lambda$-termes
pouvaient se réduire. 
Un des aspects primordiale des système de type est la correspondance de Curry-Howard.
Celle ci permet de d'établire des relations entre la logique propositionnelle et les systèmes 
de type. Nous verrons que ``t est une preuve de P'' est équivalent à \emph{t:P} c'est à dire
t est de type P.
Tout d'abord intéressons nous aux bases de la logique propositionnelle.
\subsubsection{La logique propositionnelle}

Les règles de la logique propositionnelle associes à chaque constructeur 
une règle d'introduction qui permet de CREUSER, une élimination qui permet d'utiliser 
les hypothèse contenants ce constructeurs ainsi qu'une règle de calcul.

Tout comme les règles de typage on lire les règles suivantes de cette façon:''Si l'on suppose le numérateur
alors le dénominateur est vrai'' ou encore ``Pour prouver le dénominateur il nous faut prouver le numérateur''

Commençons par le connecteur $\Rightarrow$, représentant l'implication, sa règle d'introduction est la suivante:

La règle d'introduction:
\begin{align*}
  \cfrac{[x:A] \: t:B}
        {\lambda x:A.t\: :\: A\Rightarrow B}
\end{align*}
Ici la notation [x:A] signifie ``Supposons x:A montrons t:B''.
Voici maintenant la règle d'élimination:
\begin{align*}
  \cfrac{q\: :A\Rightarrow B\:\: a:A}
        {q\:a\: : B}
\end{align*}

On constate que la règle d'introduction de l'implication est presque identique à celle 
du typage de l'abstraction. De meme pour l'élination vis à vis de la règle de l'application.
La règle de calcul va nous permettre de confirmer notre intuition:
\begin{align*}
  \App{(\Lam{x:A}{t})}{a}\rightarrow \subst{t}{x}{a}
\end{align*}
On reconnait clairement l'évaluation d'une application. C'est cette intuition 
qu'on eu Haskell Curry et Alvin Howard ce qui à permis de prouver la correspondance
entre les systèmes de type et la logique propositionnelle.

Regardons maintenant un second exemple, le constructeur $\land$ signifiant le \emph{et} logique, dont voici la règle de 
formation:
\begin{align*}
\cfrac{A \:est\: un\: terme \:\: B\:est\:un\:terme}
{A\land B} 
\end{align*}
La règle d'introduction:
\begin{align*}
\cfrac{p:A\:\:q:B}
{p,q\: : A\land B}
\end{align*}
Si l'on veut prouver $A\land B$ il nous faut prouver d'une part A et d'autre part B
La règle d'élimination 
\begin{align*}
\cfrac{r\: : A\land B}
      {fst\:r:\:A} \:\:
      \cfrac{r\: : A\land B}
            {snd\:r:\:B}
\end{align*}

On reconnait ici le produit cartésien que l'on avait introduit dans notre $\lambda$-calcul simplement typé avec \emph{fst}
et \emph{snd} les projections.


Pour l'instant nous n'avons pas établie de lien réel entre ces connecteurs et nos termes, c'est l'enjeu de la
section suivante.

\subsubsection{correspondance de Curry Howard bis}

Dans la section précédente nous avons regarder quelques intuitions permettant de voir le lien entre la logique
et l'informatique au travers des systèmes de type.
Nous avons étudié le $\lambda$-calcul qui permet de faire le lien avec la déduction naturelle. Il existe d'autre
modèles de calculs permettants de faire des liens similaires comme par exemple les Système à la Hilbert et 
les systèmes de type de la logique combinatoire.

Voici un tableau montrant les différents liens entre la logique et le $\lambda$-calcul.

\todo{roman: mettre un tableau de correspondance (que j'ai en photo) mais je ne sais pas quelle est la meilleure présentation}


Le fait d'avoir séparé nos termes permets de rendre ces correspondances plus aisées. En effet les constructeur
correspondent aux \emph{termes inférables} tandis que les \emph{termes synthétisables} sont les destructeurs.

\todo{j'aurais des questions à posé jeudi pour finir cette partie}









\subsection{Système de type dépendant}

Comme nous allons le voir dans cette section les types dépendants vont nous permettre d'exprimer 
des termes inexistants, dans notre système précédent. Pour faire echo avec la section précédente,
nous allons introduire un nouveau lien entre la logique et notre système de type: le quantificateur $\forall$.

\subsubsection{Equivalence entre les types et les termes}
\label{presentation_type_dependants}

Jusqu'a présent nous avions d'une part l'ensemble des types et l'ensemble des termes. Cette séparation 
avait un sens car les termes et les types ne se comportaient pas de la meme façon. La plus grande différence 
était au niveau de l'évaluation, en effet nos types étant statiques il n'était pas nécéssaire de les réduires
ou d'effectuer des calculs sur eux %nul.
Cependant certains termes ne peuvent pas s'exprimer dans un système de type statique, prenons par exemple
la fonction identité. 
\begin{example}
  Dans notre système précédent il existait une fonction identité pour chaque type. 
  \begin{align*}
    &\Lam{x}{x}\: :Bool\rightarrow Bool \\
    &\Lam{x}{x}\: :Int\rightarrow Int \\
    & ... \\
  \end{align*}
On souhaiterais écrire une fonction polymorphe dont le type de retour est influencé par le type de retour.
\end{example}

Il existe différentes façon de permettre l'écriture de fonctions comme celles ci. Inspirons nous de la
logique, le quatifieur $\forall$ pourrait nous permettre d'écrire ce type de termes.
\begin{example}
  On souhaiterais pouvoir écrire une fonction identité de la manière suivante:
  \begin{align*}
    \Lam{x}{x}\::(\forall x:A \rightarrow A)
  \end{align*}
\end{example}

Avec des variables au sein de nos types nous pouvons désormais introduire un ensemble de termes, 
comme par exemple les vecteurs de taille \emph{n}.
\begin{example}  
  \label{example vecteur}
  Voici des vecteurs d'éléments de type $\alpha$ et de taille \emph{n}:
  \begin{align*}
    &[e] &: Vec\: 1\: \alpha \\
    &[(e:\alpha),(e:\alpha)] &: Vec\: 1\: \alpha \\
    &... \\
    &[.....] &: \forall n:Int\: \forall \alpha : A . Vec\: \alpha \: n \\
  \end{align*}
\end{example}
On ressent de plus en plus l'intuition que en introduisant une dépendance dans nos types, ceux ci se comportent de la meme façon que 
les termes.
Il serait intérressant de considérés à la fois les termes et les types comme un unique ensemble régit par les meme propriétés.
C'est ce que certains systèmes comme \emph{Système F} et les types dépendants on formalisé. 
Meme si les termes sont maintenant des types et inversement il nous faut quand meme introduire un type pour les types.
\begin{example}
  Reprenons notre fonction identité, dire que:
  \begin{align*}
    \Lam{x}{x} : \forall x:A \rightarrow A
  \end{align*}
  Si l'on considère que A est le terme $\Lam{x}{x}$ cela n'a pas de sens.
\end{example}
Nous allons donc dorénavant noté \emph{*} le type des types.

\subsubsection{Formalisation}

Maintenant que nous avons l'intuition des nouveaux constructeurs nous pouvons maintenant enrichire notre language,
voici les nouvelles règles de typage en Figure~\ref{fig:typage dependant}.

\begin{figure}
  \center\boxed{\Gamma\vdash T \ni t}
  
  \begin{align*}
    &\cfrac{\Gamma,x:S\vdash T \ni t}
    {\Gamma \vdash \forall x:S.T \ni \lambda x. t}\mbox{(Abs)} \\
    &\cfrac{\Gamma \vdash t \in T' \:\: T=T'}
    {\Gamma\vdash T \ni inv(t)}\mbox{(Inv)} \\
    &\cfrac{}
    {\Gamma \vdash * \ni *}\mbox{(Star)} \\
    &\cfrac{\Gamma \vdash * \ni S\:\:\Gamma,x:S \vdash *\ni T}
    {\Gamma\vdash * \ni \forall x:S.T}\mbox{(Pi)}
  \end{align*}
  
  \center\boxed{\Gamma\vdash t \in T}
  
  \begin{align*}
    &\cfrac{x:T \in \Gamma}
    {\Gamma \vdash x \in T }\mbox{(Var)} \\
    &\cfrac{\Gamma \vdash f \in \forall x:S.T \quad \Gamma\vdash S \ni s }
    {\Gamma\vdash f\:s\in \subst{T}{s}{x}}\mbox{(App)} \\
    &\cfrac{\Gamma\vdash * \ni T \:\:\Gamma\vdash T \ni t}
    {\Gamma\vdash (t:T) \in T}\mbox{(Ann)} \\
  \end{align*}
  \caption{Typage Dépendant}
  \label{fig:typage dependant} 
\end{figure}

Les deux nouvelles constructions \emph{Pi} et \emph{Star} sont des \emph{termes inférables} étant donné
que l'on possède toute l'information nécéssaire pour les vérifier. De manière générale les types seront 
des \emph{termes inférables}.

Si l'introduction d'un système bi-directionnel dans le $\lambda$-calcul pouvait ne pas etre indispensable, elle prend tout son 
sens avec les types dépendants.
Cependant nous ne pouvons pas parler de types dépendants sans un système bi-directionnel, ce sont dans les 
\emph{termes inférables} que nous allons définir la dépendances que nous allons utilisé dans les 
\emph{termes synthétisables}.
Mis à part la dépendance introduite dans l'abstraction notre language ne comporte pas de termes exploitant 
l'expressivité des types dépendants. Nous verrons au fur et à mesur des extensions toute leur richesse.

En général le connecteur $\forall$ est appelé \emph{Pi} nous garderons cette convention.
Les deux notations suivantes sont équivalentes: 
\begin{align*}  
  \forall x:S.T \Leftrightarrow Pi\: x\: S\: T
\end{align*}
Afin d'alléger la syntaxe si l'on veut crée un \emph{Pi} anonyme on peut utiliser la notation suivante:
\begin{align*}
  & \forall x:Nat.Nat \Leftrightarrow Pi\: x\: Nat\: Nat \Leftrightarrow (Nat \rightarrow Nat) \\
\end{align*}

Avant de poursuivre il est important de nous convaincre que l'ensemble des termes exprimables avec un système 
de typage simple est inclus dans l'ensemble des termes des types dépendants.
\begin{example}
  On peut toujours exprimé une fonction identité applicable uniquement aux entiers de la manière suivante:
  \begin{align*}
    &\Lam{x}{x}\:\forall x:Int\:Int \\
  \end{align*}
\end{example}

\paragraph{Implémentation :} 
La représentation de nos termes vérifiables et synthétisables dans le programme:
\codefrom{dependent}{lambda}{inTm}
\codefrom{dependent}{lambda}{exTm}

Nous n'avons rajouter que deux nouveaux termes dans le noyeau de notre language mais 
le fait de ne plus faire la distinction entre les termes et les types change beaucoup de
choses dans l'architecture du programme. 

Dans l'implémentation du \fun{type_checker} du $\lambda$-calcul simplement typé lorsqu'un terme n'était pas
correctement typé la fonction stopait l'execution du programme en levant une exeption.
Nos programmes devenant de plus en plus complexe il peut etre intérressant de renvoyer un rapport detaillé
de l'echec. Voici la structure que nous allons utilisé:

\codefrom{dependent}{lambda}{debug}

Nous aurons aussi besoin des fonctions suivantes: 
-\fun{res_debug}: qui retourne le booléens présent dans le rapport.    
-\fun{create_report}: qui crée un rapport en prenant un argument pour chaque champs du \fun{report}
L'équivalent de ces fonctions pour le type \emph{debug synth} sont suivis de \fun{_synth}.
Cette assistance est nécéssaire pour aider les programmeurs à connaitre la source de l'erreur,
tout comme le font les compilateurs modernes. Cela nous aide aussi pour tester la validité de celui 
ci car on peut maintenant tester si la vérification d'un terme est fausse.

Nous avons désormais une forme normale pour les types, il est donc intérressant de 
fournire cette forme normale directement au type-checker. La fonction \fun{check} prend donc maintenat
un contexte, un \emph{terme inférable} ainsi qu'une value.


\codefrom{dependent}{lambda}{check_abs}
$\cfrac{\Gamma,x:S\vdash T \ni t}
    {\Gamma \vdash \forall x:S.T \ni \lambda x. t}$



\codefrom{dependent}{lambda}{check_inv}
$\cfrac{\Gamma \vdash t \in T' \:\: T=T'}
    {\Gamma\vdash T \ni inv(t)}$

Le principal changement de cette implémentation est le changement d'égalité. 
En effet ici nos termes peuvent contenirs des fonctions anonymes dont on ne peut 
tester l'égalité avec la simple fonction d'ocaml. Il nous faut donc d'abord transformer 
nos \emph{value} en \emph{termes inférables}. Le second problème est que le nom associé 
aux différents binder tels que le $\lambda$ ou le $\forall$ n'auront pas nécéssairement le 
meme nom. Comme nous l'avons vu dans la Section~\ref{alpha_equiv}sur l'$\alpha$-équivalence 
deux termes sont égaux meme si le nom de leur variables est différents. 
La fonction \fun{equal_inTm} parcour simplement les deux termes passé en arguments sans tenir compte
du nom de variable associé au binder. Par contre les variables libres doivent nécéssairement etre les memes.

\codefrom{dependent}{lambda}{check_star}
$\cfrac{}
    {\Gamma \vdash * \ni *}$



\codefrom{dependent}{lambda}{check_pi}
$\cfrac{\Gamma \vdash * \ni S\:\:\Gamma,x:S \vdash *\ni T}
    {\Gamma\vdash * \ni \forall x:S.T}$





\codefrom{dependent}{lambda}{synth_var}
$\cfrac{x:T \in \Gamma}
    {\Gamma \vdash x \in T }$
Tout comme dans l'implémentation précédente il n'est pas possible de rencontrer de variable 
liée lors de la vérification de type.

\codefrom{dependent}{lambda}{synth_app}

$\cfrac{\Gamma \vdash f \in \forall x:S.T \quad \Gamma\vdash S \ni s }
    {\Gamma\vdash f\:s\in \subst{T}{s}{x}}$



\codefrom{dependent}{lambda}{synth_ann}

$\cfrac{\Gamma\vdash * \ni T \:\:\Gamma\vdash T \ni t}
    {\Gamma\vdash (t:T) \in T}$

Etant donné que nos termes et nos types sont équivalents il faut maintenant vérifier que 
$T$ est bien un type. Il faut aussi évaluer celui ci afin de le mettre en forme normale.

\subsubsection{Mise à jour de l'évaluation}

Nous savons maitenant comment vérifier les termes \emph{pi} et \emph{Star}, passons donc 
à leur évaluation:

\[\begin{array}{c}
  \inferrule{{}}
            {*\Downarrow *}
  \medskip\\
  \inferrule{{p\Downarrow t\:\:\:p'\Downarrow t'}}
            {\forall x:p.p'\Downarrow \forall x:t.t'}
\end{array}\]

Les deux \emph{value} nécéssaires à l'implémentation de cette évaluation sont:
\codefrom{dependent}{lambda}{value_pi_star}

En suivant le meme raisonnement que pour l'évaluation d'une abstraction avec la
fonction \fun{big_step_eval}, nous allons transformer le second membre de $\forall$
en fonction anonyme. 

\codefrom{dependent}{lambda}{big_step_new}
Le premier membre est évalué simplement tandisque le second est bien évalué en fonction anonyme,
car comme pour l'abstraction cela nous permet de pouvoir substituer dans notre type 
directement.

Pour terminer voici la fonction permettant de remettre nos \emph{values} dans le monde
des termes vérifiables:

\codefrom{dependent}{lambda}{value_to_inTm_new}



\subsection{Extensions}

Comme nous l'avons vu dans l'Exemple~\ref{example vecteur} nous pouvons typé de nouveaux termes inexistants au paravant.
Nous commencerons par mettre a niveau les encodages précédents. Nous présenterons ensuite les vecteurs ainsi que l'égalité.

\subsubsection{Les entiers}

Nous avons désormais besoin de modifier notre grammaire des entiers dans notre language:
\begin{bnf}
  t &::= &....... &\mbox{(termes vérifiables)} \\
  &|& \nat & \mbox{(nat)} \\
  &|& \zero & \mbox{(zero)} \\
  &|& \succs\:t & \mbox{(succ)} \\
  s &::= &....... &\mbox{(termes synthétisables)} \\
  &|& \iter\:t\:t\:t\:t & \mbox{(iter)}
\end{bnf}
Maintenant iter possède un argument de plus que précédement nous verrons sont role dans le typage des entiers.
\codefrom{dependent}{lambda}{terme_nat}
\codefrom{dependent}{lambda}{terme_iter}



Passons maintenant aux règles de typages:

\todo{roman:mieux présenter iter dans la spec} 
\begin{align*}
  &\cfrac{}
  {\Gamma\vdash * \ni Nat}&\mbox{(Nat)} \\
  &\cfrac{}
  {\Gamma\vdash Nat \ni Zero}&\mbox{(Zero)} \\
  &\cfrac{\Gamma\vdash Nat \ni n}
  {\Gamma\vdash Nat \ni Succ\:n}&\mbox{(Succ)} \\
  &\cfrac{\Gamma\vdash Nat\rightarrow *\ni P\: \Gamma\vdash Nat\ni n\: \Gamma\vdash \forall n:Nat.(P\:n\rightarrow P\:(succ\:n))\ni f\:
  \Gamma\vdash P\:Zero\ni a}
  {\Gamma\vdash iter \: P\: n\:f\:a\in P\:n}&\mbox{(Iter)}\\
\end{align*}
Comme nous l'énoncions précédement les types sont maintenant des termes, il nous faut donc ajouter une règle \emph{Nat}.

Dans le $\lambda$-calcul simplement typé \ref{entier_type} nous avions besoin que l'argument \emph{a} soit un \emph{terme synthétisable}
afin de déterminer le type de retour de cette construction.
Maintenant l'ensemble des arguments de iter sont des termes inférables car l'introduction d'un prédicat
\emph{P} nous permet de connaitre le type de retour de iter et donc de vérifier les autres termes. 
Ce prédicat nous permet d'une part de crée de la dépendance et d'autre part de rajouter de l'information.

Pour continuer l'analogie avec la logique propositionnelle, on constate que la règle de typage de iter correspond à un raisonnement par
\emph{induction}. En effet on vérifie d'abord que l'argument \emph{a} est bien du type du prédicat dans le cas de zero. 
Puis l'on vérifie que la fonction \emph{f} est définie pour tout \emph{n} vers \emph{n + 1}.

Nous allons maintenant définir un $\lambda$-terme permettant d'effectuer l'addition de deux nombres avec l'aide de notre syntaxe
lispienne présentée en Section~\ref{parsing}:
\begin{align*}
  plus\:=\: (lambda\:n\:(lambda\:a\:(iter\:(lambda\:x\:N)\:n\:(lambda\:ni\:(lambda\:x\:(succ\:x)))\:a)))
\end{align*}
Pour effectuer l'addition \emph{n\:+\:m} la stratégie consiste à iterer \emph{n} fois la fonction successeur sur \emph{m}.
Afin d'aléger la syntaxe nous utiliserons dorénavant ``(+ n m'' correspondant au terme \emph{plus} appliqué aux entiers \emph{n} et
\emph{m}.

Les règles de typages correspondantes dans notre algorithme:

\todo{mettre le code quand celui ci sera mis au propre car pas présentable pour le moment}


Pour l'évaluation nous n'avons pas besoin d'évaluer le prédicat, celle ci s'effectue de la meme façon que 
dans le $\lambda$-calcul simplement typé.


\subsubsection{Les vecteurs}

Les vecteurs sont un très bon exemple d'implémentation où l'on peut introduire de la dépendance. Nous avons vu une 
présentation assez informelle
des vecteurs afin de présenter les types dépendants, il sera donc question ici formaliser l'intuition de la
la Section~\ref{presentation_type_dependants}. 
Commençons par enrichire notre grammaire:

\newcommand{\vect}{\mathit{vec}} 
\newcommand{\dnil}{\mathit{dnil}}
\newcommand{\dcons}{\mathit{dcons}}
\newcommand{\dfold}{\mathit{dfold}}

\begin{bnf}
  t &::= &....... &\mbox{(termes vérifiables)} \\
  &|& \vect\:t\:t & \mbox{(vec)} \\
  &|& \dnil\:t & \mbox{(dnil)} \\
  &|& \dcons\:t\:t & \mbox{(dcons)} \\
  s &::= &....... &\mbox{(termes synthétisables)} \\
  &|& \dfold\:t\:t\:t\:t\:t\:t & \mbox{(dfold)}
\end{bnf}

\codefrom{dependent}{lambda}{terme_vector}
\codefrom{dependent}{lambda}{terme_dfold}



Les arguments des différents constructeurs seront expliqué une fois que nous aurrons vu les 
règles de typage:
\begin{align*}
  &\cfrac{\Gamma\vdash * \ni \alpha\:\:\Gamma\vdash Nat \ni n}
  {\Gamma\vdash * \ni Vec\: \alpha\:n }&\mbox{(Vec)} \\
\end{align*}




Ici $\alpha$ sera donc le type des éléments contenus dans le vecteur et \emph{n} sa taille. 
Cette représentation des vecteurs n'est pas familière aux programmeurs, en général si l'on veut appliquer une fonction sur des vecteurs 
de taille précise il faut effectuer un test à l'entrée de la fonction. C'est un des aspects très intéressant des types dépendants dans 
l'utilisation des types dépendants. Si l'on possédait ce genre de constructions dans un language comme Java par exemple, nous
pourrions crée une surchage sur des fonctions qui permettrait de traiter différement les vecteurs de grande taille pour le tri par exemple.
Certains tris étant beaucoup plus efficaces sur de grands vecteurs et inversements. 
Voici maintenant deux constructeurs pour les vecteurs:
\begin{align*}
  &\cfrac{}
  {\Gamma\vdash Vec\:\alpha\:n\ni dnil\:\alpha}&\mbox{(dnil)} \\
  &\cfrac{\Gamma\vdash Vec\:\alpha\:\zero\ni v \:\:\Gamma\vdash \alpha\ni a}
  {\Gamma\vdash Vec\:\alpha\:(succ\:n)\ni dcons\:a\:v}&\mbox{(dcons)} \\
\end{align*}

Le terme \emph{dnil} correspond au vecteur de taille zero, et \emph{dcons} qui nous permet avec d'ajouter un élément dans un vecteur.
\begin{example}
  Voici un vecteur de taille trois et dont les éléments sont des entiers:
  \begin{align*}
    dcons\:zero\:(dcons\:(succ\:zero)\:(dcons\:zero\:(dnil\:Nat)))
  \end{align*}  
\end{example}

Nous pouvons maintenant crée des vecteurs mais nous ne possédons pas encore d'éliminateur pour les utilisers. Nous allons 
implémenter une fonction bien connue des programmeurs fonctionnels, \emph{dfold} dont voici une définition intuitive:
\fun{fold f vec b} $\rightarrow$ \fun{f a1 (f a2(...(f an b)...))}.
Définissons maintenant l'éliminateur \emph{dfold} comme un \emph{terme synthétisable}:
\todo{modifier la présentation aussi}
\begin{align*}
  &\cfrac{\Gamma\vdash *\ni\alpha\:
    \Gamma\vdash Nat \ni n \: 
    \Gamma\vdash \forall n:Nat.\forall v:Vec\:\alpha\:n.*\ni P\:
    \Gamma\vdash Vec\:\alpha\:n\ni v\:
    \Gamma\vdash \forall n:N.\forall v:Vec\:\alpha\:n.\forall a:\alpha.(P\:n\:v\rightarrow P\:(succ\:n)\:(dcons\:a\:v))\ni f}
  {\Gamma\vdash dfold\:\alpha\:P\:n\:v\:f\:a\in P\:n\:v}&\mbox{(dfold)}
\end{align*}

De la meme manière que pour l'éliminateur des entiers naturels \emph{iter}, le prédicat \emph{p} nous permet 
de rendre le type de retour dépendant des différents arguments.

Il existe de nombreuses façon d'utiliser \emph{dfold}, une application assez simple consiste à faire la somme des éléments d'une liste.
Voici le terme correspondant à cette utilisation:
\begin{align*}
  somme_liste\:=\:(lambda\:v (lambda n(dfold\:N\:(lambda\:n\:(lambda\:xs\:N))\:n\:v\:(lambda\:n(lambda\:xs\:(lambda\:a\:(lambda\:x\:(+\:a\:x)))))\:zero)))
\end{align*}

Voici donc le code du type-checker correpondant:

\codefrom{dependent}{lambda}{check_vec}
$\cfrac{\Gamma\vdash * \ni \alpha\:\:\Gamma\vdash Nat \ni n}
  {\Gamma\vdash * \ni Vec\: \alpha\:n }$
\codefrom{dependent}{lambda}{check_dnil}
$\cfrac{}
  {\Gamma\vdash Vec\:\alpha\:\zero\ni dnil\:\alpha}$

\codefrom{dependent}{lambda}{check_dcons}
  $\cfrac{\Gamma\vdash Vec\:\alpha\:n\ni v \:\:\Gamma\vdash \alpha\ni a}
  {\Gamma\vdash Vec\:\alpha\:(succ\:n)\ni dcons\:a\:v}$

\todo{rajouter dfold mais plus tard, la c'est vraiment pas présentable}

\paragraph{Evaluation :} 
Avant d'implémenter l'évaluation dans notre programme il nous faut tout d'abord
rajouter les \emph{valeurs} suivantes à notre language.
\codefrom{dependent}{lambda}{Value_Vector}
Passons maintenant à l'évaluation des vecteurs, nos trois constructeurs 
n'ont pas d'évaluation particulière:
\[\begin{array}{c}
  \inferrule{{\alpha\Downarrow \alpha'\:\:\:n\Downarrow n'}}
            { \vect\:\alpha\:n\Downarrow \vect\:\alpha'\:n'}
  \medskip\\
  \inferrule{{\alpha\Downarrow \alpha'}}
            {\dnil\:\alpha\Downarrow \dnil\:\alpha'}
  \medskip\\
  \inferrule{{a \Downarrow a'\:\:\:xs \Downarrow xs'}}
            {\dcons\:a\:xs\Downarrow \dcons\:a'\:xs'}
\end{array}\]

Ce qui se traduit dans notre algorithme de la façon suivante:
\codefrom{dependent}{lambda}{big_step_vec}

L'évaluation de \emph{dfold} s'effectue de la manière suivante:
\[\begin{array}{c}
  \inferrule{{xs\Downarrow \dnil\:\alpha\:\:\:n\Downarrow \zero}}
            {\dfold\:\alpha\:P\:n\:xs\:f\:a \Downarrow a}
  \medskip\\
  \inferrule{{xs\Downarrow \dcons\:e\:xs'\:\:\:n\Downarrow\succs\:n'}}
            {\dfold\:\alpha\:P\:n\:xs\:f\:a \Downarrow \App{\App{f}{(n\:xs\:e)}}{(\dfold\:\alpha\:P\:n'\:xs'\:f\:a)}}           
\end{array}\]

Si $dfold$ contient des variables libres il nous faut un élément neutre à retourner:

\codefrom{dependent}{lambda}{neutral_fold}
Pour l'implémentation, de la meme façon que avec iter nous avons crée une fonction \fun{vfold}
qui nous permet d'éffectuer l'évaluation:

\codefrom{dependent}{lambda}{vfold}


\subsubsection{L'égalite} 

Pour implémenter l'égalité au sein de notre language il faut nous tourner vers la logique. 
Leibniz philosophe du XVII siècle énonça que deux éléments sont identiques si elles ont les memes propriétés.
\todo{expliquer plus en détail en faisant un parallèle avec la logique}

On peut maintenant introduire le type identité:
\begin{align*}
  &\cfrac{\Gamma\vdash *\ni A \:\: \Gamma\vdash A \ni a \:\: \Gamma\vdash A \ni b }
  {\Gamma\vdash * \ni Id\:A\:a\:b}&\mbox{(Id)}
\end{align*}

refl
\begin{align*}
  &\cfrac{\Gamma\vdash A \ni a}
  {\Gamma\vdash Id\:A\:a\:a\ni refl\:a}&\mbox{(refl)}
\end{align*}

et trans
\begin{align*}
  &\cfrac{
    \Gamma\vdash * \ni A
    \Gamma\vdash A\ni a
    \Gamma\vdash A \ni b
    \Gamma\vdash \forall a:A.\forall b:A.(Id\:A\:a\:b\rightarrow *)
    \Gamma\vdash Id\:A\:a\:b \ni q
    \Gamma\vdash P\:a\:a\:(refl\:a)\ni x}
    {\Gamma\vdash trans\:A\:P\:a\:b\:q\:x\in P\:a\:b\:q}&\mbox{(trans)}
\end{align*}

\todo{roman: a finir quand j'aurais mieux compris}





\subsection{Exemples de preuves}














% pour l'implémentation quand je parle du parser ne pas montrer le code 
% mais expliquer la syntaxe lisp

% pour la prochaine introduction d'implémentation dire que la grosse nouveauté
% c'est le type checker et le fait que on 


%pour le simplement typé quand on introduit la première réduction on peut faire l'analogie avec le compilateur qui une fois que les
%termes on été type checker on peut maintenant oublier les types et maintenant réduire 



%Il faudrait que pour les booléens et tout ce genre de choses je fasse dans la partie formelle des spec correspondants aux evaluations ect..


%partie pour quand l'inspiration est partie

%pour introduire la fonctin d'égalité dans le type checker des types dépendants il faut dire que avant on pouvait comparer nos types directements avec la fonction d'égalité de ocaml car il n'y avait pas de variables dans nos types alors que maintenant oui

%Dans les types dépendants on pourra dire que l'on considère que nos termes sont des programmes 

%  pour l'agalité page 111 de thompson

%% * Outro

\clearpage

\bibliographystyle{abbrvnat}
\bibliography{prerapport.bib,rapport.bib}  

\end{document}

