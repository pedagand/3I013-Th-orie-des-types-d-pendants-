\documentclass {article}

%% ** Packages

\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsthm, amssymb, amsmath}
\usepackage{hyperref}
\usepackage{mathpartir}

%% ** OCaml listings

\usepackage{xcolor}
\usepackage{listings}
\lstset{
  language=[Objective]Caml,
  %% emph={[2]Nil,Cons,FZe,FSu,ze,su,Ze,Su},
  %% emphstyle={[2]\Constructor},
  %% emph={[3]lookup,failwith},
  %% emphstyle={[3]\Function},
  %% emph={[4]vec,fin,nat,list,tree,completeTree},
  %% emphstyle={[4]\Canonical},
  morecomment=[s]{(*}{*)},
  rangeprefix=\(\*\=,
  rangesuffix=\ \*\),
  includerangemarker=false,
  extendedchars=\true,
  inputencoding=utf8,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  basicstyle=\ttfamily\small,
  framesep=4mm,
  moredelim=*[s][\itshape]{(*}{*)},
  moredelim=[is][\textcolor{darkgray}]{§}{§},
  escapechar=°,
  keywordstyle=\color[rgb]{0.627451, 0.125490, 0.941176},
  stringstyle=\color[rgb]{0.545098, 0.278431, 0.364706},
  commentstyle=\color[rgb]{0.698039, 0.133333, 0.133333},
  numberstyle=\color[rgb]{0.372549, 0.619608, 0.627451},
  boxpos=t,
  literate= {'a}{{$\alpha$}}1%
    {->}{{${\to}$}}2
    {*}{{${\times}$}}1
    {::}{{${:\::}$}}1
}

\newcommand{\codefrom}[3]
           {\lstinputlisting[linerange={#3}-End]{../#1/#2.ml}}


%% ** Theorem styles 


\newtheorem{theorem}{Théorème}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemme}

\theoremstyle{definition}
\newtheorem{definition}{Définition}
\newtheorem{example}{Exemple}

\theoremstyle{remark}
\newtheorem{remark}{Remarque}
\newtheorem{para}{} 

%% ** commands

\newcommand{\todo}[1]{\textcolor{red}{#1}}
\newcommand{\attention}[1]{\textcolor{orange}{#1}}
\newcommand{\etc}{\textit{etc.}}
\newcommand{\true}{\mathsf{true}}
\newcommand{\false}{\mathsf{false}}
\newcommand{\bool}{\mathsf{bool}}
\newcommand{\ifte}{\mathsf{IfThenElse}}

%% ** Title

\title{Implémentation de la théorie des types dépendants}
\author{Roman Delgado}
\date{}


\begin{document}

\maketitle


%% ** Abstract 


\begin{abstract} 
  Ce document représente l'ensemble du travail effectué durant l'unité d'enseignement 3I013 de l'upmc,
\end{abstract}

\tableofcontents

\clearpage

%% ** Main

\section{Introduction}

blablawsdsdfsdf

\section{$\lambda$-calcul non typé}

En 1936, Alonzo Church introduit le lambda calcul non typé
~\citep{church:lambda-calcul}. Le $\lambda$-calcul est
un modèle de calcul universel, tout comme les machines de Turing. Celui-ci repose
sur une syntaxe minimaliste et permet de formaliser le concept de fonction. Il est au coeur de nombreuses recherches dans le domaine de la 
programmation fonctionnelle. Le lambda calcul non typé a connu un formidable 
succès pratique, donnant lieu à de multiples variantes dont on trouvera une présentation
 moderne et synthétique dans l'ouvrage de ~\citet{pierce:tapl}.


\subsection{Présentation formelle}

\subsubsection{Syntaxe}
Le $\lambda$-calcul est composé uniquement de \(\lambda\)-termes dont voici la syntaxe

\newcommand{\Lam}[2]{\ensuremath{\lambda #1. #2}}
\newcommand{\App}[2]{\ensuremath{#1\:#2}}
\newcommand{\Var}[1]{\ensuremath{#1}}


\begin{align*}
  t &::= & \mbox{(lambda terme)} \\
  &|\quad \Var{x} & \mbox{(variable)} \\
  &|\quad \Lam{x}{t} & \mbox{(abstraction)} \\
  &|\quad \App{t}{t}          & \mbox{(application)}
\end{align*}

Pour faire une analogie avec les mathématiques, une abstraction peut
être vue comme une définition de fonction anonyme.
 
\begin{example}
 La fonction identité est définie par le $lambda$-terme suivant : $\Lam{x}{\Var{x}}$
\end{example}

On peut constater avec cette syntaxe que les abstractions ne prennent
qu'un seul argument. Cependant, l'ensemble des fonctions à plusieurs
arguments peut etre représenté, par curryfication, à l'aide une
succession de fonctions à un seul argument.

\begin{example}
  Le \(\lambda\)-terme $\Lam{x y}{t}$ correspond au terme %$\Lam{x}{\Lam{y}{t}}$  
\end{example} 

Dans la suite de cet article nous utiliserons des fonctions à un seul
argument.

\subsubsection{Variables libres et variables liées}

\newcommand{\IsFree}{\mathrm{isFree}}

Une variable est liée lorsque celle ci est déclarée dans le corps d'un lambda, 
dans l'exemple précédent x était une variable liée. 
Si la variable n'a pas été déclarée, elle est dite libre. 

\begin{align*}
  \IsFree(x) &\triangleq \{x\} \\
  \IsFree(\lambda x. t) &\triangleq \IsFree(t)/\{x\} \\
  \IsFree(f s) &\triangleq \IsFree(f) \cup \IsFree(s) \\
\end{align*}


\begin{example}
  Dans le terme suivant \(\lambda x.\lambda y.x\:y\:z\) \(\Lam{x}{\Lam{y}{\App{\App{\Var{x}}{\Var{y}}}{\Var{z}}}}\), 
  les variables $\Var{x}$ et $\Var{y}$ sont liées tandis que la variable $\Var{z}$ est libre 
\end{example}


Un terme ne contenant aucune occurrence de variable libre est dit ``clos''.

\begin{example}  
  \label{example:ouvert-clos}  
  Dans le $\lambda$-terme \(\App{\Lam{x}{\Lam{y}{\App{x}{y}}}}{\Var{y}}\), la
  variable $Var{x}$ est liée ainsi que la première occurence de la
  variable $Var{y}$. Cependant, la variable $Var{y}$ à l'extérieur des
  parenthèse est libre.
\end{example}

\label{problemelibreliee}
Un des problèmes introduit par cette représentation des variables est qu'il devient assez compliqué de déterminer si une variable est libre ou non, comme on peut le constater dans l'exemple ci-dessus (Exemple~\ref{example:ouvert-clos}). Il faut donc introduire la notion 
d'$\alpha$-équivalence.

\subsubsection{$\alpha$-équivalence}

\newcommand{\equivAlpha}{\mathop{\equiv_\alpha}}

On considère que deux termes sont \(\alpha\)-équivalents si et seulement si ils sont 
égaux au renommage de leur variables liées près. 
\begin{example}
  Voici deux termes alpha équivalents 
  \begin{align*}
    & \Lam{x}{Var{x}} \equivAlpha \Lam{y}{Var{y}} \\
  \end{align*}
\end{example}
  
\subsection{Calculer dans le lambda calcul}
\label{calculer_dans_le_lambda_calcul}

Dans le lambda calcul pur, il n'existe pas de primitive pour effectuer des 
calculs. Le seul moyen de calculer de nouveaux termes est de les appliquer 
entre eux. Mais il nous faut tout d'abord définir le mécanisme de substitution par lequel se réalise la notion de calcul.

\subsubsection{Substitution}

\newcommand{\subst}[3]{#1[#2 := #3]}


La substitution est un mécanisme central dans le lambda calcul. Cela consiste 
à remplacer l'occurrence d'une variable liée par un \(\lambda\)-terme.
On note généralement la substitution de la variable $\Var{x}$ dans le terme $\Var{t}$ par le 
terme u avec la notation suivante. 
\[ 
\subst{t}{x}{u}
\]

Définition formelle de la substitution: 
\begin{align*}
    \subst{x}{x}{u} &\triangleq u \\
    \subst{x}{y}{u} &\triangleq x \\
    \subst{\lambda x.t}{x}{u} &\triangleq \lambda x.(\subst{t}{x}{u}) \\
    \subst{\lambda y.t}{x}{u} &\triangleq \lambda x.t \\
    \subst{(t\: v)}{x}{u} &\triangleq (\subst{t}{x}{u}\: \subst{v}{x}{u}) 
\end{align*}

\begin{example}
  Soit le terme $\Lam{x}{\subst{x}{x}{\Lam{y}{y}}}$, après avoir effectué la
  substitution nous obtenons le terme $\Lam{x}{\Lam{y}{\Var{y}}}$.
\end{example}


\subsubsection{$\beta$-réduction}


\label{reduction}
Seules les applications de la forme \(\App{(\Lam{\Var{x}}{t})}{u}\),
dont le membre de gauche est une abstraction, peuvent être réduites :
un tel terme s'appelle un
\emph{redex}~\citep{krivine:lambda-calculus}. Le terme
\(\subst{t}{x}{u}\), obtenu après réduction, est appelé son
\emph{contracté}.

\begin{example}
  Le terme \(\App{\Lam{x}{x}}{u}\) est \attention{``un'' redex, pas ``une''} un redex tandis que le terme
  \(\App{x}{u}\) n'en est pas un.
\end{example}

\newcommand{\Red}{\leadsto}
\newcommand{\Conv}{\leadsto^{*}}

Formellement, on définit la \(\beta\)-réduction par induction sur les
termes :
\[\begin{array}{c}
  \inferrule{{}}
            {\App{\Lam{\Var{x}}{t}}{u} \Red \subst{t}{x}{u}}
  \medskip\\
  \inferrule{t \Red t'}%
            {\Lam{\Var{x}}{t} \Red \Lam{\Var{x}}{t'}}
  \medskip\\
  \inferrule{t \Red t'}
            {\App{t}{u} \Red \App{t'}{u}}
  \medskip\\
  \inferrule{u \Red u'}
            {\App{t}{u} \Red \App{t}{u'}}
\end{array}\]

On obtient la \(\beta\)-conversion en prenant la clôture reflexive et
transitive \(t \Conv t'\) de la \(\beta\)-réduction : on a \(t \Conv
t'\) s'il existe une suite de \(\beta\)-réductions telles que \(t \Red
\ldots \Red t'\).

\begin{example}
  Soit le terme \attention{problème de parenthèse} \(\App{\Lam{x}{\Lam{y}{\App{y}{x}}}}{z}\).  Ce terme est
  sous la forme d'une application ayant une abstraction comme membre
  de gauche. La réduction consiste à substituer la variable liée par
  l'abstraction par le membre droit de l'application. On obtient donc 
   \(\Lam{x}{\Lam{y}{\App{z}{x}}}\)
\end{example}

\begin{example}
  Voici un autre exemple de réduction
  \begin{align*}
    & ((\lambda x .\lambda y. z) w) \leadsto \lambda x.\lambda y.z \\
  \end{align*}
  Ici z étant une variable libre il n'y a rien à réduire.
\end{example}


\subsubsection{Stratégie de réduction : appel par nom}

\label{reduction:call_by_name}
Un terme est dit en \emph{forme
  normale}~\citep{krivine:lambda-calculus} si on ne peut plus lui
appliquer de réduction: il ne contient aucun redex. La normalisation
consiste donc à reduire autant que possible notre terme. En
particulier, on caractérise inductivement les formes normales de la
façon suivante :
%
\begin{itemize}
\item Une variable \(\Var{x}\) est en forme normale ;
\item Si \(t\) est en forme normale, alors \(\Lam{\Var{x}}{t}\) est en
  forme normale ;
\item Si \(t\) et \(u\) sont en formes normales et que \(u\) n'est pas
  une abstraction, alors \(\App{t}{u}\) est en forme normale.
\end{itemize}

On en déduit qu'un terme est en forme normale si et seulement s'il est
de la forme
\(\Lam{\Var{x_0}}\ldots\Lam{\Var{x_k}}\App{\App{\App{x_i}{t_0}}{\ldots}}{t_l}\)
où les \(t_j\) sont eux-mêmes des termes normaux.



\attention{Pas vraiment :} Cependant il
existe tout de meme deux formes normales, la faible qui considère
qu'un lambda est une valeur finale, et la forte où meme les redex à
l'intérieure d'une \emph{abstraction} doivent etre évaluées.  Il
existe donc plusieurs stratégies de réduction qui permettent
d'atteindre différents type de forme normale.

\begin{example}
  Le terme 
  \begin{align*}
    (((\lambda x.x) (\lambda y.y)) z) &\leadsto ((\lambda y.y) y) \\
    & \leadsto y
  \end{align*}
  Ici y n'est plus réductible c'est donc la forme normale du terme.
\end{example}

Le lambda calcul étant un modèle de calcul universel, il permet de 
d'écrire des termes/programmes qui ne terminent pas : ceux-ci n'ont pas 
de forme normale. 

\begin{example}
 
  Le terme suivant n'admet pas de forme normale :
  %
  \begin{align*}
  (\lambda x. x\: x) (\lambda x. x\: x) &\leadsto (x x)[x \mapsto \lambda x. x\: x] \\
                                        &\leadsto (\lambda x. x\: x) (\lambda x. x\: x) \\
                                        &\leadsto \ldots \\
  \end{align*}
\end{example}

Il existe de nombreuses stratégies de normalisation des termes dans le
lambda calcul non typé, les plus connues étant l'\emph{appel par nom}
et l'\emph{appel par valeur}.  Pour le lambda calcul non typé 
nous avons choisis d'utilisé l\emph{appel par valeur}. Elle consiste à
réduire les \emph{redex} sauf celle étant sous une \emph{abstraction}.

\begin{align*}
  AppelParValeur(x) &\triangleq x \\
  AppelParValeur(\Lam{x}{t}) &\triangleq \Lam{x}{t} \\
  AppelParValeur(\App{\Lam{x}{t}}{u}) &\triangleq AppelParValeur(\subst{t}{x}{u}) \\
  AppelParValeur(\App{t}{u}) &\triangleq AppelParValeur(\App{AppelParValeur(t)}{u})
\end{align*}

Pour certains termes, on ne peut pas atteindre une forme normale forte, cela
permet de se rapprocher des définitions de fonctions dans les languages de 
programmations où l'on ne précalcule pas les valeurs au seins d'une fonction.

\begin{example}
  Voici une réduction avec la stratégie \emph{appel par valeur}:
  \begin{align*}
    & \App{\Lam{x}{\Var{x}}}({\App{\Lam{y}{\Var{y}}}({\Lam{z}{\App{\Lam{x}{\Var{x}}}{\Var{z}}}}})) \\
    \rightarrow & \App{\Lam{y}{\Var{y}}}({\Lam{z}{\App{\Lam{x}{\Var{x}}}{\Var{z}}}})\\
    \rightarrow & \Lam{z}{\App{\Lam{x}{\Var{x}}}{\Var{z}}}\\
    \nrightarrow & \:
  \end{align*}
  Ici il n'y a plus rien à réduire avec notre stratégie. On obtient une forme normale faible.
\end{example}

%je sais pas si cette partie la est judicieuse je pense que oui ça permet d'
%introduire un peu la suite du rapport 
Dans les sections suivantes, nous verrons lorsque nous introduirons
les systèmes de type que l'on peut ne considérer que des termes qui
réduisent vers une forme normale (c'est une des propriétés
intéressante offerte par les systèmes de type)

\attention{Question classique : si tu ne peux plus écrire de
  programmes qui ne terminent pas, tu n'es plus Turing complet donc tu
  es strictement moins expressif que tous les langages de
  programmation existants. Est-ce gênant ?}

\begin{example}
  Voici un exemple d'évaluation avec la stratégie call by value
  \begin{align*}
    & ((\lambda x.\lambda y. x\: y)\: \lambda w.w)  \\
    \leadsto & (\lambda y. (\lambda w.w)\: y) 
  \end{align*}
\end{example}





\subsection{Encodages à la Church}

~\citet{church:lambda-calcul}

Le $\lambda$-calcul possède un noyeau de language minimaliste cependant 
Church ~\citet{church:lambda-calcul} a introduit de nombreux encodages de 
construtions familières aux développeurs, tels que les entiers,
les booléens, ...


\subsubsection{Les booléens de Church}

\newcommand{\True}{\ensuremath{\mathrm{true}}}
\newcommand{\False}{\ensuremath{\mathrm{false}}}
\newcommand{\Ifte}{\ensuremath{\mathrm{ifte}}}

Nous allons ici voir une représentation des booléens accompagnée de la 
structure de contrôle \texttt{if ... then ... else ...}.
Voici les termes correspondants aux constructeurs $True$, $False$ et 
$IfThenElse$
\begin{align*}
  \True &\triangleq \lambda x.\lambda y. y  \Lam{x}{\Lam{y}{\Var{y}}} \\
  \False &\triangleq \lambda x.\lambda y. x \Lam{x}{\Lam{y}{\Var{x}}} \\
  \Ifte &\triangleq \Lam{l}{\Lam{m}{\Lam{n}{\App{\Var{l}}{\App{\Var{m}}{\Var{n}}}}}}  \\
\end{align*}

On assimile ces deux termes aux booléens $True$ et $False$ car leur calcul au sein
de l'application d'un $Ifte$ reproduit le comportement attendu.

\begin{example}
  Voici un exemple de réduction du terme Ifte avec comme condition \emph{False}:
  \begin{align*}
    &\App{\App{\App{(\Lam{l}{\Lam{m}{\Lam{n}{\App{\App{l}{m}}{n}}}}})({\Lam{x}{\Lam{y}{y}}}}){v}}{w} \\
    \rightarrow & \App{\App{({\Lam{m}{\Lam{n}{\App{\App({\Lam{x}{\Lam{y}{y}}}){m}}{n}}}}}){v}}{w} \\
    \rightarrow & \App{(\Lam{n}{\App{\App({\Lam{x}{\Lam{y}{y}}}){v}}{n}})}{w} \\
    \rightarrow & \App{\App({\Lam{x}{\Lam{y}{y}}}){v}}{w}) \\
    \rightarrow & \App({\Lam{y}{y}}){w}) \\
    \rightarrow & \Var{w}
  \end{align*}
\end{example}

Ici nous n'avons aucun moyen de vérifier avant normalisation que le premier
argument de Ifte est un booléen, nous ne pouvons pas garantire la bonne évaluation
de notre terme.

\todo{Tu pourrais faire une petite remarque sur l'encodage objet des
  booléens, qui est effectivement utilisé dans des langages purement
  objets comme Self, Smalltalk ou Pharo.}

\subsubsection{Les entiers de Church}

Ici, nous allons voir comment créer
les entiers naturels \textit{ex nihilo} en utilisant un \emph{encodage à
  la Church}.

L'idée consiste à représenter le nombre \(n\) par une fonction d'ordre
supérieur prenant en argument une fonction \Var{f} et l'appliquant \(n\)
fois à un argument \Var{x}. On définira donc 
%
\begin{align*}
\mathsf{zero} &= \lambda f. \lambda x. x \\
\mathsf{un}   &= \lambda f. \lambda x. f\: x \\
\mathsf{deux} &= \lambda f. \lambda x. f\: (f\: x)
\end{align*}

Afin de construire tous les entiers naturels, on s'inspire alors de la
définition des entiers de Peano et définit le successeur d'un nombre \(n\)
comme
%
\[
\mathsf{successeur} = \lambda n. \lambda f. \lambda x. n\: f\: (f\: x)
\]
%
c'est-à-dire \(n\) applications de \(f\) précédées d'une première
application de \(f\), soit \(n+1\) applications.

De la même manière, on construit l'addition de deux nombres \(m\) et
\(n\) en faisant \(m\) applications répétées de \(f\) précédées par
\(n\) applications :
%
\[
\mathsf{plus} = \lambda m. \lambda n. \lambda f. \lambda x. m f (n f x)
\]


\subsection{Implementation}

Nous nous attarderons ici sur les choix d'implémentations et il sera question
d'analyser certaines parties du code et non sa totalité.

\subsubsection{Représentation des $\lambda$-termes}
 
Pour pallier au problème que nous énoncions précédement ~\ref{problemelibreliee}, nous
utilisons une représentation particulière pour les variables liées:
les indices de de Bruijn.  Nous allons ainsi représenter les variables
liées non pas par un nom mais par un entier naturel. Cette valeur est determiné 
à partir du nombre de $\lambda$ entre la variable et le $\lambda$ qui la lie.

\begin{example}
  Le $\lambda$-terme représentant l'identité, que l'on écrivait \(\lambda x.x\), est représenté par \(\lambda.0\)
  et le terme $\Lam{x}{\Lam{y}{x}}$ s'écrira maintenant $\lambda.\lambda.1$ 
\end{example}

Mais nous n'allons pas simplement utilisé une représentation avec les indices de de Bruijn 
car pour la représentation des variables libres nous utiliserons comme précédement un nom
de variable. On appelle cette représentation ``locally nameless'' ~\citep{chargueraud:locally-nameless}

Voici le code Ocaml traduisant la définition inductive des termes que nous avions 
définis.

\codefrom{untyped}{lambda}{untyped_term}

\todo{Il serait super cool de faire des références de l'implémentation
  vers la définition formelle. Tu pourrais utiliser une ``footnote''.}

Cette représentation se rapproche au plus de la spécification
formelle, seule la distinction entre les variables liées \lstinline!BoundVar! et les
variables libres \lstinline!FreeVar! diffère du fait que que nous utilisons désormais 
la représentation ``locally nameless''.


\subsubsection{Analyse syntaxique}

\todo{Je ne vois pas trop l'intérêt de cette section. Soit tu définis
  formellement le parser (sans donner le code), soit tu dis juste dans
  une phrase, quelque part que ta syntaxe de haut niveau est celle de
  Lisp, sans en dire plus (parce que c'est assez commun)}

\todo{Phrase très longue :}
Afin de permettre de construire des termes rapidement et le plus lisible 
possible la création d'un parseur s'imposait.
La notation choisie a été la notation préfixe (notation polonaise inversée),
une syntaxe très proche du langage lisp. En plus d'etre simple à comprendre
elle est facile à implémenter avec l'aide des S-expressions.

\begin{example}
  Voici un exemple de correspondance entre les termes avant et après parsing
  \begin{tabular}{ll}
    \lstinline!(lambda x x)! & \lstinline!Abs(BoundVar 0)! \\
    \lstinline!(x y)! & \lstinline!Appl(FreeVar "x", FreeVar "y")!
  \end{tabular}
\end{example}

Comme on peut le constater dans l'exemple pour alléger la redaction des termes,
on utilise une représentation des variables classiques, c'est dans le parseur que 
l'on determine la valeur de l'indice d'une variable si celle ci est liée et son 
nom si celle ci est libre. Les termes sont donc bien conforme à la 
représentation ``locally nameless''
Pour l'affichage de nos termes on effectue l'opération inverse, c'est à dire que
les chaines de caractères en sortie seront elle memes des S-expressions.

\subsubsection{Substitution}

On découvre ici un nouvel avantage de notre représentation avec les indices de
de Bruijn, car il n'est pas nécessaire de prendre des précautions quant au
nom des variables de notre terme substituant qui rendrait liée une variable qui était libre. 

\begin{example}
  Avec la représentation classique:
  \[ 
  \lambda x.x[x := \lambda y.x]\leadsto\lambda x.\lambda y.x
  \]
  
  On constate dans cet exemple que la substitution génère une ambiguité sur la variable \emph{x},
  on ne peut plus déterminé si celle-ci est liée ou libre.
  Voici la meme substitution avec la représentation ``locally nameless''
  \[ 
  \lambda.0[0 := \lambda.x]\leadsto\lambda.\lambda.x
  \]
  Ici l'ambiguité n'existe plus, on sait que \emph{x} est une variable libre.
\end{example}

Implémentons donc la substitution dans notre programme:

\codefrom{untyped}{lambda}{substitution}

L'argument \emph{term} correspond au terme dans lequel on va substituer le terme \emph{tsub} et 
l'argument \emph{var} est un entier qui va nous permettre de compter le nombre de binder \(\lambda\)
traversés. Si l'on recontre une BoundVar avec comme indice var on retourne donc \emph{tsub} à la 
place de celle-ci.


\subsubsection{$\beta$-Reduction et évaluation}
La fonction de réduction consiste donc à trouver les applications dont le membre 
de gauche est une abstraction \ref{reduction}.
Nous appelons la fonction de substitution  avec la
valeur \(0\) car on souhaite substituer l'ensemble des variables du binder
\(\lambda\) en cours.

\codefrom{untyped}{lambda}{reduction}

Nous disposons de l'ensemble des fonctions nécessaires afin de faire une évaluation 
correspondant à la stratégie d'évaluation call bu value. En voici une implémentation
possible: 
\todo{Pierre : Je ne suis pas très fan de cette implémentation, je vais voir si je peux proposer mieux}

\codefrom{untyped}{lambda}{evaluation}

Si l'on trouve un redex, on reduit puis l'on evalue le resultat de la reduction,
et si le membre de gauche n'est pas une variable on evalue celui-ci pour determiner
si celui ci peut nous donner une abstraction afin de pouvoir effectuer une réduction.
Conformément à la stratégie, on n'évalue jamais le membre de gauche d'une application
pour les raisons énoncées dans la section d'évaluation ~\citep{reduction:call_by_name}.


\subsubsection{Les booléens}

Afin d'implémenter les boléens dans notre language un choix d'implémentation 
possible est de simplement définir de nouveaux termes True,False et Ifte
comme nous l'avons vu dans la section précédente. Cependant nous avons choisi 
d'enrichir le noyau de notre language en créant trois nouveaux constructeurs.
Cela permet de ne pas alourdir l'écriture de certains termes ainsi que 
d'améliorer la représentation et d'automatiser des opérations d'évaluation.

\codefrom{untyped}{lambda}{bool_term}

Pour la substitution des termes \emph{True} et \emph{False} les règles 
sont triviales. Pour le terme \emph{IfThenElse} il faut rappeler la 
fonction de substitution sur l'ensemble des arguments du constructeur.
Il n'est pas nécéssaire d'incrémenter la valeur de \emph{var} étant donné
que ce constructeur ne lie aucune variables.

\codefrom{untyped}{lambda}{bool_substitution}

Pour la réduction il n'y à pas de réduction possible pour nos termes
ce qui reviens donc a retourner le terme sans aucunes modifications.


Voici enfin la section correspondant à l'évaluation des booléens.
Encore une fois True et False s'évaluant simplement en True et False ils
ne représentent aucune difficulté d'implémentation. En ce qui concerne
le terme \emph{IfThenElse} si le premier argument est \emph{True}
on retourne alors le second argument et on retourne le troisième argument 
dans le cas où la condition serait un \emph{False}. Dans le cas 
où le premier argument ne sera pas un booléens on evalue celui ci pour 
essayer d'obtenir un booléens qui nous permettrait d'évaluer notre 
terme.

\codefrom{untyped}{lambda}{bool_evaluation}


\subsubsection{Les entiers}

Tout comme pour les booléens nous allons ajouté les trois constructeurs 
\emph{Zero},\emph{Succ} et \emph{Iter} à notre language.

\codefrom{untyped}{lambda}{nat_term}

Pour ce qui est de la substitution et la réduction le comportement est très
similaire à celui des boléens et ne nécessite pas d'explications supplémentaires.

Substitution:

\codefrom{untyped}{lambda}{nat_substitution}

Reduction:

\codefrom{untyped}{lambda}{nat_reduction}

En revanche l'évaluation du terme \emph{Iter(n,f,a)} est déja plus intéressante.
Si le premier argument est \emph{Zero} alors il faut retourner le terme \emph{a}.
Si \emph{n} est un \emph{Succ(num)} alors il faut d'abord evaluer l'application 
\emph{(f a)}. puis rappeler la fonction d'évaluation avec le terme 
\emph{Iter} avec ces nouveaux arguments.

\codefrom{untyped}{lambda}{nat_evaluation}

\section{Le lambda calcul simplement typé}

%je ne sais pas si je met ça ici ou dans l'introduction du debut à voir
En gros dire que ça ne sert a rien de compiler du code qui ne peut pas marcher

\subsection{Les types}

Il est important avant tout de définir ce qu'est un type.
Considérons \emph{P} l'ensemble des types de base comme par exemple 
\emph{int} l'ensemble des entiers et \emph{bool} l'ensemble des booléens.
Et soit \emph{*} l'ensemble des types, on peut alors définir de façon inductive
ce qu'est un type.
\begin{align*}
  * &::= \\
  &| int \\
  &| bool \\
  &| * \rightarrow * \\
  &| * \times * \\
\end{align*}

Le type \(\rightarrow\) correpond au type des fonctions et le type (a*b)
correspond au type des couples que nous allons désormais introduire dans notre language.

\begin{example}
  Voici des exemples de type:
  \begin{equation}
    int \rightarrow bool  \label{eq_1} 
  \end{equation}
  \begin{equation}
    (bool * int) \label{eq_2} 
  \end{equation}
  Le type \ref{eq_1} est celui d'une fonction prenant un argument de type \emph{int} et 
  retournant un résultat de type \emph{bool}.
  Le second type \ref{eq_2} correspond a une pair donc le membre de gauche est un \emph{bool}
  et le membre de droit un \emph{int}
\end{example}

Comme nous l'avons vu précédement avec la curryfication qui consistait à exprimer une 
fonction avec plusieurs arguments en une succession de fonctions à un argument, cela 
se répercute aussi sur les types.

\begin{example}
  Soit la fonction \(\lambda\)x\:y.(x y) peut s'exprimer 
  \(\lambda\)x.\(\lambda\)y.(x y) qui pourrait donc avoir 
  le type (int \(\rightarrow\) int)\(\rightarrow\) int \(\rightarrow\) int
\end{example}

\subsection{Système de type}

Introduire le système de type en une ligne
\subsubsection{Spécification}

Afin de faciliter la lecture et la compréhension nous allons dans 
un premier temps donner les règles de typage pour les termes appartenants au noyau 
du language. Nous donnerons les autres règles dans les sections suivantes.

La vérification de type s'effectue dans un \emph{contexte} qui assigne
à chaque variable d'un programme son type. Le contexte est donc une
liste ordonnée de paires variable/type :
%
\begin{align*}
  \Gamma &::= &\mbox{(contexte)} \\
         &\quad . & \mbox{(contexte vide)} \\
         &\quad \Gamma, x : * & \mbox{(type de variable)} 
\end{align*}

Les règles de typage sont définies en Figure~\ref{fig:typage-simple}.

\begin{figure}
\[
\begin{array}{c}
\inferrule[(Var)]%
             {x:T\,\in\Gamma}%
             {\Gamma\vdash x:T} 
\medskip\\
\inferrule[(Abs)]%
          {\Gamma, x:A \vdash t:B}%
          {\Gamma \vdash \lambda x. t \,:\, A\rightarrow B}
\qquad
\inferrule[(App)]%
          {\Gamma \vdash f : A\rightarrow B \\
           \Gamma \vdash s : A}%
          {\Gamma\vdash f\: s : B}
\medskip\\
\inferrule[(true)]
          {{}}
          {\Gamma\vdash \mathsf{true} : \mathsf{bool}}
\qquad
\inferrule[(false)]
          {{}}
          {\Gamma\vdash \mathsf{false} : \mathsf{bool}}
\medskip\\
\inferrule[(If-else)]
          {t1:\mathsf{bool} \\
           t2:T \\
           t3:T}
         {\Gamma\vdash if t1 then t2 else t3}
\end{array}
\]

\caption{Typage (lambda calcul simplement typé)}
\label{fig:typage-simple}
\end{figure} 

La règle (Var) spécifie le typage des variables. Cette expression se
lit en partant du numérateur pour déduire le dénumérateur : supposons
que la variable x de type T est présente dans le contexte, alors on
conclut que le type de la variable x est T.

La règle (Abs) spécifie le typage des lambda
abstractions. L'abstraction construit un type de la forme \(A
\Rightarrow B\) : il faut donc que la variable associée au lambda
terme soit de type \(A\) et le résultat de type \(B\).

La règle (App) sécifie le typage de l'application. Ici le première
argument d'une application doit nécéssairement etre du type 
$A \rightarrow B$. Dans la section d'évaluation ~\ref{reduction:call_by_name}
nous avions vu que l'on réduisait seulement les \emph{redex}.
Maintenant nous pouvons éliminé les applications qui ne réduise pas grace à
notre système de type. De plus on vérifie que \emph{s} est bien du type 
\emph{A} pour garantire l'évaluation.


\begin{example}
  \label{probleme:type_simple}
  Voici donc quelques exemples de dérivations de type.
  Ces dérivations se lisent du bas vers le haut.
  
  
  JE PENSE QUE JE VAIS DEVOIR FAIRE DES CFRACS DE CFRACS ECT MAIS SI
  IL EXISTE UNE MEILLEUR SOLUTION JE PREFERE ATTENDRE
  %faire une application basique avec le lambda terme de l'identité a gauche appliqué a un truc nul et le tout de type entier cela 
  % va nous permettre de montrer que l'on doit faire de la magie sur le type de A
\end{example}

%ici je pourrais dire que l'on doit annoter tous les termes mais que c'est trop lourd
%syntaxiquement donc que on préfère introduire le bi-directionnel
Comme nous avons pu le constater dans le dernière exemple il nous manque des informations
quand au type de \emph{f}. En effet lorsque l'on vérifie une \emph{Appl} il faut 
vérifier que le membre de gauche est de type $A \rightarrow B$ alors que l'on ne connait 
que \emph{B}. Nous allons donc introduire une nouvelle représentation de nos termes 
afin de résoudre ce problème.

\subsubsection{Système de type bi-directionnel}

Les applications dont le membre de gauche est une abstractions posent problème comme vu dans l'exemple ~\ref{probleme:type_simple}.
Nous allons donc catégoriser nos \(\lambda\)-termes dans deux sous catégorie, 
d'un coté les termes pouvant se trouver à gauche au sein d'une application et les autres.

\begin{align*}
  ex &::= & \mbox{exTermes} \\
  &| (ex\: in) &\mbox{Appl}\\
  &| x &\mbox{Var} \\
  in &::= & \mbox{inTermes}\\
  &|\lambda x.in &\mbox{Abs}\\
  &|inv(ex) &\mbox{Inv}\\
\end{align*}

On constate tout d'abord qu'un nouveau terme à fait son apparition, \emph{inv}.
Celui ci permet de passer des \emph{inTermes} aux \emph{exTermes}. Pour l'instant on ne peut pas
encore faire le chemin inverse, c'est à dire passer des exTermes aux inTermes nous 
l'introduiront par la suite.
On a maintenant résolu notre problème d'avoir une application dont le membre de gauche
est une abstraction, cependant si l'on ne peut plus écrire des termes sous cette forme
cela retire tous les calculs de notre language.
La principale raison pour laquel nous ne pouvions pas typechecker les abstractions 
dans le membre gauche de l'application était du au manque d'information quand au type 
de celle ci.
On va donc introduire un nouveau terme permettant de passer des exTermes aux inTermes 
mais en demandant de l'information quand à son type, l'annotation.

Voici donc notre nouvelle représentation des termes:

\begin{align*}
  ex &::= & \mbox{exTermes} \\
  &| (ex\: in) &\mbox{Appl} \\
  &| x &\mbox{Var} \\
  &| (in:Type)&\mbox{Ann} \\
  in &::= & \mbox{inTermes} \\
  &|\lambda x.in &\mbox{Abs} \\ 
  &|inv(ex) &\mbox{Inv} \\
\end{align*}


\begin{example}
Voici maintenant la dérivation qui nous possait problème précédement.
FAIRE LA DERIVATION ET CA MARCHE !!
\end{example}

Nous avons donc résolu ce problème grace à l'introduction d'un système bi-directionnel
cependant si nous avions introduit l'annotation directement dans notre système précédent le 
problème ne se serait pas posé. Cependant cette solution nous à permis de savoir précisément 
quand il était nécéssaire d'annoter nos termes et donc de réduire au maximum le nombre d'annotations.

Voici donc nos nouvelles règles de typage en Figure~\ref{fig:typage-simple-bi-direct}.

\begin{figure}
\label{regles typage bidirectionnel}
\center\boxed{\Gamma\vdash T \ni t}

\begin{align*}
  &\cfrac{T = A \rightarrow B \: \Gamma, x:A \vdash B \ni t}
  {\Gamma \vdash T \ni \lambda x. t}\mbox{(Abs)}&\: \\
  &\cfrac{\Gamma \vdash t \in T' \:\: T=T'}
  {\Gamma\vdash T \ni inv(t)}\mbox{(Inv)} \\
\end{align*}

\center\boxed{\Gamma\vdash t \in T}

\begin{align*}
  &\cfrac{x:T \in \Gamma}
  {\Gamma \vdash x \in T }\mbox{(Var)}&\: \\
  &\cfrac{\Gamma \vdash f \in A\rightarrow B \quad \Gamma\vdash A \ni s }
  {\Gamma\vdash f\:s\in B}\mbox{(App)} \\
  &\cfrac{\Gamma\vdash T \ni t}
    {\Gamma\vdash (t:T) \in T}\mbox{(Ann)} \\
\end{align*}

\caption{Typage (lambda calcul simplement typé Bi-directionnel)}
\label{fig:typage-simple-bi-direct} 
\end{figure}   

Les règles de la forme \(\Gamma\vdash T \ni t\) sont des règles de vérification (check),
celles de la forme \(\Gamma\vdash t \in T\) des règles de synthèse.
Pour la vérification on connait le type \emph{T} et l'on souhaite déterminer si le terme \emph{t}
est bien de ce type. Pour la synthèse, on ne connait pas le type de \emph{t} et l'on souhaite le
determiner.

\begin{example}
EXEMPLE DE DERIVATION AVEC LES NOUVELLES REGLES
\end{example}

\todo{ajouter une phrase sur le fait qu'un terme bien typé par la spec est bien type dans notre système}
\subsection{Normalisation} %en gros calculer dans le lambda calcul non typé

Dans cette section nous verrons certaines propriétés offertent par les systèmes de type, et nous parlerons 
de l'évaluation. Nous ne reviendrons pas sur la substitution ni la réduction car cela reste identique par 
rapport à la section \ref{calculer_dans_le_lambda_calcul}.

\subsubsection{Méta-théorie}

Le typage permet d'obtenir, à la compilation, des garanties quant à la
bonne exécution des programmes.  Formellement, ces garanties se traduisent en deux propriétés essentielles d'un système de type :
\begin{description}
\item[``Progress'':] soit \(t\) un terme correctement typé alors \(t\) est une valeur ou il
 existe une réduction telle que \(t \leadsto t'\)
\item[``Preservation'':] si un terme \emph{t} a le type \emph{T}
et que \emph{t} $\leadsto$ \emph{t'} alors \emph{t'} est de type \emph{T}
\end{description}

La conjonction de ces deux propriétés donne le slogan 
``un programme bien typé ne plante jamais'' (citation Milner)  
tout programme bien typé réduit vers une valeur nécessairement bien typé. 

Nous avons désormais des garanties quant à la terminaison de nos programme.
Cela se traduit par le fait que l'on pourra systématiquement obtenir une 
forme normale pour nos termes contrairement au \(\lambda\)-calcul non typé.

\begin{example}
  Reprenons le terme ((\(\lambda\)x.x x) (\(\lambda\)x.x x)) que nous ne parvenions 
  pas à réduire précédement. Maintenant ce terme ne peut plus etre écrit. Essayons
  tout de meme de trouver un type pour l'annotation du membre gauche de l'application.
  \begin{align*}
    & ((\lambda x.x x : ?X) (\lambda x.x x)) \\
    ?X &::= ?X \rightarrow ?X
  \end{align*}  
  Nous ne pouvons donc plus écrire ce terme.
\end{example}

\subsubsection{Reduction forte}

\label{reduction_forte}
Dans le \(\lambda\)-calcul non typé nous avions utilisé une stratégie d'évaluation \emph{Appel par nom}
car nous souhaitions éviter d'évaluer des termes ne pouvant se normaliser et donc de provoquer la
terminaison prématurée du programme.
D'après les propriétés de la section précédente nous disposons de la certitude que une fois 
acceptés par le type-checker nos termes réduisent tous.
Nous allons donc implémenter une stratégie de réduction forte.

Les types ne sont pas utiles lors de l'évaluation. Nous allons donc tout d'abord implémenter
une fonction de réduction forte sur les \(\lambda\)-termes non typés.

Voici la spécification de notre réduction forte :
%si ce n'est pas ce genre de chose qu'il faut que je dise je ferais un texte ici expliquant la réduction forte.
\todo{a changer avec un tableau de cfrac montrant l'évaluation}
\begin{align*}
  rdf ::=&\: \\
  x &\rightarrow x \\
  \lambda x.x &\rightarrow \lambda x.(reduction forte \:x) \\
  (x \:y) &\rightarrow ((reduction forte \:x) (reduction forte \:y)) \\
\end{align*}

La traduction de nos termes bidirectionnels vers les termes non typés
est transparente, il suffit d'effacer les annotations de type.

\begin{example}
  Faire un exemple ou avec l'ancien cela ne marchait pas et maintenant ça marche
\end{example}

\subsection{Extensions} 

Dans notre précédent language nous avions introduit les booléens ainsi que les entiers,
nous verrons ici la façon de les représenters ainsi que leurs règles de typage.
Nous introduirons aussi un nouveau type, le produit cartésien.

\subsubsection{Les entiers}

Commençons cette fois ci par les entiers étant donné que le type \emph{Nat}
est déja présent dans notre language.
Les constructeurs sont les memes que dans le \(\lambda\) calcul non typé 
cependant maintenant que nous disposons de termes bi directionnel il est important
de préciser où les placer.

%alors la il me faut une justification peut etre plus précise car j'en vois une pour les types dépendants mais pas pour ici
%Pour les types dépendants je dirais que ceux dans les exTm c'est parceque on veut pouvoir avoir de la dépendance
%sur eux mais je sais pas si ici je peux en parler
\emph{Succ} et \emph{Zero} sont des \emph{inTermes} étant donné que l'on peut determiner leur 
type sans le synthétiser contrairement à \emph{Iter}.
Les règles d'évaluations restent inchangés depuis la précédente spécification.
Regardons maintenant les règles de typage de ces différents constructeurs:
\begin{align*}
  &\cfrac{\:}
  {\Gamma\vdash Nat \ni \mathrm{Zero}}&\mbox{(Zero)} \\
  &\cfrac{\Gamma\vdash Nat \ni t}
  {\Gamma\vdash Nat \ni \mathrm{Succ(t)}}&\mbox{(Succ)} \\
  &\cfrac{\Gamma\vdash Nat \ni n \:\: \Gamma\vdash a \in A \:\: \Gamma\vdash A\rightarrow A \ni f}
  {\Gamma\vdash \mathrm{iter}\: n\: f\: a \in A}&\mbox{(Iter)} \\
\end{align*}


\subsubsection{Les booléens}

Afin de pouvoir typer nos termes il nous faut introduire le type \emph{Bool}.


En suivant la meme demarche que  pour les entiers les 
constructeurs \emph{True} et \emph{False} sont désormais des \emph{inTermes}
et le constructeur \emph{Ifte} un \emph{exTerme}



Nous pouvons désormais typer nos booléens de la manière suivante:
\begin{align*}
  &\cfrac{}
  {\Gamma\vdash Bool \ni true}&\mbox{(True)} \\
  &\cfrac{}
  {\Gamma\vdash Bool \ni false}&\mbox{(False)} \\
  &\cfrac{\Gamma\vdash Bool \ni c \:\: \Gamma\vdash t \in C \:\: \Gamma\vdash e \in C}
  {\Gamma\vdash \mathrm{ifte}\: c\: t\: e\in C}&\mbox{(Ifte)}
\end{align*}

On constate ici un exemple d'utilisation concrète des types. En effet 
précédement avant evaluation de l'ensemble du terme nous ne pouvions 
pas savoir si le terme \emph{c} était \emph{True} ou \emph{False}.
Désormais nous avons la certitude avant execution que ce terme retourne 
le terme correspondant à la branche \emph{then} ou \emph{else}

\subsubsection{Le produit cartésien}
\label{produit_cartesien}

Le produit cartésien est un objet mathématique qui est définit comme
un ensemble composé de deux éléments.
Cela nous permettra de crée des collections d'éléments. 
Pour ce faire nous allons implémenter un nouveau constructeur:
les \emph{paires} sous la forme \emph{($a\,b$)}
Nous allons aussi rajouter deux éliminateurs, les projections:
\emph{$\pi 0$} qui appliqué à une paire 
permet de retourner son premier élément ainsi que \emph{$\pi 1$} pour le second élément.
Nous ne disposons actuellement pas d'un type permettant de caractériser nos \emph{paires},
introduisons donc ce le type \emph{produit} de la forme \emph{($a\times b$)}.

Nous allons maintenant évaluer nos termes, 


Règle de typages des paires:
\begin{align*}
  &\cfrac{\Gamma\vdash A\ni a \:\: \Gamma\vdash B\ni b}
  {\Gamma\vdash A\times B \ni a,b}&\mbox{(Paire)} \\
  &\cfrac{\Gamma\vdash p \in (A\times B)} 
  {\Gamma\vdash p.\pi 0 \in A}&\mbox{($\pi 0$)} \\
  &\cfrac{\Gamma\vdash p \in (A\times B)} 
  {\Gamma\vdash p.\pi 1 \in B}&\mbox{($\pi 1$)} \\
\end{align*}

%on peut parler du fait que de faire des paires de paires c'est long a checker c'est mieux de faire des vecteurs pour ça?

\subsection{Implémentation}

Voici donc une implémentation du $\lambda$-calcule simplement typé.

\subsubsection{Représentation des termes et des types}

Comme nous précédement nous allons nous contenter de 
de présenter l'implémentation du noyau de notre language, nous introduirons 
les différents extensions dans les sections suivantes.
Commençons tout d'abord par donné la représentation des \emph{inTermes}
ainsi que celle des \emph{exTermes}

\codefrom{typed}{lambda}{inTm}
\codefrom{typed}{lambda}{exTm}

De la meme façon que nous avons représenté nos termes voici la 
représentation de nos types 

\codefrom{typed}{lambda}{Type}


\subsubsection{Type checker}

Le point centrale de cette nouvelle implémentation est le type-checker, 
il sera ici question de l'implémentation des règles bi-directionnelles.
Il nous faut donc traduire nos règles \ref{regles typage bidirectionnel} 
de façon algorithmique. 

La fonction gensym utilisée ici permet de crée un nom de variable assurant que celui n'a encore jamais
été utilisé. 

\label{check}
\codefrom{typed}{lambda}{check}
\codefrom{typed}{lambda}{synth}

Pour cette implémentation nous avons choisis générer des exeptions lorsque le terme
n'était pas correctement typé. Cela permet de terminer le programme directement car de toute
façon le terme serait refusé. Nous reviendrons cependant sur certains points négatifs de cette
méthode dans l'implémentation des types dépendants.

Nous disposons d'une fonction de vérification \emph{Check} ayant pour 
paramètres: un contexte qui est une liste de paires de la forme \emph{(var,type)},
un \emph{inTerme} ainsi qu'un type. Elle retourne un booléens permettant de déterminer
si le terme est correctement typé.
La fonction de synthèse \emph{synth} prend un contexte et un \emph{exTerme} 
et renvoi le type de celui ci.

Pour la vérification de l'abstraction on vérifie si le type en entrée est bien une flèche,
si c'est le cas il nous faut appelé recursivement notre fonction afin de vérifier le terme
sous le $\lambda$. Pour effectuer cet appel il nous faut libérer les variables liées à ce 
$lambda$ à l'aide de la substitution et de l'insérer avec son type dans le contexte.

Pour l'inversion on synthétise un type et on le compare à celui en entrée.
Pour l'instant les types sont statiques %peut etre changer le mot 
et ils ne possèdent pas de variables. Cela nous permet donc d'utiliser la fonction 
d'égalité d'Ocaml. 

Analysons maintenant les règles de synthèses, et commençons par les variables.
Etant donné que nous libérons l'ensemble des variables liées par les $\lambda$ 
si le type-checker en rencontre une le terme est immédiatement refuser.
Pour les variables libres la fonction retourne son type en parcourant le contexte
à l'aide de la méthode \emph{assoc} du module \emph{List}.
Nous n'avons plus réellement de choix d'implémentation à commenter, le reste est 
une simple traduction de nos règles \ref{regles typage bidirectionnel}.


\subsubsection{Réduction forte à petits pas}
\label{reduction_petits_pas}


Nous allons donc implémenté une fonction de réduction 
On appelle cette implémentation de réduction ``à petits pas'' car 
on effectue les réductions étapes par étape. Cela se raproche fortement 
de l'implémentation que nous avons donné de la réduction dans le $\lambda$-calcul
non typé du point de vue de l'implémentation.

Les termes préfixés d'un \emph{S} sont équivalents aux $\lambda$-termes 
du $\lambda$-calcul non typé, l'annotation n'est donc plus présente.

\codefrom{typed}{lambda}{reduction_forte}

Pour l'application \emph{SAppl} si le terme est une \emph{SAbs} on 
effectue la substitution puis l'on évalue le terme obtenu.
Sinon on évalue d'abord celui ci, si l'on obtient une \emph{SAbs} 
on appel la réduction sur l'application de celui ci au terme de droite
sinon il ne nous reste plus qu'à évaluer le terme de droite.

Lorsque l'on réduit sous une \emph{SAbs} il nous faut d'abord libérer l'ensemble des
variables qui lui sont liées. Il nous faut les reliers une fois la réduction terminé 
nous avons donc implémenter une fonction pour effectuer cette opération RELIE LIBRE. %a changer
Elle prend en argument le nom de la variable libre, la valeur de son indice de de Bruijn 
et le terme. Son code est assez triviale nous ne le présenterons donc pas ici.

Les autres règles ne nécéssitent pas de commentaires particuliers.

\subsubsection{Réduction forte à grands pas}

Nous allons maintenant implémenté une nouvelle réduction. 
Comme nous l'avons vu dans la section \ref{reduction_forte} %peut etre dans la partie safety je ne me souviens plus a voir 
la réduction forte aboutie forcément à une forme normale, les termes que nous obtenons
sont donc les memes qu'avec la réduction précédente \ref{reduction_petits_pas}. Nous allons donc implémenter 
d'une nouvelle façon cette réduction. Le but de cette implémentation est d'exploiter 
les ressources mises à dispositions par les languages de programmation fonctionnelle.
Elle a aussi pour effet d'évaluer complètement les termes, on peut le constater du fait %a changer
que les fonctions prenenent des \emph{inTermes} ou des \emph{exTermes} en entrée et retourne des valeurs.
Les valeurs ne sont plus réinterprétées par la suite.

On utilise la flèche \(\Downarrow\) pour signifie que l'on evalue complètement 
les termes. Nous n'obtenons plus de \emph{inTermes} ni de \emph{exTermes} mais
des valeurs et des termes neutres.
\begin{align*}
  v &::= &\mbox{Valeurs} \\
  &| \lambda x \rightarrow v &\mbox{Abstraction} \\
  &| n &\mbox{terme neutre} \\
  n &::= &\mbox{Neutres} \\
  &|x &\mbox{Variable} \\
  &|n v &\mbox{Application} \\
\end{align*}
Ici la représentation de l'abstraction sous la forme \(\lambda x\rightarrow v\)
est lié au fait qu'une abstraction avec ces termes est une fonction.
Voici donc le code correspondant en Ocaml:

\codefrom{typed}{lambda}{value}
\codefrom{typed}{lambda}{neutral}

La value \emph{VLam} est bien représenté par une fonction Ocaml
Pour ce qui est de l'évaluation les règles formelles sont les memes que pour 
la réduction à petit pas. 
Commençons par donner le code de celle ci, nous le commenterons après.


\codefrom{typed}{lambda}{big_step_eval_exTm}
\codefrom{typed}{lambda}{vapp}
\codefrom{typed}{lambda}{big_step_eval_inTm}



La règle de l'annotation \emph{Ann} ne nécéssite pas d'explications particulières car
elle est conforme à la spécification. 
L'évaluation de l'abstraction \emph{Abs} se traduit par la création d'une \emph{VLam}
dont le corps est une fonction anonyme. 

%revoir ce paragraphe.
Cette représentation nous permet de reconsidérer la façon de voir la 
réduction d'une \emph{Abstraction}. En effet lorsque l'on applique une \emph{Abstraction}
à un terme nous avions introduit la substitution, qui consiste à remplacer les occurences 
des variables liée à ce terme. La transformation d'une \emph{Abstraction} consiste donc à 
crée une fonction anonyme puis à évaluer le terme contenue dans celle ci en ajoutant dans le 
contexte la variable liée à cette fonction. Lors de l'évaluation d'une variable liée, on va
retrouver dans le contexte l'argument correspondant. On aura donc bien le comportement attendu
lors de l'application de cette fonction anonyme, car cela va remplacer les occurences de la 
variable.

\begin{example}
  Soit le terme \(\App{\Lam{x}{\Var{x}}}{u}\), avec la méthode d'évaluation à petit pas,
  on évalue en effectuant $\subst{x}{x}{u}$ ce qui nous donne comme résultat
  \emph{u}. 
  Avec l'évaluation à grands pas on évalue le terme $\Lam{x}{x}$ en 
  \emph{function arg $\rightarrow$ arg} ce qui appliqué à \emph{u} nous renvoi bien celui ci.
\end{example}

Pour l'application nous faisons appelle à une fonction vapp. Dans le cas ou l'on atch une 
\emph{VLam} on applique directement la fonction, sinon on crée un \emph{NApp} contenant les 
deux arguments. 

La fonction \emph{VFree} permet simplement à partir d'un nom de crée une \emph{NFree}
à l'intérieure d'un \emph{VNeutral}.
Elle permet simplement d'alléger le code de la fonction.

\codefrom{typed}{lambda}{vfree}


Une fois nos termes normalisés il nous faut maintenant un moyen de repasser nos termes
dans la représentation classique. Il nous faut donc implémenter cette fonction permettant de 
faire cette association, voici son code:

\codefrom{typed}{lambda}{value_to_inTm}
\codefrom{typed}{lambda}{neutral_to_exTm}

Afin de transformer une value \emph{VLam} en \emph{Abs} il nous faut 
appliquer la fonction \emph{f} à une variable libre. Ici il y a un choix d'implémentation 
au niveau de la valeur de cette variable, on met une valeur négative ce qui va nous permettre
par la suite de les reconaitres lors de l'évaluation des variables libres. Ainsi nous pourrons les
transformer en variables liées et non libre avec le bon indice de de Bruijn.

\subsubsection{Produit cartésien}

Nous allons maintenant implémenté le produit cartésien afin d'enrichire notre 
language. Tout d'abord comme nous l'avons vu dans la section \ref{produit_cartesien}
il nous faut introduire trois nouveaux termes ainsi qu'un nouveau constructeurs de type.
\emph{Type}
\codefrom{typed}{lambda}{type_pair}
\emph{inTermes}
\codefrom{typed}{lambda}{inTm_pair}
\emph{exTermes}
\codefrom{typed}{lambda}{exTm_pair}
\emph{value}
\codefrom{typed}{lambda}{value_pair}

Il nous faut maintenant implémenter les règles de typage au sein de notre algotithme:

\emph{check}
\codefrom{typed}{lambda}{check_pair}
\emph{synth}
\codefrom{typed}{lambda}{synth_pair}

Rien à commenter,





%% Voici donc les règles d'évaluations:
%% \begin{align*}
%%   &\cfrac{t \Downarrow t'}
%%   {t:T \Downarrow t'}&\mbox{(Ann)}&\: \\
%%   &\cfrac{}
%%   {x \Downarrow x}&\mbox{Var} \\
%%   &\cfrac{t \Downarrow \: \lambda x.v \:\: \subst{v}{x}{t'}\Downarrow v'}
%%   {t\:t'\Downarrow \: v'}&\mbox{Appl redex} \\
%%   &\cfrac{t \Downarrow \: n \:\: v \Downarrow v'}
%%   {t\:t'\Downarrow \: n \: v'}&\mbox{Appl} \\
%%   &\cfrac{e \Downarrow \: v}
%%   {\lambda x.t \Downarrow \: \lambda x.v}&\mbox{Abs}
%% \end{align*}












%on veut maintenant montrer celle ou on transforme en mode normale et après mettre la big_step


\section{Les types dépendants}

% pour l'implémentation quand je parle du parser ne pas montrer le code 
% mais expliquer la syntaxe lisp

% pour la prochaine introduction d'implémentation dire que la grosse nouveauté
% c'est le type checker et le fait que on 


%pour le simplement typé quand on introduit la première réduction on peut faire l'analogie avec le compilateur qui une fois que les
%termes on été type checker on peut maintenant oublier les types et maintenant réduire 



%Il faudrait que pour les booléens et tout ce genre de choses je fasse dans la partie formelle des spec correspondants aux evaluations ect..


%partie pour quand l'inspiration est partie

%pour introduire la fonctin d'égalité dans le type checker des types dépendants il faut dire que avant on pouvait comparer nos types directements avec la fonction d'égalité de ocaml car il n'y avait pas de variables dans nos types alors que maintenant oui

%Dans les types dépendants on pourra dire que l'on considère que nos termes sont des programmes 

%% * Outro

\clearpage

\bibliographystyle{abbrvnat}
\bibliography{prerapport.bib,rapport.bib}  

\end{document}

