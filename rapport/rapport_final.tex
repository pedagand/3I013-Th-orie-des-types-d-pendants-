\documentclass {article}

%% ** Packages

\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsthm, amssymb, amsmath}
\usepackage{hyperref}
\usepackage{mathpartir}

%% ** OCaml listings

\usepackage{xcolor}
\usepackage{listings}
\lstset{
  language=[Objective]Caml,
  %% emph={[2]Nil,Cons,FZe,FSu,ze,su,Ze,Su},
  %% emphstyle={[2]\Constructor},
  %% emph={[3]lookup,failwith},
  %% emphstyle={[3]\Function},
  %% emph={[4]vec,fin,nat,list,tree,completeTree},
  %% emphstyle={[4]\Canonical},
  morecomment=[s]{(*}{*)},
  rangeprefix=\(\*\=,
  rangesuffix=\ \*\),
  includerangemarker=false,
  extendedchars=\true,
  inputencoding=utf8,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  basicstyle=\ttfamily\small,
  framesep=4mm,
  moredelim=*[s][\itshape]{(*}{*)},
  moredelim=[is][\textcolor{darkgray}]{§}{§},
  escapechar=°,
  keywordstyle=\color[rgb]{0.627451, 0.125490, 0.941176},
  stringstyle=\color[rgb]{0.545098, 0.278431, 0.364706},
  commentstyle=\color[rgb]{0.698039, 0.133333, 0.133333},
  numberstyle=\color[rgb]{0.372549, 0.619608, 0.627451},
  boxpos=t,
  literate= {'a}{{$\alpha$}}1%
    {->}{{${\to}$}}2
    {*}{{${\times}$}}1
    {::}{{${:\::}$}}1
}

\newcommand{\codefrom}[3]
           {\lstinputlisting[linerange={#3}-End]{../#1/#2.ml}}


%% ** Theorem styles 


\newtheorem{theorem}{Théorème}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemme}

\theoremstyle{definition}
\newtheorem{definition}{Définition}
\newtheorem{example}{Exemple}

\theoremstyle{remark}
\newtheorem{remark}{Remarque}
\newtheorem{para}{} 

%% ** commands

\newcommand{\todo}[1]{\textcolor{red}{#1}}
\newcommand{\attention}[1]{\textcolor{orange}{#1}}
\newcommand{\question}[1]{\textcolor{green}{#1}}
\newcommand{\etc}{\textit{etc.}}

\newenvironment{bnf}
               {\[\begin{array}{lcl@{\qquad}r}}
               {\end{array}\]}

\newcommand{\fun}[1]{\lstinline!#1!}
%% ** Title

\title{Théorie des Types Dépendants\\Conception et Implémentation}
\author{Roman Delgado}
\date{}


\begin{document}

\maketitle


%% ** Abstract 

\todo{Mettre un coup de ispell}

\begin{abstract} 
  Ce document représente l'ensemble du travail effectué durant l'unité d'enseignement 3I013 de l'\textsc{upmc}. \todo{Cet abstract n'apporte pas grand chose : le supprimer ?}
\end{abstract}

\setcounter{tocdepth}{2}
\tableofcontents

\clearpage

%% ** Main

\section{Introduction}

\todo{a relire}

Un langage de compilation est entièrement défini par son compilateur. En effet ce logiciel permet de traduire
des programmes écrits dans un langage de haut niveau en instructions pour le processeur.

Il sera donc question dans ce rapport de comprendre le typage, une des étapes de la chaîne de compilation.
Pour résumer brièvement le compilateur 
traduit d'abord le texte écrit par le programmeur en un arbre de syntaxe abstraite. Cette représentation est ensuite utilisable
dans un algorithme.
Si le compilateur ne génère pas d'erreur durant cette étape, on dit que le programme est syntaxiquement correct. Cependant 
le programmeur à pu écrire des instructions telles que \lstinline!x = 2 + true!. Même si cette instruction est syntaxiquement correcte, celle-ci 
n'a aucun sens. Il lui faut maintenant à partir de l'arbre de syntaxe abstraite générer du code assembleur, un code compréhensible 
par les microprocesseurs. Le compilateur peut très bien générer une suite d'instructions assembleur correspondant à l'expression 
précédente. C'est durant l'exécution du programme que le processeur va interrompre le programme. Lorsque ces erreurs surviennent, il est 
très compliqué de trouver la source de celles-ci car l'instruction fautive ne correspond pas au code écrit par le programmeur. 
Pour éviter ce genre d'erreurs qui peuvent survenir très longtemps après le lancement du programme (les serveurs par exemple), 
il nous faut donc vérifier la validité de celui-ci. Il faut donc rajouter une étape dans la chaîne de compilation grâce au typage 
assuré par l'analyseur de type.
L'intérêt du typage est donc de vérifier que le programme s'exécutera correctement, sans avoir besoin d'exécuter celui-ci. 
Il permet aussi d'obtenir des informations très précises sur la source des erreurs.

\section{$\lambda$-calcul non typé}
\label{sec:untyped}

\todo{Il reste des ``lambda'' qui devraient être des $\lambda$.}

En 1936, Alonzo Church introduit le $\lambda$-calcul non typé
~\citep{church:lambda-calcul}. Le $\lambda$-calcul est
un modèle de calcul universel, tout comme les machines de Turing. Celui-ci repose
sur une syntaxe minimaliste capturant exactement la notion de fonction. Ce formalisme est au c\oe{}ur de nombreuses recherches dans le domaine de la 
programmation fonctionnelle. Le $\lambda$-calcul non typé a connu un formidable 
succès pratique, donnant lieu à de multiples variantes dont on trouvera une présentation
 moderne et synthétique dans l'ouvrage de ~\citet{pierce:tapl}.

\subsection{Syntaxe}
Le $\lambda$-calcul est composé uniquement de \(\lambda\)-termes dont voici la syntaxe

\newcommand{\Lam}[2]{\ensuremath{\lambda #1. #2}}
\newcommand{\App}[2]{\ensuremath{#1\:#2}}
\newcommand{\Var}[1]{\ensuremath{#1}}
\newcommand{\Fst}[1]{\ensuremath{#1.\pi_0}}
\newcommand{\Snd}[1]{\ensuremath{#1.\pi_1}}
\newcommand{\Pair}[2]{\ensuremath{(#1, #2)}}
\newcommand{\ifte}[4][]{\ensuremath{\mathsf{if}_{#1}\: #2\: \mathsf{then}\: #3\: \mathsf{else}\: #4}}
\newcommand{\true}{\ensuremath{\mathsf{true}}}
\newcommand{\false}{\ensuremath{\mathsf{false}}}
\newcommand{\zero}{\ensuremath{\mathsf{zero}}} 
\newcommand{\succs}{\ensuremath{\mathsf{succ}}}
\newcommand{\iter}{\ensuremath{\mathsf{iter}}}


\begin{bnf}
  t &::= & &\mbox{(lambda terme)} \\
  &|& \Var{x} & \mbox{(variable)} \\
  &|& \Lam{x}{t} & \mbox{(abstraction)} \\
  &|& \App{t}{t}          & \mbox{(application)}
\end{bnf}

Pour faire une analogie avec les mathématiques, une abstraction peut
être vue comme une définition de fonction anonyme.
 
\begin{example}
 La fonction identité est définie par le $lambda$-terme suivant : $\Lam{x}{\Var{x}}$
\end{example}

On peut constater avec cette syntaxe que les abstractions ne prennent
qu'un seul argument. Cependant, l'ensemble des fonctions à plusieurs
arguments peut être représenté, par curryfication, à l'aide d'une
succession de fonctions à un seul argument.

\begin{example}
  \label{example:id}
  La fonction \Lam{\Pair{x}{y}}{t}, qui a deux arguments \Var{x} et \Var{y},
  correspond au $\lambda$-terme $\Lam{x}{\Lam{y}{t}}$
\end{example} 


\subsubsection{Variables libres et variables liées}

\newcommand{\IsFree}{\mathrm{isFree}}


Une variable est \emph{liée} lorsque celle-ci est déclarée dans le corps d'un
lambda. Dans l'Exemple~\ref{example:id}, $x$ était ainsi une variable liée.
Si la variable n'a pas été déclarée, elle est dite
\emph{libre}. Formellement, l'ensemble des variables libres d'un terme est
défini récursivement de la façon suivante:
%
\begin{align*}
  \IsFree(x) &\triangleq \{x\} \\
  \IsFree(\lambda x. t) &\triangleq \IsFree(t) \backslash \{x\} \\
  \IsFree(f s) &\triangleq \IsFree(f) \cup \IsFree(s) \\
\end{align*}

Comme les abstractions lient les variables, elles sont communéments appelées \emph{lieurs}.

\begin{example}
  Dans le terme \(\Lam{x}{\Lam{y}{\App{\App{\Var{x}}{\Var{y}}}{\Var{z}}}}\),
  les variables $\Var{x}$ et $\Var{y}$ sont liées tandis que la variable $\Var{z}$ est libre .
\end{example}


Un terme ne contenant aucune occurrence de variable \emph{libre} est dit \emph{clos}.

\begin{example}  
  \label{example:ouvert-clos}  
  Dans le $\lambda$-terme
  \App{(\Lam{x}{\Lam{y}{\App{x}{y}}})}{\Var{y}}, la variable \Var{x}
  ainsi que la première occurence de la variable \Var{y} sont
  liées. Cependant la seconde occurence de variable \Var{y} est
  libre.
\end{example}


\subsubsection{$\alpha$-équivalence}
\label{alpha_equiv}
\label{problemelibreliee}

\newcommand{\equivAlpha}{\mathop{\equiv_\alpha}}

Le problème avec cette représentation est que les termes
\Lam{\Var{x}}{\Var{x}} et \Lam{\Var{y}}{\Var{y}} sont \textit{à
  priori} distincts du fait des noms de variable utilisés. Or cette
distinction n'est pas souhaitable : ces deux termes représentent de
façon équivalente la fonction identité, indépendamment du choix de nom
de variable. Nous introduisons donc la notion d'$\alpha$-équivalence.

On considère que deux termes sont \(\alpha\)-équivalents si et seulement si ils sont 
égaux au renommage de leurs variables liées près. 
\begin{example}
  Voici deux termes \(\alpha\)-équivalents 
  \begin{align*}
    & \Lam{x}{\Var{x}} \equivAlpha \Lam{y}{\Var{y}} \\
  \end{align*}
\end{example}

\subsubsection{Représentation concrète}
 
Pour pallier à la remarque~\ref{problemelibreliee}, notre implémentation utilise une représentation
particulière pour les variables liées: les indices de De Bruijn.  Nous
allons ainsi représenter les variables liées non pas par un nom mais
par un entier naturel. Cette valeur est déterminée à partir du nombre
d'abstractions entre la variable et le lieur qui l'introduit.

\begin{example}
  Le $\lambda$-terme représentant l'identité, que l'on écrivait \(\lambda x.x\), est représenté par \(\lambda.0\)
  et le terme $\Lam{x}{\Lam{y}{x}}$ est représenté par $\lambda.\lambda.1$ 
\end{example}

Tandis que les variables liées seront representées par des
indices de De Bruijn, les variables libres quant à elle seront
représentées par un (unique) nom de variable, comme dans la
présentation formelle. Une telle représentation est traditionnellement
appelée ``locally nameless''~\citep{chargueraud:locally-nameless}

\begin{example} 
  
  Soit \Var{x} une variable libre. 
  En théorie : 
  \(\Lam{x}{\App{(\Lam{\Var{y}}{\Lam{z}{\Var{y}}})}{\Var{x}}} \leadsto \Lam{x}{\Lam{z}{\Var{x}}}\)

  En pratique avec les indices de De Bruijn : $\Lam{}{\App{(\Lam{}{\Lam{}{1}})}{0}} \leadsto \Lam{}{\Lam{}{0}}$

  Ici on constate bien que le terme obtenu n'est pas correct. Il nous faut introduire une opération
  intermédiaire afin de remédier à ce problème.
  Cette opération est appelée par Pierce les ``shifts''
  
  \todo{Mettre à jour cet exemple}
  En pratique avec du locally nameless : $\App{(\Lam{}{0})}{\Var{x}}\leadsto \Var{x}$

  Il n'est plus nécessaire d'effectuer des ``shifts'', cette représentation
  possède les avantages de la représentation avec les indices de De Bruijn et
  s'affranchit du problème de la valeur des variables libres.
  
\end{example}

Voici le code Ocaml traduisant cette définition inductive des termes :
%
\codefrom{untyped}{lambda}{untyped_term}

Cette représentation se rapproche au plus de la spécification formelle
: seule la distinction entre les variables liées (\lstinline!BoundVar!)
et les variables libres (\lstinline!FreeVar!) diffère.



  
\subsection{Calculer dans le lambda calcul}
\label{calculer_dans_le_lambda_calcul}

Dans le lambda calcul pur, il n'existe pas d'opérations primitives, comme l'addition ou la multiplication d'entiers par exemple. Le seul moyen de calculer de nouveaux termes est de les appliquer 
entre eux. Mais il nous faut tout d'abord définir le mécanisme de substitution par lequel se réalise la notion de calcul.

\subsubsection{Substitution}

\newcommand{\subst}[3]{#1[#2 := #3]}


La substitution est un mécanisme central dans le lambda calcul. Cela consiste 
à remplacer l'occurrence d'une variable liée par un \(\lambda\)-terme.
On note \(\subst{t}{x}{u}\) la substitution de la variable $\Var{x}$ dans le terme $\Var{t}$ par le 
terme u.

Formellement, la substitution est définie par récursion sur le $\lambda$-terme : 
\begin{align*}
    \subst{x}{x}{u} &\triangleq u \\
    \subst{x}{y}{u} &\triangleq x & (x \neq y)\\
    \subst{\lambda x.t}{x}{u} &\triangleq \lambda x.t \\
    \subst{\lambda y.t}{x}{u} &\triangleq \lambda y. (\subst{t}{x}{u}) & (x \neq y)\\
    \subst{(t\: v)}{x}{u} &\triangleq \subst{t}{x}{u}\: \subst{v}{x}{u}
\end{align*}

\begin{example}
  Considérons le terme $\subst{(\Lam{z}{x})}{x}{\Lam{y}{y}}$. Après substitution, nous obtenons le terme $\Lam{z}{\Lam{y}{\Var{y}}}$.
\end{example}


\paragraph{Implémentation :} 
La substitution de la variable liée \lstinline!var! par le terme
\lstinline!tsub! dans \lstinline!term! est implémentée par la fonction suivante:
%
\codefrom{untyped}{lambda}{substitution}

L'argument \fun{var} compte le nombre de \emph{lieurs} traversés.
Cette valeur correspond donc à la valeur de la variable liée à substituer. C'est pour cette
raison que dans le cas où \fun{terme} est une variable liée d'indice \fun{x} on teste l'égalité entre 
\fun{var} et \fun{x}. Le cas échéant, on effectue la substitution.


\begin{example}
  Soit le terme t = \Lam{y}{\App{x}{y}} où \Var{x} est liée à
  l'abstraction la plus proche (indice 0).

  En OCaml, ce terme est représenté par 
  %
  \begin{lstlisting}
    Abs ("y", Appl (BoundVar 1, BoundVar 0))
  \end{lstlisting}

  Voici le déroulement de l'appel à la fonction de substitution sur \Var{x} :
  \begin{lstlisting}
      substitution t 0 (FreeVar "z")
  ->  substitution (Abs ("y", Appl (BoundVar 1, BoundVar 0))) 0 (FreeVar "z")
  ->  Abs("y", substitution (Appl (BoundVar 1,BoundVar 0)) 1 (FreeVar "z"))
  ->  Abs("y", Appl(substitution (BoundVar 1) 1 (FreeVar "z"), 
                    substitution (BoundVar 0) 1 (FreeVar "z")))
  ->  Abs("y", Appl(FreeVar "z", 
                    substitution (BoundVar 0) 1 (FreeVar "z")))
  ->  Abs("y", Appl(FreeVar "z", BoundVar 0))
  \end{lstlisting}

  Nous obtenons donc le terme attendu, soit \Lam{\Var{y}}{\App{\Var{z}}{\Var{y}}}.
\end{example}

\subsubsection{$\beta$-réduction}
\label{reduction}


Seules les applications de la forme \(\App{(\Lam{\Var{x}}{t})}{u}\),
dont le membre de gauche est une abstraction, peuvent être réduites :
un tel terme s'appelle un
\emph{redex}~\citep{krivine:lambda-calculus}. Le terme
\(\subst{t}{x}{u}\), obtenu après réduction, est appelé son
\emph{contracté}.

\begin{example}
  Le terme \(\App{(\Lam{x}{x})}{u}\) est  un redex tandis que le terme
  \(\App{x}{u}\) n'en est pas un.
\end{example}

\newcommand{\Red}{\leadsto}
\newcommand{\Conv}{\leadsto^{*}}

Formellement, on définit la \(\beta\)-réduction par induction sur les
termes :
\[\begin{array}{c}
  \inferrule{{}}
            {\App{(\Lam{\Var{x}}{t})}{u} \Red \subst{t}{x}{u}}
  \medskip\\
  \inferrule{t \Red t'}%
            {\Lam{\Var{x}}{t} \Red \Lam{\Var{x}}{t'}}
  \medskip\\
  \inferrule{t \Red t'}
            {\App{t}{u} \Red \App{t'}{u}}
  \medskip\\
  \inferrule{u \Red u'}
            {\App{t}{u} \Red \App{t}{u'}}
\end{array}\]

On obtient la \(\beta\)-conversion en prenant la clôture réflexive et
transitive \(t \Conv t'\) de la \(\beta\)-réduction : on a \(t \Conv
t'\) s'il existe une suite de \(\beta\)-réductions telles que \(t \Red
\ldots \Red t'\).

\begin{example}
  Soit le terme \(\App{(\Lam{x}{\Lam{y}{\App{y}{x}}})}{z}\).  Ce terme
  contient un redex : il est composé d'une application ayant une
  abstraction comme membre de gauche. La réduction consiste à
  substituer la variable liée dans la première abstraction par le
  membre droit de l'application. Son contracté est
  \(\Lam{y}{\App{y}{z}}\)
\end{example}

\begin{example}
  Voici un autre exemple de réduction
  \begin{align*}
    & \App{(\Lam{x}{\Lam{y}{y}})}{w} \leadsto \Lam{y}{y} \\
  \end{align*}
  \Var{x} n'étant pas utilisée dans la fonction, l'argument \Var{w} disparaît complètement.
\end{example}


\subsubsection{Stratégie de réduction : appel par nom}

\label{reduction:call_by_name}
Un terme est dit en \emph{forme
  normale} si on ne peut plus lui
appliquer de réduction: il ne contient aucun redex. La \emph{normalisation}
consiste à reduire autant que possible notre terme. En
particulier, on caractérise inductivement les formes normales de la
façon suivante :
%
\begin{itemize}
\item Une variable \(\Var{x}\) est en forme normale ;
\item Si \(t\) est en forme normale, alors \(\Lam{\Var{x}}{t}\) est en
  forme normale ;
\item Si \(t\) et \(u\) sont en forme normale et que \(u\) n'est pas
  une abstraction, alors \(\App{t}{u}\) est en forme normale.
\end{itemize}

On en déduit qu'un terme est en forme normale si et seulement s'il est
de la forme
\(\Lam{\Var{x_0}}\ldots\Lam{\Var{x_k}}\App{\App{\App{x_i}{t_0}}{\ldots}}{t_l}\)
où les \(t_j\) sont eux-mêmes des termes normaux.

\begin{example}[Terme en forme normale]
  \(\Lam{\Var{x}}{\Var{x}}\)
\end{example}

On dira qu'un terme \(t\) est \emph{normalisable} s'il existe un terme
normal \(t'\) tel que \(t \Conv t'\). Un terme \(t\) est
\emph{fortement normalisable} s'il n'existe aucune suite infinie de
réduction à partir de \(t\). Un terme fortement normalisable est,
\textit{à fortiori}, un terme normalisable.

\begin{example}
 \label{paradoxe}
  Le terme suivant n'admet pas de forme normale :
  %
  \begin{align*}
    \omega &\triangleq (\lambda x. x\: x) (\lambda x. x\: x) \\
           &\leadsto (x x)[x \mapsto \lambda x. x\: x] \\
           &\leadsto (\lambda x. x\: x) (\lambda x. x\: x) \\
           &\leadsto \ldots \\
  \end{align*}
\end{example}

\begin{example}[Terme normalisable mais pas fortement normalisable]
  \(\App{(\Lam{\Var{x}}{0})}{\omega}\)
\end{example}

Un terme normalisable (mais pas \emph{fortement} normalisable) pourra
donc diverger ou retourner une forme normale selon les réductions
effectuées lors de la conversion : l'ordre dans lequel sont effectuées
ces réductions est donc important. Nous considérons ici une
\emph{stratégie} de réduction qui, pour tout terme normalisable, est assurée d'obtenir une forme
normale : il s'agit de la réduction en
\emph{appel par nom}.

On remarque tout d'abord que tout terme \(t\) du \(\lambda\)-calcul
s'écrit sous la forme
%
\[
\Lam{\Var{x_0}}\Lam{\Var{x_m}}\App{\App{\App{k}{t_0}}{\ldots}}{t_n}
\]
%
où \(k\) est soit une variable soit un redex (le \emph{redex de tête})
tandis que les \(t_i\) sont des termes quelconques (et donc eux-même
de cette forme).


Un terme est en \emph{forme normale de tête} lorsque \(k\) est
nécessairement une variable : le redex le plus à gauche du terme est
``bloqué'' sur une variable et ne peut donc réduire.

La stratégie d'\emph{appel par nom} consiste à contracter
successivement le redex de tête (et uniquement ce redex). 

\newcommand{\CBN}{\mathop{\leadsto_N}}

\[\begin{array}{c}
\inferrule{{}}
          {\App{(\Lam{\Var{x}}{t})}{u} \CBN \subst{t}{x}{u}}
          \medskip\\
          \inferrule{t \CBN t'}
                    {\App{t}{u} \CBN \App{t'}{u}}
                    \medskip\\
                    \inferrule{{}}
                              {\Lam{x}{t}\Red \Lam{x}{t}}
                              \medskip\\
                              \inferrule{{}}
                                        {x\Red x}
                                        
\end{array}\]



Crucialement, nous avons la propriété suivante~\citep[th.3,
  p.62]{krivine:lambda-calculus} :
%
\begin{proposition}
  Un terme \(t\) normalise vers une forme normale de tête si et
  seulement si la stratégie d'appel par nom termine (donnant un terme en
  forme normale de tête).
\end{proposition}


Il existe d'autres stratégies de réduction comme par exemple
\emph{l'appel par valeur}, qu'implémente OCaml. Bien que plus
efficace, l'appel par valeur diverge pour certains termes normalisant.
Dans le contexte du \(\lambda\)-calcul non typé, où les termes ne sont
pas tous fortement normalisables, on privilégiera la réduction en appel
par nom.

\begin{example}
  \begin{align*}
    (\App{(\App{(\Lam{x}{\Var{x}})}{(\Lam{y}{y})})}{\Var{z}}) & \leadsto (\App{(\Lam{y}{\Var{y}})}{\Var{z}}) \\    
    & \leadsto \Var{z}
  \end{align*}
  Ici \Var{z} n'est plus réductible, c'est donc la forme normale du terme.
\end{example}


\begin{example}
  Voici une réduction en appel par nom:
  \begin{align*}
    & \App{(\Lam{x}{\Var{x}})}({\App{(\Lam{y}{\Var{y}})}({\Lam{z}{\App{(\Lam{x}{\Var{x}})}{\Var{z}}}}})) \\
    \rightarrow & \App{(\Lam{y}{\Var{y}})}({\Lam{z}{\App{(\Lam{x}{\Var{x}})}{\Var{z}}}})\\
    \rightarrow & \Lam{z}{\App{(\Lam{x}{\Var{x}})}{\Var{z}}}
  \end{align*}
  Le terme obtenu est en forme normale de tête.
\end{example}

Dans les sections suivantes, nous verrons lorsque nous introduirons
les systèmes de type que l'on peut statiquement garantir que les
termes acceptés par l'analyse de type sont fortement normalisants.

\begin{remark}
  Le fait d'obtenir la garantie que l'ensemble de nos termes sont fortement normalisants signifie que
  notre langage n'est plus \emph{Turing complet}. En effet nous ne pourrons plus exprimer les programmes
  qui ne terminent pas. Cependant ce n'est pas gênant car nous ne cherchons pas à écrire ce genre de
  programmes dans notre système.
\end{remark}




\paragraph{Implémentation :}
La fonction de $\beta$-réduction consiste donc à contracter une
application dont le membre de gauche est une abstraction. Le cas
échéant, l'opération échoue. Pour ce faire, nous appelons la fonction
de substitution pour substituer la première variable (d'indice \(0\))
par l'argument dans le corps de la fonction :
%
\codefrom{untyped}{lambda}{reduction}

Les seuls termes pouvant se réduire étant les redex, nous effectuons la substitution sur celle-ci,
sinon le terme est retourné sans modification.
Passons maintenant à l'évaluation:

\codefrom{untyped}{lambda}{evaluation}
\codefrom{untyped}{lambda}{evaluation_bis}

La fonction \fun{eval} à pour but de détecter les applications et d'en évaluer le membre de gauche.
Une fois le membre de gauche évalué, nous pouvons tenter de réduire l'ensemble de l'application.

\subsection{Encodages à la Church}

Bien que le $\lambda$-calcul soit un langage minimaliste, ~\citet{church:lambda-calcul} a montré que l'on peut
y \emph{encoder} de nombreux types de données familiers aux développeurs, tels que
les entiers et les booléens.


\subsubsection{Les booléens de Church}
\label{church-bool}

\newcommand{\True}{\ensuremath{\mathit{true}}}
\newcommand{\False}{\ensuremath{\mathit{false}}}
\newcommand{\Ifte}{\ensuremath{\mathit{ifte}}}

Nous allons voir une représentation des booléens accompagnée de la 
structure de contrôle \texttt{if ... then ... else ...}.
Voici les termes correspondants aux constructeurs \True{}, \False{} et 
\Ifte{} :
\begin{align*}
  \True &\triangleq  \Lam{x}{\Lam{y}{\Var{y}}} \\
  \False &\triangleq \Lam{x}{\Lam{y}{\Var{x}}} \\
  \Ifte &\triangleq \Lam{l}{\Lam{m}{\Lam{n}{\App{\Var{l}}{\App{\Var{m}}{\Var{n}}}}}}  \\
\end{align*}

On assimile ces deux termes aux booléens \True{} et \False{} car leur calcul au sein
de l'application d'un \Ifte{} reproduit le comportement attendu.

\begin{example}
  Voici un exemple de réduction du terme \Ifte{} appliqué à la condition \False{} :
  \begin{align*}
    \App{\App{\App{\Ifte}{\False{}}}{\Var{v}}}{\Var{w}}  \triangleq&\: \App{\App{\App{(\Lam{l}{\Lam{m}{\Lam{n}{\App{\App{l}{m}}{n}}}}})({\Lam{x}{\Lam{y}{y}}}}){v}}{w} \\
    \rightarrow &\: \App{\App{({\Lam{m}{\Lam{n}{\App{\App({\Lam{x}{\Lam{y}{y}}}){m}}{n}}}}}){v}}{w} \\
    \rightarrow &\: \App{(\Lam{n}{\App{\App({\Lam{x}{\Lam{y}{y}}}){v}}{n}})}{w} \\
    \rightarrow &\: \App{\App({\Lam{x}{\Lam{y}{y}}}){v}}{w}) \\
    \rightarrow &\: \App({\Lam{y}{y}}){w}) \\
    \rightarrow &\: \Var{w}
  \end{align*}
\end{example}

Ici nous n'avons aucun moyen de vérifier avant normalisation que le
premier argument de \Ifte{} est effectivement un booléen : nous ne
pouvons donc pas garantir la bonne évaluation de notre terme.

\begin{remark}
  Les langages orientés objets permettent de représenter ce type d'encodage d'une manière particulière.
  Voici la représentation avec le langage Java:
  \begin{lstlisting}[language=java]
    Interface Bool<A>{
      A ifte(A x,A y);
    }
    
    class True<A> implements Bool<A>{
      A ifte(A x,A y){
        return x;
      }
    }
    class False<A> implements Bool<A>{
      A ifte(A x,A y){
        return y;
      }
    }    
  \end{lstlisting}
\end{remark}


\subsubsection{Les entiers de Church}

\newcommand{\Zero}{\mathit{zero}}
\newcommand{\Un}{\mathit{un}}
\newcommand{\Deux}{\mathit{deux}}
\newcommand{\Succ}{\mathit{successeur}}
\newcommand{\Plus}{\mathit{plus}}


Ici, nous allons voir comment créer les entiers naturels \textit{ex
  nihilo} en utilisant un encodage à la Church. L'idée consiste à
représenter le nombre \(n\) par une fonction d'ordre supérieur prenant
en argument une fonction \Var{f} et l'appliquant \(n\) fois à un
argument \Var{x}. On définira donc
%
\begin{align*}
\Zero &\triangleq \Lam{f}{\Lam{x}{x}}\\ 
\Un   &\triangleq \Lam{f}{\Lam{x}{\App{f}{x}}} \\
\Deux &\triangleq \Lam{f}{\Lam{x}{\App{f}{(\App{f}{x}})}}
\end{align*}

Afin de construire tous les entiers naturels, on s'inspire alors de la
définition des entiers de Peano et on définit le successeur d'un nombre \(n\)
comme
%
\[
\Succ \triangleq \Lam{n}{\Lam{f}{\Lam{x}{\App{\App{n}{f}}{(\App{f}{x})}}}}
\]
%
c'est-à-dire \(n\) applications de \(f\) précédées d'une première
application de \(f\), soit \(n+1\) applications.

De la même manière, on construit l'addition de deux nombres \(m\) et
\(n\) en faisant \(m\) applications répétées de \(f\) précédées par
\(n\) applications :
%
\[
\Plus \triangleq \Lam{m}{\Lam{n}{\Lam{f}{\Lam{x}{\App{\App{m}{f}}{(\App{\App{n}{f}}{x}})}}}}
\]


\subsection{Extensions}

Nous nous attardons ici sur quelques choix d'implémentation et il
sera question d'analyser certaines parties du code et non sa totalité.

\subsubsection{Les booléens}

\newcommand{\NTrue}{\lstinline!True!}
\newcommand{\NFalse}{\lstinline!False!}
\newcommand{\NIfte}{\lstinline!IfThenElse!}

Afin d'implémenter les boléens dans notre langage, une possibilité
consiste à exporter l'encodage à la Church des termes \True{},
\False{} et \Ifte{} définis en Section~\ref{church-bool}. Cependant
nous avons choisi d'enrichir le noyau de notre langage afin de
supporter, de façon primitive, les booléens. Cela permet d'alléger
l'écriture des termes mais surtout de faciliter la représentation et,
par la suite, la compilation des programmes manipulant des expressions
booléennes.


Nous allons donc étendre la grammaire de nos $\lambda$-termes
\begin{bnf}
  t &::= & (\ldots) &\mbox{(lambda terme)} \\
  &|& \true & \mbox{(true)} \\
  &|& \false & \mbox{(false)} \\
  &|& \ifte{t}{t}{t} & \mbox{(ifte)}
\end{bnf}
%
ainsi que notre implémentation
%
\begin{lstlisting}
type lambda_term = (...)
\end{lstlisting}
\vspace{-.7\baselineskip}
\codefrom{untyped}{lambda}{bool_term}

Pour la substitution des constructeurs \NTrue{} et \NFalse{}, les règles
sont triviales. Pour le terme \NIfte{}, il faut rappeler la fonction de
substitution sur l'ensemble des arguments du constructeur.  En
particulier, il n'est pas nécessaire d'incrémenter la valeur de
\lstinline!var! étant donné que ce constructeur ne lie aucune
variables.


La réduction est étendue au-delà de la \(\beta\)-réduction par une
relation de \(\iota\)-réduction, correspondant à la réduction du test
conditionnel \ifte{\ldots}{\ldots}{\ldots} face aux booléens \true{}
ou \false{} :
%
\[\begin{array}{c}
  \inferrule{{}}
            {\ifte{\true}{u}{v} \Red u}
  \qquad 
  \inferrule{{}}
            {\ifte{\false}{u}{v} \Red v}
  \medskip\\
  \inferrule{t \Red t'}
            {\ifte{t}{u}{v} \Red \ifte{t'}{u}{v} }
\end{array}\]


L'implémentation de cette réduction ne présente pas de difficulté
particulière :
\codefrom{untyped}{lambda}{iota_sig} \lstinline{(...)}
\codefrom{untyped}{lambda}{bool_evaluation}


\subsubsection{Les entiers}

\newcommand{\nat}{\ensuremath{\mathit{nat}}}
\newcommand{\NZero}{\lstinline!Zero!}
\newcommand{\NSucc}{\lstinline!Succ!}
\newcommand{\NIter}{\lstinline!Iter!}

Tout comme pour les booléens, il nous faut enrichir la grammaire
formelle du $\lambda$-calcul
%
\begin{bnf}
  t &::= & (\ldots) &\mbox{(lambda terme)} \\
  &|& \zero & \mbox{(zero)} \\
  &|& \succs\: t & \mbox{(succ)} \\
  &|& \iter\: t\:t\:t & \mbox{(iter)}
\end{bnf}
%
ainsi que sa réalisation dans l'implémentation
%
\begin{lstlisting}
type lambda_term = (...)
\end{lstlisting}
\vspace{-.7\baselineskip}
\codefrom{untyped}{lambda}{nat_term}

Ces trois constructeurs n'étant pas des lieurs, l'implémentation de la
substitution est triviale.

La \(\iota\)-réduction de l'itération se définit ainsi:
%
\[\begin{array}{c}
  \inferrule{{}}
            {\iter\:(\succs\:n)\:f\:a\Red \iter\:n\:f\:(\App{f}{a})}
  \qquad
  \inferrule{{}}
            {\iter\:\zero\:f\:a\Red a}
  \medskip\\
  \inferrule{t \Red t'}
            {\iter\:t\:f\:a\Red \iter\:t'\:f\:a}
\end{array}\]



L'implémentation de l'évaluation suit cette spécification :
\codefrom{untyped}{lambda}{iota_sig} \lstinline{(...)}
\codefrom{untyped}{lambda}{nat_evaluation}
Nous rappelons donc la fonction avec cette fois-ci \fun{(f a)} et le prédécesseur de \fun{n}.

Ici la \(\iota\)-réduction n'effectue que les étapes de calcul d'\fun{iter} sans effectuer l'évaluation
des applications. En effet cela n'est pas le rôle de la \(\iota\)-réduction mais de la $\beta$-réduction
de réduire les applications.


\subsubsection{Les paires}
\label{paires}


La paire est une construction très répandue dans les langages fonctionnels, 
cela nous permet de créer un ensemble de deux éléments. Afin d'en extraire les éléments,
nous utiliserons les projections $\pi_0$ et $\pi_1$. Celles-ci nous permettent 
d'obtenir respectivement le premier ou le second élément de la paire.

\begin{bnf}
  t &::= & (\ldots) &\mbox{(lambda terme)} \\
  &|& \Pair{t}{t} & \mbox{(pair)} \\
  &|& \Fst{t} & \mbox{($\pi_0$)} \\
  &|& \Snd{t} & \mbox{($\pi_1$)} 
\end{bnf}

Ce qui se traduit dans notre programme par l'ajout des termes suivants:

\begin{lstlisting}
type lambda_term = (...)
\end{lstlisting}
\vspace{-.7\baselineskip}
\codefrom{untyped}{lambda}{pair_term}

La substitution s'implémente trivialement car aucun de ces constructeurs 
n'est un lieur.
La \(\iota\)-réduction est étendue aux projections de la façon suivante:
%
\[\begin{array}{c}
  \inferrule{}
            {\Fst{\Pair{u}{v}} \Red u}
  \qquad
  \inferrule{}
            {\Snd{\Pair{u}{v}} \Red v}
  \medskip\\
  \inferrule{t \Red t'}
            {\Fst{t} \Red \Fst{t'}}
  \qquad
  \inferrule{t \Red t'}
            {\Snd{t} \Red \Snd{t'}}

\end{array}\]

Implémentons donc ces règles:
\codefrom{untyped}{lambda}{iota_sig} \lstinline{(...)}
\codefrom{untyped}{lambda}{pair_evaluation}
L'évaluation des membres de la paire s'effectue dans la fonction \fun{eval}:
\codefrom{untyped}{lambda}{evaluation_sig} \lstinline{(...)}
\codefrom{untyped}{lambda}{evaluation_pair}



\section{Le $\lambda$-calcul simplement typé}

Nous allons maintenant enrichir notre $\lambda$-calcul avec des
types. Cela va nous donner des propriétés quant à l'évaluation de nos
termes et leur utilisation. Nous verrons que dans le $\lambda$-calcul
simplement typé il est impossible d'écrire des termes qui ne soient pas
fortement normalisants, comme dans l'Exemple~\ref{paradoxe}. Dans un
premier temps nous introduirons les types, puis nous verrons comment
les utiliser en définissant des règles de typage pour nos termes.


\subsection{Les types}
\label{simple_type}


\newcommand{\intg}{\ensuremath{\mathsf{int}}}
\newcommand{\bool}{\ensuremath{\mathsf{bool}}}

Il est important avant tout de définir ce qu'est un type. Les types
que nous considérons dans cette partie sont décrits par la grammaire
suivante :
%
\begin{bnf}
  T &::=& &\mbox{(type)}\\
  &|& \intg{} &\mbox{(entiers)}\\ 
  &|& \bool{} &\mbox{(booléens)}\\
  &|& T \rightarrow T &\mbox{(fonction)}\\
  &|& T \times T &\mbox{(produit)}\\
\end{bnf}

\begin{example}
  Voici des exemples de type:
  \begin{eqnarray}
    \intg \rightarrow \bool  \label{eq_1}  \\
    \bool \times \intg \label{eq_2} 
  \end{eqnarray}
  Le type (\ref{eq_1}) est celui d'une fonction prenant un argument de type entier et 
  retournant un résultat de type booléen.
  Le second type (\ref{eq_2}) correspond à une paire donc le membre de gauche est un booléen
  et le membre de droite un entier.
\end{example}

\paragraph{Implémentation :}

La spécification des types se traduit naturellement en OCaml :
%
\codefrom{typed}{lambda}{Type}


\subsection{Système de type}

Un système de type est un système formel permettant de vérifier que l'ensemble de nos termes sont
correctement typés. Il sera question de définir un ensemble de règles pour chacun des termes de notre langage.
Le typage nous apportera certaines propriétés quant à la normalisation de nos termes comme nous le verrons
dans la section \ref{meta_theorie}. 

\subsubsection{Spécification}

Afin de faciliter la lecture et la compréhension, nous allons dans 
un premier temps donner les règles de typage pour les termes appartenant au noyau 
du langage. Nous donnerons les autres règles dans les sections suivantes.

La vérification de type s'effectue dans un \emph{contexte} qui assigne
à chaque variable d'un programme son type. Le contexte est donc une
liste ordonnée de paires variable/type :
%

\begin{bnf}
  \Gamma &::=& &\mbox{(contexte)} \\
         &|& . & \mbox{(contexte vide)} \\
         &|& \Gamma, x : T & \mbox{(type de variable)} 
\end{bnf}


\begin{figure}
\[
\begin{array}{c}
\inferrule[(Var)]%
             {x:T\,\in\Gamma}%
             {\Gamma\vdash x:T} 
\medskip\\
\inferrule[(Abs)]%
          {\Gamma, x:A \vdash t:B}%
          {\Gamma \vdash \Lam{\Var{x}}{t} \,:\, A\rightarrow B}
\qquad
\inferrule[(App)]%
          {\Gamma \vdash f : A\rightarrow B \\
           \Gamma \vdash s : A}%
          {\Gamma\vdash \App{f}{s} : B}
\end{array}
\]

\caption{Lambda calcul simplement typé}
\label{fig:typage-simple}
\end{figure} 


Les règles de typage sont définies en
Figure~\ref{fig:typage-simple}. La règle (\textsc{Var}) spécifie le
typage des variables. Cette expression se lit en partant du numérateur
pour déduire le dénominateur : supposons que la variable \Var{x} de
type \Var{T} soit présente dans le contexte, alors on conclut que le
type de la variable \Var{x} est \Var{T}.  La règle (\textsc{Abs})
spécifie le typage des $\lambda$-abstractions. L'abstraction construit un
type fonction de la forme \(A \Rightarrow B\) : il faut donc que la
variable associée au lambda terme soit de type \(A\) et le résultat de
type \(B\).  La règle (\textsc{App}) spécifie le typage de
l'application.  Dans un langage de programmation, appliquer un terme
n'étant pas une fonction n'a pas de sens. On s'assure donc que le
membre gauche de notre application est bien de type $A\rightarrow B$,
pour $A$ et $B$ quelconque. De plus on vérifie que l'argument de la
fonction est bien de type $A$, correspondant au domaine définition de la
fonction.


\begin{example}
  \label{probleme:type_simple}
  Voici donc quelques exemples de dérivations de type.  Ces
  dérivations se lisent du bas vers le haut.
  
  %% \todo{avec cfrac}
  %% \begin{align*}
  %%   \cfrac{
  %%     \cfrac{
  %%       \cfrac{
  %%         \cfrac{x:Int\rightarrow Bool \in \Gamma}{\Gamma,x:Int\rightarrow Bool,y:Int\vdash x:Int\rightarrow Bool}\:\:\:\:%level3gaucheApp
  %%         \cfrac{y:Int\in \Gamma}{\Gamma,x:Int\rightarrow Bool,y:Int\vdash y:Int}%level3droitApp
  %%       }{\Gamma,x:Int\rightarrow Bool,y:Int\vdash \App{x}{y} : bool}%level2
  %%     }{\Gamma,x:Int\rightarrow Bool\vdash \Lam{y}{\App{x}{y}}:Int \rightarrow Bool}%level1
  %%   }{\Gamma\vdash \Lam{x}{\Lam{y}{\App{x}{y}}}:(\intg\rightarrow \bool) \rightarrow \intg \rightarrow \bool} %level0
  %% \end{align*}

  \[
  \begin{array}{c}    
\inferrule[]%
          {\inferrule[]%
            {\inferrule[]              
              {\inferrule[]{x:\intg\rightarrow \bool \in \Gamma}{\Gamma,x:\intg\rightarrow \bool,y:\intg\vdash x:\intg\rightarrow \bool} %level3gaucheApp
               \inferrule[]{y:\intg\in \Gamma}{\Gamma,x:\intg\rightarrow \bool,y:\intg\vdash y:\intg} %level3droitApp
              }
              {\Gamma,x:\intg\rightarrow \bool,y:\intg\vdash \App{x}{y} : \bool}%level2
            }            
            {\Gamma,x:\intg\rightarrow \bool\vdash \Lam{y}{\App{x}{y}}:\intg \rightarrow \bool}%level1
            }
             {\Gamma\vdash \Lam{x}{\Lam{y}{\App{x}{y}}}:(\intg\rightarrow \bool) \rightarrow \intg \rightarrow \bool}%level0 
\end{array}
\]


  Ce terme est donc correctement typé.

\end{example}

Le système de type tel que présenté est une \emph{spécification} :
afin de l'implémenter, il nous faut effectuer des choix laissés libres
par la spécification. Par exemple, la dérivation
%
  \[
  \begin{array}{c}
    \inferrule[]
              {\inferrule{\Gamma, \Var{x} : ?_A \vdash \true : \bool}
                         {\Gamma\vdash (\Lam{x}{\true}): ?_A \rightarrow \bool }%level1gauche
               \:\:\:\inferrule[]{}{\Gamma\vdash \Lam{y}{\Var{y}}:?_A}%level1droit 
              }
              {\Gamma\vdash \App{(\Lam{x}{\true})}{(\Lam{y}{\Var{y}})}:\bool}%level0
              
  \end{array}  
  \]  
%
 admet une infinité de choix possibles pour le type
\(?_A\) : on pourra choisir $?_A = \intg$ ou encore $?_A = \bool \times (\intg \to \intg)$.

Afin d'obtenir un algorithme, la règle typant l'application introduit
donc une difficulté : il faut vérifier que le membre de gauche est de
type $A \rightarrow B$ alors que l'on ne connait que $B$. Nous allons
donc introduire une nouvelle représentation des termes afin de
déterminer la spécification et obtenir un algorithme.

\subsubsection{Syntaxe bidirectionnelle}


Les applications dont le membre de gauche est une abstraction, posent
problème car il faut leur calculer un type sans nécessairement avoir cette information à disposition immédiate.  Nous
allons donc partitionner les \(\lambda\)-termes en deux catégories :
d'une part, les termes dont on peut automatiquement synthétiser le
type (que l'on peut donc placer à gauche d'une application) et ceux
pour lesquels il faudra fournir une annotation de type (annotation que l'on saura vérifier efficacement).
Nous nommerons les premiers
les termes \emph{synthétisables} et les seconds les  termes
\emph{vérifiables}. 

\newcommand{\Inv}[1]{\ensuremath{\mathsf{inv}(#1)}}
\newcommand{\Ann}[2]{\ensuremath{(#1\: :\: #2)}}

Voici donc notre représentation des termes:
 
\begin{bnf}
  ex &::= &&\mbox{(termes synthétisables)} \\
  &|& \App{ex}{in} & \mbox{(application)} \\
  &|& \Var{x} & \mbox{(variable)} \\
  &|& \Ann{in}{T} & \mbox{(annotation)} \\
  in &::= &&\mbox{(termes vérifiables)} \\
  &|& \Lam{x}{in} & \mbox{(abstraction)} \\
  &|& \Inv{ex} & \mbox{(inversion)}
\end{bnf}


On a ainsi introduit l'inversion \Inv{ex}, qui permet d'inclure les
termes synthétisables dans le monde des termes vérifiables, et l'annotation \Ann{in}{T}, qui inclut les termes
vérifiables dans le monde des termes synthétisables en fournissant
l'information de typage manquante.

\newcommand{\verif}{vérification de type}
\newcommand{\synth}{synthèse de type}
\newcommand{\verifterme}{termes vérifiables}
\newcommand{\synthterme}{termes synthétisables}


\paragraph{Implémentation :}


La représentation des termes bidirectionnels est sans surprise :
\codefrom{typed}{lambda}{inTm}
\codefrom{typed}{lambda}{exTm}

Le type \lstinline!name! ci-dessous nous permettra de mettre des entiers à la place 
d'une chaîne de caractère\todo{description trop opérationnelle/peu motivée : ne pas en parler maintenant. On pourrait introduire name pour gérer les DefVars dans le non typé : cela simplifierai les choses.}, nous en reparlerons dans l'implémentation de l'évaluation.
\codefrom{typed}{lambda}{name}


\subsubsection{Système de type bidirectionnel}

À partir de cette nouvelle présentation de la syntaxe, on adapte
aisément les règles de typage
(Figure~\ref{fig:typage-simple-bi-direct}), qui sont désormais
entièrement dirigées par la syntaxe et donc purement algorithmique.


\begin{figure}
\label{regles typage bidirectionnel}

\[\begin{array}{c@{\qquad}c}
\boxed{\Gamma\vdash T \ni t}
&
\boxed{\Gamma\vdash t \in T}
\bigskip\\
%%
&
\inferrule[(Var)]
          {x:T \in \Gamma}
          {\Gamma \vdash x \in T }
\medskip\\
\inferrule[(Abs)]
          {T = A \rightarrow B \\
          \Gamma, x:A \vdash B \ni t}
          {\Gamma \vdash T \ni \Lam{x}{t}}
&
\inferrule[(App)]
          {\Gamma \vdash f \in A\rightarrow B \quad \Gamma\vdash A \ni s}
          {\Gamma\vdash \App{f}{s}\in B}
\medskip\\
%%
\inferrule[(Inv)]
          {\Gamma \vdash t \in T' \:\: T=T'}
          {\Gamma\vdash T \ni \Inv{t}}
&
\inferrule[(Ann)]
          {\Gamma\vdash T \ni t}
          {\Gamma\vdash \Ann{t}{T} \in T}
\end{array}\]


\caption{Lambda calcul  bidirectionnel simplement typé}
\label{fig:typage-simple-bi-direct} 
\end{figure}   


Les règles de la forme \(\Gamma\vdash T \ni t\) sont des règles de
vérification, celles de la forme \(\Gamma\vdash t \in T\) des règles
de synthèse.  Lors de la vérification, on connaît le type $T$ et
l'on souhaite déterminer si le terme $t$ est bien de ce
type. Lors de la synthèse, on est en mesure, à partir d'un terme
$t$ quelconque, de déterminer son type \(T\) sans ambiguïté.  On vérifie
aisément que ce système de type bidirectionnel est équivalent à celui
présenté en Figure~\ref{fig:typage-simple}.

\begin{example}
  Voici maintenant la même dérivation mais avec notre système de type bidirectionnel:
  \[
  \begin{array}{c}
    \inferrule[]
              {\inferrule{\Gamma, \Var{x} : \intg\rightarrow\intg \vdash \true : \bool}%level2droit
                         {\Gamma\vdash \Ann{\Lam{x}{\true}}{(\intg\rightarrow\intg)\rightarrow \bool}\in (\intg\rightarrow\intg)\rightarrow \bool }%level1gauche
                         \:\:\:\inferrule[]{\inferrule[]{}{\Gamma,y:\intg\vdash \intg \ni y}%level2droit
                         }{\Gamma\vdash \intg\rightarrow\intg \ni \Lam{y}{\Var{y}}}%level1droit 
              }
              {\Gamma\vdash \App{\Ann{(\Lam{x}{\true})}{(\intg\rightarrow\intg)\rightarrow\bool}}{(\Lam{y}{\Var{y}})}\in\bool}%level0
  \end{array}  
  \]  
\end{example}

\paragraph{Implémentation :}

\begin{itemize}
  
\item[$\bullet$] \boxed{\boxed{\Gamma\vdash T \ni t}}\\
  
  Nous disposons d'une fonction de vérification \lstinline!check!
  permettant de vérifier que le terme \fun{inT} est bien de type
  \fun{ty}.
  Le \fun{contexte} est une liste qui nous permet de stocker
  des paires associant une variable à son type. Il nous faut aussi
  donner le type d'entrée \fun{ty}.
    
  
  
  \codefrom{typed}{lambda}{check_def} 
  
\item[$\bullet$] \boxed{\inferrule[Abs]
  {T = A \rightarrow B\\ \Gamma, x:A \vdash B \ni t}
  {\Gamma \vdash T \ni \lambda x. t}} \\
  

  Lorsque que l'on veut vérifier le terme contenu dans une abstraction il faut libérer l'ensemble des variables
  qui lui sont associées. Avec notre représentation ``locally nameless'' nous somme obligé d'effectuer une substitution.
  
  C'est pour cette raison que l'on génère un nouveau nom à l'aide de la fonction \fun{gensym} qui nous garantie
  que ce nom n'a jamais été utilisé. On substitue l'ensemble
  des variables liées à l'abstraction en cours avec une variable libre dont le nom est celui généré précédement.
  On insère ensuite dans le contexte l'association variable type.
  
%
 \codefrom{typed}{lambda}{check_abs}

\item[$\bullet$] \boxed{\cfrac{\Gamma \vdash t \in T' \:\: T=T'}
                              {\Gamma\vdash T \ni inv(t)}\mbox{(Inv)}} \\


Afin de tester l'égalité de type, l'égalité structurelle de OCaml est
suffisante puisque les types sont purement statiques (contrairement
aux types dépendants qui, eux, calculeront).
%
\codefrom{typed}{lambda}{check_inv}
  

\item[$\bullet$] \boxed{\boxed{\Gamma\vdash t \in T}}\\

La fonction de synthèse \lstinline!synth! prend un contexte, un
terme synthétisable et renvoie le type de celui-ci.

 \codefrom{typed}{lambda}{synth_def}

\item[$\bullet$] \boxed{\cfrac{\Gamma\vdash T \ni t}
                              {\Gamma\vdash (t:T) \in T}\mbox{(Ann)}} \\

  Nous sommes ici en synthèse c'est à dire que nous devons retourner un type.
  Si $t$ est effectivement de type $T$, alors il suffit de retourner $T$.
  %
\codefrom{typed}{lambda}{synth_ann}



\item[$\bullet$] \boxed{\cfrac{x:T \in \Gamma}
                               {\Gamma \vdash x \in T }\mbox{(Var)}}\\

Dans la spécification formelle, on ne fait pas de distinction entre
les variables libres et liées.  Comme nous l'avons vu dans la règle de
typage de l'abstraction, l'ensemble des variables liées à chacun des
lieurs sont libérées. La spécification parle donc bien des variables
libres, que l'on synthétise à partir  du type qui leur a été assigné dans le contexte.
%
\codefrom{typed}{lambda}{synth_var}

\item[$\bullet$] \boxed{\cfrac{\Gamma \vdash f \in A\rightarrow B \quad \Gamma\vdash A \ni s }
         {\Gamma\vdash f\:s\in B}\mbox{(App)}}\\

  
  Comme la spécification nous l'indique, il est d'abord nécessaire de synthétiser le type de $f$.
  Il faut ensuite s'assurer que le type retourné par la synthèse est bien de la forme $A\rightarrow B$
  puis en extraire le type $A$ pour pouvoir cette fois-ci vérifier $s$. Si cette vérification réussit,
  on retourne le type $B$.
 
\codefrom{typed}{lambda}{synth_appl}

\end{itemize}

Pour cette implémentation nous avons choisi de générer des exceptions
lorsque le terme n'était pas correctement typé. Cela permet de
terminer le programme directement car de toute façon le terme serait
refusé. Nous reviendrons cependant sur certains points négatifs de
cette méthode dans la section \ref{upgrade_type_check}.



\subsection{Normalisation} 

Dans cette section nous verrons certaines propriétés offertes par les
systèmes de type, et nous parlerons de l'évaluation. Nous ne
reviendrons pas sur la substitution ni la $\beta$-réduction, qui
restent identique aux définitions introduites en
Section~\ref{calculer_dans_le_lambda_calcul}.

\subsubsection{Méta-théorie}
\label{meta_theorie}

Le typage permet d'obtenir, lors de la compilation, des garanties quant à la
bonne exécution des programmes.  Formellement, ces garanties se traduisent en deux propriétés complémentaires d'un système de type :
\begin{description}
\item[Progrès :] si un terme \(t\) est correctement typé alors soit \(t\) est une valeur, soit il
 existe une réduction telle que \(t \leadsto t'\)
\item[Préservation :] si un terme $t$ a le type $T$
et que $t \leadsto t'$ alors $t'$ est de type~$T$
\end{description}

La conjonction de ces deux propriétés donne le slogan ``un programme
bien typé ne plante jamais'' \todo{citation milner}. tout programme
bien typé réduit vers une valeur de ce type.

\begin{example}
  Un programme de type \bool{} réduit vers une valeur de type \bool{}
  et donc ce programme réduit \emph{nécessairement} vers le
  constructeur \true{} ou le constructeur \false{}.
\end{example}


\subsubsection{Réduction forte}

\label{reduction_forte}
Dans le \(\lambda\)-calcul non typé, nous avions utilisé une stratégie
d'évaluation en appel par nom car nous n'avions pas la garantie que
les termes réduits soient fortement normalisants.  D'après les
propriétés de la section précédente nous disposons de la certitude que
les termes acceptés par le type-checker sont fortement
normalisants.

De plus, les types ne sont plus utiles lors de l'évaluation.  Nous
allons donc implémenter une stratégie de réduction forte sur les
\(\lambda\)-termes non typés de la Section~\ref{sec:untyped}. La
réduction forte du \(\lambda\)-calcul simplement typé sera donc
obtenue par plongement des termes bidirectionnels dans le fragment
fortement normalisant du \(\lambda\)-calcul non typé. La traduction de
nos termes bidirectionnels vers les termes non typés est transparente
: il suffit d'effacer les annotations de type.

\begin{example}
  
  \todo{Roman: j'ai l'exemple sur papier faut juste que le mette dans le rapport C'est l'exemple où cela ne réduit pas}
   
\end{example}

\paragraph{Implémentation :}
\label{reduction_petits_pas}

La fonction de réduction forte est très similaire à la fonction
d'évaluation précédente
%
\codefrom{untyped}{lambda}{reduction_forte}
%
Avec les garanties offertes par notre
système de type nous pouvons à présent contracter \emph{tous} les
redexes d'un terme sans risque de divergence. 



\subsection{Extensions} 

Dans notre calcul non typé, nous avions introduit les booléens, les entiers ainsi que les paires,
nous verrons ici la façon de les représenter ainsi que leurs règles de typage.

\subsubsection{Les entiers}
\label{entier_type}

Les constructeurs sont les mêmes que dans le \(\lambda\)-calcul non typé 
cependant, maintenant que nous disposons de termes bidirectionnels, il est important
de préciser leur phase.

\succs{} et \zero{} sont des termes vérifiables étant donné que
leur type sera toujours \emph{Nat}. À l'inverse, on exige que l'itérateur soit annoté par son type de retour :
celui-ci est donc  synthétisable.
Les règles de typage bidirectionnel sont donc :
\[
\begin{array}{c}
\inferrule[(Zero)]%
             {\:}%
             {\Gamma\vdash Nat \ni \zero} 
\medskip\\
\inferrule[(Succ)]%
          {\Gamma\vdash Nat \ni \Var{t}}%
          {\Gamma\vdash Nat \ni \succs\:\Var{t}}
\qquad
\inferrule[(Iter)]%
          {\Gamma\vdash Nat \ni n \:\: \Gamma\vdash A \ni a \:\: \Gamma\vdash A\rightarrow A \ni f}%
          {\Gamma\vdash \iter\: \Var{A}\: \Var{n}\: \Var{f}\: \Var{a} \in \Var{A}}
\end{array}
\]

%
Les règles d'évaluations restent inchangées. 

\subsubsection{Les booléens}


Afin de pouvoir typer nos termes, il nous faut introduire le type \bool{}.
En suivant la même démarche que  pour les entiers, les 
constructeurs \emph{True} et \emph{False} sont désormais des \emph{termes vérifiables}
et le constructeur \emph{Ifte} un \emph{terme synthétisable}

Nous pouvons désormais typer nos booléens de la manière suivante:

%
\[
\begin{array}{c}
\inferrule[(true)]
          {{}}
          {\bool \ni \Gamma\vdash \true{}}
\qquad
\inferrule[(false)]
          {{}}
          {\bool \ni \Gamma\vdash \false{} }
\medskip\\
\inferrule[(If-else)]
          {\Gamma\vdash \bool\ni t1{} \\
           \Gamma\vdash t2\in A \\
           \Gamma\vdash t3\in A}
         {\Gamma\vdash \ifte[A]{t1}{t2}{t3} \in A}
\end{array}
\]

\subsubsection{Le produit cartésien}
\label{produit_cartesien}

%% \newcommand{\pair}[2]{\ensuremath{#1,#2}}
%% \newcommand{\produit}[2]{\ensuremath{#1\times#2}}
%% \newcommand{\projun}[1]{\ensuremath{\pi0.#1}}
%% \newcommand{\projdeux}[1]{\ensuremath{\pi1.#1}}

Les projections sont des \emph{termes synthétisables} étant donné que
leur type dépend de la paire sur laquelle ils sont appliqués. La paire est
un \emph{terme vérifiable} car chaque paire à un type statique.

Règle de typages des paires:

\[
\begin{array}{c}
\inferrule[(Paire)]
          {\Gamma\vdash A\ni a \:\: \Gamma\vdash B\ni b}
          {\Gamma\vdash A\times B \ni \Pair{a}{b}}
\qquad
\inferrule[($\pi_0$)]
          {\Gamma\vdash p \in A\times B}
          {\Gamma\vdash \Fst{p} \in A}
\medskip\\
\inferrule[($\pi_1$)]
          {\Gamma\vdash p \in A\times B}
          {\Gamma\vdash \Snd{p} \in A}
\end{array}
\]

Pour les projections, il nous faut vérifier le fait que l'argument est
bien de type produit afin de retourner le type du membre de gauche ou
droit.

Concernant l'évaluation, les règles sont les mêmes qu'en Section~\ref{paires}.

\paragraph{Implémentation :}
Nous allons maintenant implémenter le produit cartésien afin d'enrichir
notre langage. 

%% En l'état, cette liste de code sans commentaire nous est inutile.
%% \emph{Type}
%% \codefrom{typed}{lambda}{type_pair}
%% \emph{inTermes}
%% \codefrom{typed}{lambda}{inTm_pair}
%% \emph{exTermes}
%% \codefrom{typed}{lambda}{exTm_pair}

L'algorithme de typage suit litéralement sa spécification bidirectionnelle :
%
\codefrom{typed}{lambda}{check_def}\lstinline!(...)!
\codefrom{typed}{lambda}{check_pair}
\codefrom{typed}{lambda}{synth_def}\lstinline!(...)!
\codefrom{typed}{lambda}{synth_pair}



\subsection{Réduction forte à grands pas}
\label{red_forte_grand_pas}

Dans cette section, nous décrivons une implémentation alternative de
la réduction forte qui exploite le fait que nous implémentons notre évaluateur dans un langage fonctionnel.
Il est intéressant d'exploiter les mécanismes d'Ocaml. Nous allons créer un interpréteur pour nos termes
en utilisant les termes Ocaml ce qui nous permettra de ne pas avoir à 
gérer les mécanismes de définition de fonction et d'application.

Comme nous l'avons vu dans la Section~\ref{reduction_forte} \if 0 peut
etre dans la partie safety je ne me souviens plus a voir \fi la
réduction forte aboutit forcément à une forme normale, les termes que
nous obtenons par la réduction à grands pas, seront donc les mêmes que
ceux obtenus avec la réduction à petits pas
(Section~\ref{reduction_petits_pas}).

\newcommand{\VLam}{\lstinline!VLam!}
Voici donc le code correspondant à la nouvelle représentation de nos termes en Ocaml:

\codefrom{typed}{lambda}{value}
\codefrom{typed}{lambda}{neutral}

Le terme \fun{VLam} correspond à l'abstraction.
Cette représentation nous permet de reconsidérer la façon de voir la 
réduction d'une abstraction. En effet lorsque l'on applique une abstraction
à un terme, nous avions introduit la substitution, qui consiste à remplacer les occurences 
des variables liées à ce terme. La transformation d'une abstraction consiste donc à 
créer une fonction anonyme puis à évaluer le terme contenu dans celle-ci en ajoutant dans le 
contexte la variable liée à cette fonction. Lors de l'évaluation d'une variable liée, on va
retrouver dans le contexte l'argument correspondant. On aura donc bien le comportement attendu
lors de l'application de cette fonction anonyme car cela va remplacer les occurences de la 
variable.

\begin{example}
  Soit le terme \(\App{\Lam{x}{\Var{x}}}{u}\), avec la méthode
  d'évaluation à petit pas, on évalue en effectuant $\subst{x}{x}{u}$
  ce qui nous donne comme résultat $u$.  Avec l'évaluation à
  grands pas, on évalue le terme $\Lam{x}{x}$ en la fonction OCaml
  \lstinline!fun arg -> arg!. Cette fonction une fois appliquée à la traduction $v_u$ de
  $u$,  nous retourne $v_u$ comme souhaité.
\end{example}


Comme nous l'avons vu précédement le type contenu dans une annotation n'est pas utile lors de l'évaluation.
Il nous faut simplement évaluer le terme \fun{x} contenu dans celle ci.
%
\codefrom{typed}{lambda}{big_step_eval_exTm_ann}

Il en est de même pour l'inversion :
\codefrom{typed}{lambda}{big_step_eval_inTm_inv}


Pour les variables liées il faut retrouver dans le contexte la variable à laquelle elle est associée.
Cela nous permettra de définir cette variable comme un argument de la fonction anonyme que nous avons
créée avec l'évaluation de l'abstraction.

\codefrom{typed}{lambda}{big_step_eval_exTm_var}

Nous avons besoin de créer des \fun{neutral} pour
tous les termes dont l'évaluation est terminée. C'est le rôle de la fonction
\fun{vfree} dont voici le code:
\codefrom{typed}{lambda}{vfree}


Pour évaluer l'application d'un coup, définissons une fonction 
\fun{vapp} permettant d'effectuer la réduction.  Nous appelons donc cette fonction avec le couple formé
par l'évaluation de la fonction et son argument.  Si la fonction est une abstraction, il nous suffit d'appliquer celle-ci
\emph{dans Ocaml}, étant donné qu'elle est encodée par une fonction
anonyme OCaml. Sinon l'évaluation est bloquée sur un terme neutre, il faut donc
créer un nouveau terme neutre contenant la fonction suspendue.
Voici le cas de l'application dans notre fonction d'évaluation:

\codefrom{typed}{lambda}{big_step_eval_exTm_app}
Ainsi que le code de \fun{vapp}: 
\codefrom{typed}{lambda}{vapp}

Comme nous l'avons vu précédement, nous avons créé une \fun{value} correspondant
à l'abstraction, \fun{VLam} prenant en argument une fonction de type \fun{value} $\rightarrow$ \fun{value}.
L'évaluation de l'abstraction consiste donc à transformer celle-ci en une fonction.
\codefrom{typed}{lambda}{big_step_eval_inTm_abs} 

Une fois nos termes évalués dans OCaml, il s'agit de les
\emph{réifier} sous forme de termes de notre
$\lambda$-calcul. Cette fonction doit nécessairement prendre un argument de
type{value} afin de nous retourner un \emph{terme synthétisable}.

\codefrom{typed}{lambda}{value_to_inTm}
\codefrom{typed}{lambda}{neutral_to_exTm}



Le type \fun{name} nous permet de faire la distinction entre les
variables réellement libres et celles que nous souhaitons lier pendant la réification.
Afin de transformer une valeur \lstinline!VLam f! en
\emph{Abs} il nous faut appliquer la fonction \emph{f} à une variable
de réification, que l'on distinguera des autres variables libres grâce au type \fun{name}.
On s'assure que les variables ainsi introduites sont fraîches en utilisant la fonction \fun{gensym}.
La fonction \fun{boundfree} va nous permettre de relier les \fun{NFree} dont la variable est un \fun{Quote}.
\codefrom{typed}{lambda}{boundfree}



\section{Les types dépendants}

Maintenant que les bases du $\lambda$-calcul et du typage on été présentés,
nous allons découvrir les types dépendants. 
 
\subsection{Automatisation de démonstration de preuve}
Durant les deux premières parties du rapport nous avons présenté le $\lambda$-calcul
qui nous a permis de nous initier à la conception et à l'implémentation d'un système de type. Cependant nous avions une vision 
calculatoire des types. En effet notre seul but était de nous assurer que nos $\lambda$-termes
étaient fortement normalisants. 
Un des aspects primordial des systèmes de types est la correspondance de Curry-Howard.
Celle-ci permet de d'établir des relations entre la logique propositionnelle et les systèmes 
de type. Nous verrons que ``t est une preuve de P'' est équivalent à  $t:P$ c'est à dire  $t$ est de type $P$.
Tout d'abord intéressons nous aux bases de la logique propositionnelle.

\subsubsection{La logique propositionnelle}

Les règles de la logique propositionnelle associent à chaque
connecteur logique une \emph{règle d'introduction} qui permet de
formuler une conclusion à partir de certaines hypothèses. Par exemple,
la règle d'introduction de l'implication est
%
\begin{align*}
  \inferrule[]{\Gamma, A \vdash B}
        {\Gamma \vdash A \Rightarrow B}
\end{align*}

Les connecteurs logiques sont éliminés à travers une \emph{règle
  d'élimination}, qui se traduit calculatoirement par des règles de
réduction. Par exemple, la règle d'élimination de l'implication est 
%
\[
  \inferrule{\Gamma \vdash A\Rightarrow B \\
             \Gamma \vdash A}
            {\Gamma \vdash B}
\]

On constate que la règle d'introduction de l'implication est presque identique à celle 
du typage de l'abstraction. De même pour l'élimination vis à vis de la règle de l'application.
C'est cette intuition 
qu'ont eu Haskell Curry et Alvin Howard ce qui à permis d'établir la correspondance
entre les systèmes de type et la logique propositionnelle.

Regardons maintenant un second exemple, le constructeur $\land$
signifiant le \emph{et} logique. La règle d'introduction énonce que
pour prouver $A\land B$, il nous faut prouver d'une part $A$ et d'autre
part $B$ :
%
\begin{align*}
\inferrule{\Gamma \vdash A\\
           \Gamma \vdash B}
          {\Gamma A \land B}
\end{align*}

Si l'on désire prouver une proposition $A$ et que l'on suppose $A\land B$ alors celle-ci 
est vraie. Ce raisonnement est aussi valable pour une propriété $B$.
\begin{align*}
\inferrule{\Gamma \vdash A \land B}
          {\Gamma \vdash A}
\medskip\\
\inferrule{\Gamma \vdash A \land B}
          {\Gamma \vdash B}
\end{align*}

On reconnaît ici le produit cartésien que l'on avait introduit dans
notre $\lambda$-calcul simplement typé : la règle d'introduction
correspond au constructeur de paires tandis que les éliminateurs
correspondent aux projections \Fst{} et \Snd{}.


Pour l'instant, nous n'avons pas établi de lien réel entre ces connecteurs et nos termes, c'est l'enjeu de la
section suivante.

\subsubsection{Correspondance de Curry Howard}
\label{corres_curry_howard}

Dans la section précédente nous avons regardé quelques intuitions permettant de voir le lien entre la logique
et l'informatique au travers des systèmes de type.
Nous avons étudié le $\lambda$-calcul qui permet de faire le lien avec la déduction naturelle. 
Voici un tableau montrant les différents liens entre la logique et le $\lambda$-calcul.

\begin{tabular}{c@{\quad$\leftrightarrow$\quad}c}
  logique & $\lambda$-calcul \\
  axiome & variable \\
  règles d'introduction & constructeurs \\
  règles d'élimination & destructeurs \\
  normalisation des preuves & réduction du calcul \\
\end{tabular}
\\


Le fait d'avoir séparé nos termes permet de rendre ces correspondances plus aisées. En effet les constructeurs
correspondent aux \emph{termes vérifiables} tandis que les \emph{termes synthétisables} sont les destructeurs.
Introduire de nouveaux termes dans notre $\lambda$-calcul nous a ainsi permis d'introduire de nouveaux connecteurs logiques dans notre système. Nous allons suivre la même motivation en introduisant les types dépendants.

Si nous souhaitons prouver une proposition, c'est à dire un type, il nous faudra trouver
un terme accepté par notre vérificateur de type.
Ceci permet d'aider grandement la recherche de démonstration étant donné que le vérificateur de type nous assiste dans la création des preuves, notamment grâce à une amélioration
que nous verrons en Section~\ref{ex_preuves}.



\subsection{Système de type dépendant}

Comme nous allons le voir dans cette section, les types dépendants vont nous permettre d'écrire des programmes/termes qu'il était impossible d'écrire dans le cadre simplement typé. Faisant écho à la section précédente,
nous allons introduire un nouveau lien entre logique et typage : le quantificateur $\forall$.

\subsubsection{Equivalence entre les types et les termes}
\label{presentation_type_dependants}

Jusqu'à présent, nous avions d'une part l'ensemble des types et l'ensemble des termes. Cette séparation 
avait un sens car les termes et les types ne se comportaient pas de la même façon et n'avaient pas les mêmes propriétés. 
La plus grande différence se situait au niveau de l'évaluation, en effet nos types étant statiques il n'était pas nécessaire de les évaluer.
Cependant certains termes ne peuvent pas s'exprimer dans un système de type statique, prenons par exemple
la fonction identité. 
\begin{example}
  Dans notre système précédent, il existait une fonction identité pour chaque type :
  \begin{align*}
    &\Lam{x}{x}\: :Bool\rightarrow Bool \\
    &\Lam{x}{x}\: :Int\rightarrow Int \\
    & ... \\
  \end{align*}
On souhaiterait écrire une fonction polymorphe dont le type de retour est influencé par le type en entrée.
\end{example}

Il existe différentes façon de permettre l'écriture de fonctions comme celles-ci. Inspirons-nous de la
logique, le quantificateur $\forall$ nous permet d'écrire ce type de termes.
\begin{example}
  On souhaiterait pouvoir écrire une fonction identité de la manière suivante :
  \begin{align*}
    \Lam{A}{\Lam{x}{x}}\::(\forall A, A \rightarrow A)
  \end{align*}
\end{example}

\newcommand{\nil}{\ensuremath{\mathsf{nil}}}
\newcommand{\cons}{\ensuremath{\mathsf{cons}}}
\newcommand{\Vect}{\ensuremath{\mathsf{vec}}}

Avec des variables au sein de nos types nous pouvons désormais introduire des \emph{familles de type},
comme par exemple les vecteurs de taille \emph{n}.
\begin{example}  
  \label{example vecteur}
  Les vecteurs représentent des listes dont la taille est connue (et
  vérifiée) lors de la compilation. Voici des vecteurs d'éléments de
  type $\alpha$, pour certaines tailles \emph{n} fixées : \todo{Définir des macros}
  \begin{align*}
    &\nil &: \Vect\: 0\: \alpha \\
    &\cons\: \true\: \nil &: \Vect\: 1\: \bool \\
    &\cons\: \false\: (\cons\: \true\: \nil) &: \Vect\: 2\: \bool \\
  \end{align*}
\end{example}
En introduisant une dépendance des types sur les types, ceux-ci se
comportent de la même façon que les termes. En particulier, la notion
de réduction s'élève au niveau des types : on s'attend à ce que le
type \(\Vect\: (2 + 2)\: \bool\) soit ``équivalent'' au type \(\Vect\:
4\: \bool\).  Poussant cette logique à l'extrême, on est amené à
considérer les types et les termes comme appartenant à une unique
famille syntaxique régie par les même propriétés.

Afin de distinguer statiquement types et termes, on introduit le type
$\star$, le type des types.
\begin{example}
  Pour être tout à fait explicite, notre fonction identité est de type
  \begin{align*}
    \forall A : \star, A \rightarrow A
  \end{align*}
  
  Quand le quantificateur porte sur une variable de type, on aura
  tendance à garder son type (nécessairement $\star$) implicite.

\end{example}

\subsubsection{Réduction}
\label{maj_eval}

Etant donné que nos types sont désormais des termes et que l'on peut
les normaliser il nous faut d'abord parler de l'évaluation. 
L'évaluation du terme $\star$ est triviale car ce terme est déja en forme normale.
Pour $\forall$, il nous faut évaluer ses deux arguments.

\[\begin{array}{c}
  \inferrule{{}}
            {*\Downarrow *}
  \medskip\\
  \inferrule{{p\Downarrow t\:\:\:p'\Downarrow t'}}
            {\forall x:p.p'\Downarrow \forall x:t.t'}
\end{array}\]

\newcommand{\Pis}[3]{\ensuremath{\Pi#1 : #2. #3}}

En général le connecteur $\forall$ se note $\Pi$, nous garderons cette convention. 


Les deux notations suivantes sont équivalentes: 
\begin{align*}  
  \forall x:S.T \Leftrightarrow \Pis{x}{S}{T}
\end{align*}

Afin d'alléger la syntaxe, un $\Pi$ anonyme sera noté comme une simple implication :
\begin{align*}
  & \forall x:Nat.Nat \Leftrightarrow \Pis{x}{Nat}{Nat} \Leftrightarrow (Nat \rightarrow Nat) \\
\end{align*}

L'implémentation suit la stratégie de normalisation par évaluation présentée en Section~\ref{red_forte_grand_pas}. 
Les deux \emph{value} nécessaires à l'implémentation de cette évaluation sont:

\codefrom{dependent}{lambda}{value_head}\lstinline!(...)!
\codefrom{dependent}{lambda}{value_pi_star}

En suivant le même raisonnement que pour l'évaluation d'une abstraction avec la
fonction \fun{big_step_eval}, nous allons transformer le second membre de $\forall$
en fonction anonyme. 

\codefrom{dependent}{lambda}{big_step_head}\lstinline!(...)!
\codefrom{dependent}{lambda}{big_step_new}


Le premier membre est évalué simplement tandis que le second est evalué vers une fonction anonyme puis, comme pour l'abstraction, cela nous permet de pouvoir directement substituer les valeurs normalisées dans notre type.

La fonction de réification est étendue sans surprise:
\codefrom{dependent}{lambda}{value_to_inTm_head}\lstinline!(...)!
\codefrom{dependent}{lambda}{value_to_inTm_new}



\subsubsection{Formalisation}

Maintenant que nous avons l'intuition des nouveaux constructeurs, nous pouvons enrichir notre langage.
Les règles de typage sont présentées en style bidirectionnel en Figure~\ref{fig:typage dependant}.

\begin{figure}
  \[
  \begin{array}{cc}
  \boxed{\Gamma\vdash T \ni t}
  &
  \boxed{\Gamma\vdash t \in T}
  \bigskip
  \\ 
  &
  \cfrac{x:T \in \Gamma}
        {\Gamma \vdash x \in T }\mbox{(Var)}
  \medskip
  \\
  \cfrac{\Gamma \vdash t \in T' \:\: T=T'}
        {\Gamma\vdash T \ni inv(t)}\mbox{(Inv)}
  &
  \cfrac{\Gamma\vdash * \ni T \:\:\Gamma\vdash T \ni t}
        {\Gamma\vdash (t:T) \in T}\mbox{(Ann)}
  \medskip
  \\
  \cfrac{}
        {\Gamma \vdash * \ni *}\mbox{(Star)} 
  \medskip
  \\
  \cfrac{\Gamma \vdash * \ni S\:\:\Gamma,x:S \vdash *\ni T}
        {\Gamma\vdash * \ni \forall x:S.T}\mbox{(Pi)}
  \medskip
  \\
  \cfrac{\Gamma,x:S\vdash T \ni t}
        {\Gamma \vdash \forall x:S.T \ni \lambda x. t}\mbox{(Abs)} 
  & 
  \cfrac{\Gamma \vdash f \in \forall x:S.T \quad \Gamma\vdash S \ni s }
        {\Gamma\vdash f\:s\in \subst{T}{s}{x}}\mbox{(App)} 
  \end{array}
  \]
  
  \caption{Typage dépendant}
  \label{fig:typage dependant} 
\end{figure}

Les deux nouvelles constructions $Pi$ et
$\star$ sont des termes vérifiables étant donné que l'on possède
toute l'information nécessaire pour les vérifier efficacement. De
manière générale les types seront des termes vérifiables.  Le caractère
bidirectionnel du langage est utilisé ici de façon cruciale
pour obtenir une présentation algorithmique du test de conversion : il
est tout simplement traité par le changement de phase (règle
\textsc{Inv}).

Pour le moment, mis à part la dépendance introduite par l'abstraction, notre langage ne comporte pas de termes exploitant 
l'expressivité des types dépendants. Nous découvrirons leur richesse au fur et à mesure des extensions.

Avant de poursuivre, il est important de se convaincre que l'ensemble des termes exprimables avec un système 
de type simple est inclus dans l'ensemble des termes exprimables dans un système de type dépendant.
\begin{example}
  On peut toujours exprimer une fonction identité applicable uniquement aux entiers de la manière suivante:
  \begin{align*}
    &\Lam{x}{x} : \forall x:Int.\: Int \\
  \end{align*}
\end{example}

\paragraph{Implémentation :} 

Représentons nos termes vérifiables et synthétisables dans le programme:
\codefrom{dependent}{lambda}{inTm_head}
\codefrom{dependent}{lambda}{inTm}
\codefrom{dependent}{lambda}{exTm_head}
\codefrom{dependent}{lambda}{exTm}

Nous n'avons rajouté que deux nouveaux termes dans le noyau de notre langage mais 
le fait de ne plus faire la distinction entre les termes et les types change beaucoup de
choses dans l'architecture du programme. 


\begin{itemize}
\item[$\bullet$]
  \boxed{\boxed{\Gamma\vdash T \ni t}}

Nous avons désormais une forme normale pour les types, il est donc intéressant de 
fournir cette forme normale directement au vérificateur de type. La fonction \fun{check} prend donc maintenant
un contexte, un terme vérifiable ainsi qu'un type en forme normale. Nous somme obligé d'effectuer cette opération car
nos termes ne sont plus statiques.

  \codefrom{dependent}{lambda}{check_head}

\item[$\bullet$] \boxed{\inferrule[(Abs)]{\Gamma,x:S\vdash T \ni t}
  {\Gamma \vdash \forall x:S.T \ni \lambda x. t}}\\

  Pour l'abstraction il nous faut libérer les occurences de $x$ dans $T$.
  Etant donné que nous avons désormais des variables liées dans le type $\Pi$ il nous faut
  effectuer la même opération que pour l'abstraction à savoir une substitution avec une variable
  fraîche. Notre type étant sous forme normale son second membre est une fonction
  anonyme comme vu en Section~\ref{maj_eval}. La substitution s'effectue donc au travers de l'application de fonction en Ocaml.

  \codefrom{dependent}{lambda}{check_abs}
  
\item[$\bullet$] \boxed{\inferrule[(Inv)]{\Gamma \vdash t \in T' \:\: T=T'}
  {\Gamma\vdash T \ni inv(t)}}\\
  
  Le principal changement de cette implémentation est le changement d'égalité. 
  En effet, ici les types sont des valeurs OCaml d'ordre supérieur (pouvant contenir des fonctions anonymes) dont on ne peut 
  tester l'égalité. Il nous faut donc d'abord transformer 
  ces valeurs en termes. Le second problème est que le nom associé 
  aux différents lieurs tels que le $\lambda$ ou le $\forall$ n'auront pas nécessairement le 
  même nom. Comme nous l'avons vu dans la Section~\ref{alpha_equiv},
  deux termes sont égaux même si le nom de leur variable est différents. 
  La fonction \fun{equal_inTm} parcourt simplement les deux termes passés en arguments sans tenir compte
  du nom de variable associé au lieur. Par contre les variables libres doivent nécessairement être les mêmes.

  \codefrom{dependent}{lambda}{check_inv}

         
\item[$\bullet$] \boxed{\cfrac{}
    {\Gamma \vdash * \ni *}\mbox{(Star)}}\\    

  L'implémentation de la règle \emph{Star} est triviale:
  
  \codefrom{dependent}{lambda}{check_star}

    
\item[$\bullet$] \boxed{\cfrac{\Gamma \vdash * \ni S\:\:\Gamma,x:S \vdash *\ni T}
    {\Gamma\vdash * \ni \forall x:S.T}\mbox{(Pi)}}\\    
  
  Ici,  $\Pi$ n'est pas sous forme normale étant donné qu'il est le terme
  à vérifier. Nous sommes donc obligés d'effectuer la substitution de $x$ dans $T$
  avec notre fonction \fun{substitution}:
  
\codefrom{dependent}{lambda}{check_pi}

\item[$\bullet$] \boxed{\boxed{\Gamma\vdash t \in T}}

Notre fonction de synthèse nécessite un contexte \fun{ctxt} qui est de même type que celui de la fonction
\fun{check} ainsi qu'un terme synthétisable \fun{exT}

    \codefrom{dependent}{lambda}{synth_head}

\item[$\bullet$] \boxed{\cfrac{x:T \in \Gamma}
    {\Gamma \vdash x \in T }\mbox{(Var)}}\\    

  Tout comme dans l'implémentation précédente, il n'est pas possible de rencontrer de variable 
  liée lors de la vérification de type. 

  \codefrom{dependent}{lambda}{synth_var}


\item[$\bullet$] \boxed{\cfrac{\Gamma \vdash f \in \forall x:S.T \quad \Gamma\vdash S \ni s }
    {\Gamma\vdash f\:s\in \subst{T}{s}{x}}\mbox{(App)}}\\    

  Si la synthèse de $f$ nous donne bien un $\Pi$ et que l'on vérifie $s$ de type
  $S$ alors il nous faut retourner $T$ en substituant les occurences de variables liées.  
  Etant donné que $\Pi$ est sous forme normale cette substitution s'effectue
  comme dans la règle de l'abstraction, par application de fonction dans Ocaml.
  
  \codefrom{dependent}{lambda}{synth_app}


\item[$\bullet$] \boxed{\cfrac{\Gamma\vdash * \ni T \:\:\Gamma\vdash T \ni t}
    {\Gamma\vdash (t:T) \in T}\mbox{(Ann)}}\\

Etant donné que termes et types sont équivalents, il faut vérifier que
le type $T$ proposé par l'annotation est bien un type (donc de type
$\star$), sans quoi l'utilisateur pourrait introduire un type mal
formé et donc, potentiellement, une contradiction logique. Il faut
aussi évaluer celui-ci afin de le mettre en forme normale.
  
\codefrom{dependent}{lambda}{synth_ann}

\end{itemize}


\subsection{Extensions}

Comme nous l'avons vu dans l'Exemple~\ref{example vecteur} nous pouvons typé de nouveaux termes inexistants auparavant.
Nous commencerons par mettre à jour les types de données courants. Nous présenterons ensuite les vecteurs ainsi que l'égalité.

\subsubsection{Les entiers}


La représentation de nos termes n'a pas changé:
\codefrom{dependent}{lambda}{inTm_head}\lstinline!(...)!
\codefrom{dependent}{lambda}{terme_nat}
\codefrom{dependent}{lambda}{exTm_head}\lstinline!(...)!
\codefrom{dependent}{lambda}{terme_iter}


Passons maintenant aux règles de typages: 
\[\begin{array}{c}
  \inferrule[(Nat)]{\:}
            {\Gamma\vdash * \ni Nat}
  \qquad
  \inferrule[(Zero)]{\:}
            {\Gamma\vdash Nat \ni \zero}
  \qquad
  \inferrule[(Succ)]{\Gamma\vdash Nat \ni n}
            {\Gamma\vdash Nat \ni \succs\:n}
  \medskip\\
  \inferrule[(Iter)]
            {\Gamma\vdash Nat\rightarrow *\ni P \\
              \Gamma\vdash Nat\ni n\\
              \Gamma\vdash \forall n:Nat.(P\:n\rightarrow P\:(\succs\:n))\ni f\\
              \Gamma\vdash P\:\zero\ni a}
            {\Gamma\vdash \iter \: P\: n\:f\:a\in P\:n}

\end{array}\]
Comme nous l'énoncions précédement les types sont maintenant des termes, il nous faut donc ajouter une règle \emph{Nat}.

Pour continuer l'analogie avec la logique propositionnelle, on constate que la règle de typage de $\iter$ correspond à un raisonnement par
\emph{induction}. En effet on vérifie d'abord que l'argument \emph{a} est bien du type du prédicat dans le cas de zero. 
Puis l'on vérifie que la fonction \emph{f} est définie pour tout \emph{n} vers \emph{n + 1}.

Nous allons maintenant définir un $\lambda$-terme permettant d'effectuer l'addition de deux nombres avec l'aide dans une syntaxe
Lispienne (parsée par notre prototype) :
\begin{lstlisting}
  plus = (lambda n (lambda a 
           (iter (lambda x N) n 
                 (lambda ni (lambda x (succ x))) a)))
\end{lstlisting}
Pour effectuer l'addition \emph{n\:+\:m} la stratégie consiste à iterer \emph{n} fois la fonction successeur sur \emph{m}.
Afin d'aléger la syntaxe nous utiliserons dorénavant \lstinline!(+ n m)! correspondant au terme \emph{plus} appliqué aux entiers \emph{n} et
\emph{m}.

\paragraph{Implémentation :} 

Commençons par les règles de vérifications:
\codefrom{dependent}{lambda}{check_head}\lstinline!(...)!
\codefrom{dependent}{lambda}{check_nat}

Pour \emph{iter} si l'ensemble des des hypothèses sont vérifiées il nous faut retourner l'application
du prédicat $P$ sur $n$.
\codefrom{dependent}{lambda}{synth_iter}

Dans l'implémentation ~\ref{entier_type} nous n'avons pas présenté l'évaluation à grand pas des entiers naturels, 
voici donc le code correspondant:
\codefrom{dependent}{lambda}{big_step_nat}

Pour l'évaluation de \fun{iter} nous utilisons la meme techniques que pour 
l'application. On évalue l'ensemble des arguments puis on appelle la fonction \fun{vitter}
\codefrom{dependent}{lambda}{big_step_iter}

Le prédicat ne sert pas dans l'évaluation mais étant donné que l'on doit retourner 
un terme neutre si le terme contient des variables libres nous le gardons dans les arguments de la
fonction.
\codefrom{dependent}{lambda}{vitter}

\subsubsection{Les vecteurs}

Les vecteurs permettent d'introduire réellement de la dépendance de type. Nous avons vu une 
présentation assez informelle
des vecteurs afin de présenter les types dépendants, il sera donc question ici formaliser l'intuition de la
la Section~\ref{presentation_type_dependants}. 
Commençons par enrichire notre grammaire:

\newcommand{\vect}{\mathit{vec}} 
\newcommand{\dnil}{\mathit{dnil}}
\newcommand{\dcons}{\mathit{dcons}}
\newcommand{\dfold}{\mathit{dfold}}

\begin{bnf}
  t &::= & (\ldots) &\mbox{(termes vérifiables)} \\
  &|& \vect\:t\:t & \mbox{(type des vecteurs)} \\
  &|& \dnil\:t & \mbox{(vecteur vide)} \\
  &|& \dcons\:t\:t & \mbox{(concaténation)} \\
  s &::= & (\ldots) &\mbox{(termes synthétisables)} \\
  &|& \dfold\:t\:t\:t\:t\:t\:t & \mbox{(itérateur)}
\end{bnf}

Ce qui se traduit dans notre programme par le code suivant:
\codefrom{dependent}{lambda}{terme_vector}
\codefrom{dependent}{lambda}{terme_dfold}



Les arguments des différents constructeurs seront expliqué une fois que nous aurrons vu les 
règles de typage présente en figure \ref{fig:typage_vec}.
\begin{figure}
\[
\begin{array}{c}
  
  \inferrule[(Vec)]%
             {\Gamma\vdash * \ni \alpha\:\:\Gamma\vdash Nat \ni n}%
             {\Gamma\vdash * \ni Vec\: \alpha\:n }  
  \medskip\\

  \inferrule[(dnil)]%
            {\:}%
            {\Gamma\vdash Vec\:\alpha\:\zero \ni dnil\:\alpha}  
  \medskip\\
  \inferrule[(dcons)]%
            {\Gamma\vdash Vec\:\alpha\:n\ni v \:\:\Gamma\vdash \alpha\ni a}%
            {\Gamma\vdash Vec\:\alpha\:(\succs\:n)\ni dcons\:a\:v}  

\end{array}
\]
\label{fig:typage_vec}
\end{figure} 
 
 



Dans la règle \emph{vec} $\alpha$ sera donc le type des éléments contenus dans le vecteur et \emph{n} sa taille. 
Cette représentation des vecteurs n'est pas familière aux programmeurs, en général si l'on veut appliquer une fonction sur des vecteurs 
de taille précise il faut effectuer un test à l'entrée de la fonction. C'est un des aspects très intéressant des types dépendants qui
permettent d'assister les programmeurs dans la vérification de leurs programmes.


Le terme \emph{dnil} correspond au vecteur vide, et \emph{dcons} qui nous permet avec d'ajouter un élément dans un vecteur.
\begin{example}
  Voici un vecteur de taille trois et dont les éléments sont des entiers:
  \begin{align*}
    dcons\:zero\:(dcons\:(succ\:zero)\:(dcons\:zero\:(dnil\:Nat)))
  \end{align*}  
\end{example}

Nous pouvons maintenant créer des vecteurs mais nous ne possédons pas encore d'éliminateur pour les utiliser. Nous allons 
implémenter une fonction bien connue des programmeurs fonctionnels, dfold dont voici une définition intuitive:
\fun{dfold f vec b} $\rightarrow$ \fun{f a1 (f a2(...(f an b)...))}.
Définissons maintenant l'éliminateur dfold comme un terme synthétisable:

\[\begin{array}{c}
  \inferrule[(Dfold)]{\Gamma\vdash *\ni\alpha\:
    \Gamma\vdash Nat \ni n \\ 
    \Gamma\vdash \forall n:Nat.\forall v:Vec\:\alpha\:n.*\ni P \\
    \Gamma\vdash Vec\:\alpha\:n\ni v \\
    \Gamma\vdash \forall n:N.\forall v:Vec\:\alpha\:n.\forall a:\alpha.(P\:n\:v\rightarrow P\:(succ\:n)\:(dcons\:a\:v))\ni f}
            {\Gamma\vdash dfold\:\alpha\:P\:n\:v\:f\:a\in P\:n\:v}
\end{array}\]

De la meme manière que pour l'éliminateur des entiers naturels \emph{iter}, le prédicat \emph{p} nous permet 
de rendre le type de retour dépendant des différents arguments.

Il existe de nombreuses façon d'utiliser \emph{dfold}, une application assez simple consiste à faire la somme des éléments d'une liste.
Voici le terme correspondant à cette utilisation:
\begin{lstlisting} 
somme_liste = 
  (lambda v (lambda n 
    (dfold N (lambda n (lambda xs N)) n v
      (lambda n (lambda xs (lambda a (lambda x (+ a x))))) 
      zero)))
\end{lstlisting}

Voici donc le code du type-checker correpondant:
\begin{itemize}
   
\item[$\bullet$] \boxed{\cfrac{\Gamma\vdash * \ni \alpha\:\:\Gamma\vdash Nat \ni n}
  {\Gamma\vdash * \ni Vec\: \alpha\:n }\mbox{(Vec)}}\\
  
  Il nous faut vérifier les deux arguments du terme \fun{Vec}.
  %texte pour vec 
  \codefrom{dependent}{lambda}{check_vec}

  
\item[$\bullet$] \boxed{\cfrac{}
  {\Gamma\vdash Vec\:\alpha\:\zero\ni dnil\:\alpha}\mbox{(Dnill)}}\\
  Afin de vérifier le terme \emph{Dnill} il nous faut simplement vérifier que les terme $\alpha$
  sont égaux.  \todo{Le code match sur \fun{DNil(alpha)} mais c'est un entier n en fait}
  \codefrom{dependent}{lambda}{check_dnil}

\item[$\bullet$] \boxed{\cfrac{\Gamma\vdash Vec\:\alpha\:n\ni v \:\:\Gamma\vdash \alpha\ni a}
  {\Gamma\vdash Vec\:\alpha\:(succ\:n)\ni dcons\:a\:v}\mbox{(Dcons)}}\\
  %texte pour dcons
  \codefrom{dependent}{lambda}{check_dcons}


\item[$\bullet$] \boxed{  \inferrule[]{\Gamma\vdash *\ni\alpha\:
    \Gamma\vdash Nat \ni n \\ 
    \Gamma\vdash \forall n:Nat.\forall v:Vec\:\alpha\:n.*\ni P \\
    \Gamma\vdash Vec\:\alpha\:n\ni v \\
    \Gamma\vdash \forall n:N.\forall v:Vec\:\alpha\:n.\forall a:\alpha.(P\:n\:v\rightarrow P\:(succ\:n)\:(dcons\:a\:v))\ni f}
            {\Gamma\vdash dfold\:\alpha\:P\:n\:v\:f\:a\in P\:n\:v}\mbox{(Dfold)}}\\
  Il nous faut tout d'abord vérifier l'ensemble des hypothèses puis retourner l'application du terme $P$
  aux termes $n$ et $v$
  \codefrom{dependent}{lambda}{synth_dfold}

    
\end{itemize} 




\paragraph{Evaluation :} 
Avant d'implémenter l'évaluation dans notre programme il nous faut tout d'abord
rajouter les \emph{valeurs} suivantes à notre language.
\codefrom{dependent}{lambda}{Value_Vector}

Passons maintenant à l'évaluation des vecteurs, nos trois constructeurs 
n'ont pas d'évaluation particulière:
\codefrom{dependent}{lambda}{big_step_vec}

Si $dfold$ contient des variables libres il nous faut un élément neutre à retourner:
%
\codefrom{dependent}{lambda}{neutral_fold}

Pour l'implémentation, comme pour \iter, nous avons crée une fonction \fun{vfold}
qui nous permet d'éffectuer l'évaluation:

\codefrom{dependent}{lambda}{vfold}


\subsubsection{L'égalite} 

\newcommand{\equal}[3]{\ensuremath{#1 =_#2 #3}} 

Pour implémenter l'égalité au sein de notre language, il faut nous tourner vers la logique. 
La théorie des types implémente une définition de l'égalité proche de la conception de Leibniz : deux éléments sont identiques si ils ont les memes propriétés.
Pour que deux éléments soient égaux, il faut nécéssairements qu'ils soient de même type. Ce n'est pas une
conditions suffisante mais elle est nécéssaire. On notera \equal{a}{A}{b} l'égalité de deux élements de type $A$.
\begin{example}
  L'égalité sur les entiers s'écrit donc \equal{2 + 2}{N}{4}
\end{example}

Si l'on souhaite exprimer la même idée en logique nous écrirons : $Id(A,a,b)$.
Nous allons donc introduire les règles de typage du terme id ainsi que celle de son introducteur \emph{refl} 
et de son élimnateur \emph{Trans}.


\begin{itemize}
   
\item[$\bullet$] \boxed{\inferrule[(Id)]{\Gamma\vdash *\ni A \:\: \Gamma\vdash A \ni a \:\: \Gamma\vdash A \ni b }
  {\Gamma\vdash * \ni Id\:A\:a\:b}}\\
  Pour le terme $Id\:A\:a\:b$ il nous faut tout d'abord évaluer $A$ afin de pouvoir 
  vérifier les termes $a$ et $b$
  \codefrom{dependent}{lambda}{check_head} 
  \codefrom{dependent}{lambda}{check_id}

\item[$\bullet$] \boxed{\inferrule[(Refl)]{\Gamma\vdash A \ni a}
            {\Gamma\vdash Id\:A\:a\:a\ni refl\:a}}\\

  La spécification nous indique implicitement qu'il faut tester l'égalité entre les deux termes $a$. 
  Cependant c'est le point central de cette règle.
  Deux termes sont donc éqaux si leur évaluation est la meme et que l'on peut les vérifier 
  avec le type $A$.
  \codefrom{dependent}{lambda}{check_refl}
  
\item[$\bullet$] \boxed{\inferrule[(Trans)]{
    \Gamma\vdash * \ni A \\
    \Gamma\vdash A\ni a  \\
    \Gamma\vdash A \ni b \\
    \Gamma\vdash \forall a:A.\forall b:A.(Id\:A\:a\:b\rightarrow *) \\
    \Gamma\vdash Id\:A\:a\:b \ni q \\
    \Gamma\vdash P\:a\:a\:(refl\:a)\ni x}
  {\Gamma\vdash trans\:A\:P\:a\:b\:q\:x\in P\:a\:b\:q}}\\
  
  La relation de transitivité nous indique que si les éléments $a$ et $b$ sont égaux et que l'on peut vérifier
  que l'élément $x$ est vérifier alors celui est égale à $a$ et $b$.
  \codefrom{dependent}{lambda}{synth_head}
  \codefrom{dependent}{lambda}{synth_trans}
  
\end{itemize}


\subsection{Exemples de preuves}
\label{ex_preuves}

Dans la section \ref{corres_curry_howard} nous avons parlé de l'utilisation du vérificateur de types
pour assister la démonstration de propositions logiques. Nous allons étendre notre implémentation afin
de faciliter cette tâche.
Nous verrons ensuite un exemple de démonstration de la proposition 
``2 + 2 = 4'', qui était l'objectif initiale de ce projet.


\subsubsection{Amélioration du vérificateur}
\label{upgrade_type_check}

Dans les sections précédentes, afin que le code soit présentable, nous
avons présenté une version ``allégée'' de la fonction de
vérification. Cependant, nous avons également implémenté une
version plus complète comportant des messages d'erreurs précis.

Dans l'implémentation du \fun{type_checker} du $\lambda$-calcul simplement typé lorsqu'un terme n'était pas
correctement typé la fonction stoppait son éxecution par le moyen d'une exception.
Nos programmes devenant de plus en plus complexe, il peut etre intérressant de renvoyer un rapport detaillé
de l'echec. Voici la structure que nous allons utilisé:

\codefrom{dependent}{lambda}{debug}

Nous aurons aussi besoin des fonctions suivantes:
\begin{itemize} 
\item \fun{res_debug} : retourne le booléens présent dans le rapport.    
\item \fun{create_report} : créé un rapport en prenant un argument pour chaque champs du \fun{report}
\end{itemize}
L'équivalent de ces fonctions pour le type \fun{debug synth} sont suivis de \fun{_synth}.
Cette assistance est nécéssaire pour aider les programmeurs à connaitre la source de l'erreur,
tout comme le font les compilateurs modernes. Cela nous aide aussi pour tester la validité de celui 
ci car on peut maintenant tester si la vérification d'un terme est fausse.

\newcommand{\Hole}{\text{?\!?`\!?}}

Afin que notre vérificateur de type permette d'assister dans la recherche de preuves
nous allons implémenter un nouveau constructeur: $\Hole$.
Cette implémentation est un début, il existe de nombreuses autre extensions possibles
pour assister les démonstrations.

Le but de ce constructeur est d'interrompre la vérification de type et de demander au vérificateur de type de
retourner le type que l'on souhaite vérifier.
\begin{example}
  Soit le terme \fun{(lambda x ?)} que l'on veut vérifier avec le type \fun{(pi x nat bool)},
  le type checker enoncera le fait que à la place du terme $\Hole$ nous souhaitons un terme de type 
  booléens.
\end{example}

Nous allons donc rajouter ce terme parmis les termes vérifiables :
\codefrom{dependent}{lambda}{inTm_head} \lstinline!(...)!
\codefrom{dependent}{lambda}{what}

Etant donné que ce terme est simplement là pour améliorer l'utilisation de notre programme,
il ne possède pas de règles d'évaluation ou tout autre règles de calculs.
Dans notre type checker nous allons implémenter le code suivant:

\codefrom{dependent}{lambda}{check_what}

Nous acceptons quand meme le terme pour laisser la possibilité au programmeur de placer différents $\Hole$ dans son programme.

\subsubsection{2 + 2 = 4}

Atelons nous maintenant à notre première preuve. Nous avons désormais tout le bagage nécéssaire, 
les entiers et l'égalité.





\section*{Remerciements}

Merci à Pierre-Evariste Dagand d'avoir perdu quelques cheveux pour m'aider à mener à bien ce projet 
et à Frédéric Peschanski pour sa pédagogie.


















% pour l'implémentation quand je parle du parser ne pas montrer le code 
% mais expliquer la syntaxe lisp

% pour la prochaine introduction d'implémentation dire que la grosse nouveauté
% c'est le type checker et le fait que on 


%pour le simplement typé quand on introduit la première réduction on peut faire l'analogie avec le compilateur qui une fois que les
%termes on été type checker on peut maintenant oublier les types et maintenant réduire 



%Il faudrait que pour les booléens et tout ce genre de choses je fasse dans la partie formelle des spec correspondants aux evaluations ect..


%partie pour quand l'inspiration est partie

%pour introduire la fonctin d'égalité dans le type checker des types dépendants il faut dire que avant on pouvait comparer nos types directements avec la fonction d'égalité de ocaml car il n'y avait pas de variables dans nos types alors que maintenant oui

%Dans les types dépendants on pourra dire que l'on considère que nos termes sont des programmes 

%  pour l'agalité page 111 de thompson

%% * Outro

\clearpage

\bibliographystyle{abbrvnat}
\bibliography{prerapport.bib,rapport.bib}  

\end{document}

