\documentclass {article}

%% ** Packages

\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsthm, amssymb, amsmath}
\usepackage{hyperref}

%% ** OCaml listings

\usepackage{xcolor}
\usepackage{listings}
\lstset{
  language=[Objective]Caml,
  %% emph={[2]Nil,Cons,FZe,FSu,ze,su,Ze,Su},
  %% emphstyle={[2]\Constructor},
  %% emph={[3]lookup,failwith},
  %% emphstyle={[3]\Function},
  %% emph={[4]vec,fin,nat,list,tree,completeTree},
  %% emphstyle={[4]\Canonical},
  morecomment=[s]{(*}{*)},
  rangeprefix=\(\*\=,
  rangesuffix=\ \*\),
  includerangemarker=false,
  extendedchars=\true,
  inputencoding=utf8,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  basicstyle=\ttfamily\small,
  framesep=4mm,
  moredelim=*[s][\itshape]{(*}{*)},
  moredelim=[is][\textcolor{darkgray}]{§}{§},
  escapechar=°,
  keywordstyle=\color[rgb]{0.627451, 0.125490, 0.941176},
  stringstyle=\color[rgb]{0.545098, 0.278431, 0.364706},
  commentstyle=\color[rgb]{0.698039, 0.133333, 0.133333},
  numberstyle=\color[rgb]{0.372549, 0.619608, 0.627451},
  boxpos=t,
  literate= {'a}{{$\alpha$}}1%
    {->}{{${\to}$}}2
    {*}{{${\times}$}}1
    {::}{{${:\::}$}}1
}

\newcommand{\codefrom}[3]
           {\lstinputlisting[linerange={#3}-End]{../#1/#2.ml}}


%% ** Theorem styles 


\newtheorem{theorem}{Théorème}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemme}

\theoremstyle{definition}
\newtheorem{definition}{Définition}
\newtheorem{example}{Exemple}

\theoremstyle{remark}
\newtheorem{remark}{Remarque}
\newtheorem{para}{} 

%% ** commands

\newcommand{\todo}[1]{\textcolor{red}{#1}}
\newcommand{\attention}[1]{\textcolor{orange}{#1}}
\newcommand{\etc}{\textit{etc.}}

%% ** Title

\title{Implémentation de la théorie des types dépendants}
\author{Roman Delgado}
\date{}


\begin{document}

\maketitle


%% ** Abstract 


\begin{abstract} 
  Ce document représente l'ensemble du travail effectué durant l'unité d'enseignement 3I013 de l'upmc,
\end{abstract}

\tableofcontents

\clearpage

%% ** Main

\section{Introduction}

blablawsdsdfsdf


Voici du code :

%% \codefrom{dossier}{fichier}{tag}
%%   où 'dossier' est "no_type", ou "typed", ou "dependent"
%%      'fichier' est le chemin vers un fichier dans le dossier
%%      'tag' est une déclaration de la forme (*=tag *) (code) (*=End *) dans le source

\section{$\lambda$-calcul non typé}

En 1936, Alonzo Church introduit le lambda calcul non typé
(citation de church). Le $\lambda$-calcul est
un modèle de calcul universel, tout comme les machines de Turing. Celui-ci repose
sur une syntaxe minimaliste et permet de formaliser le concept de fonction. Il est au coeur de nombreuses recherches dans le domaine de la 
programmation fonctionnelle. Le lambda calcul non typé a connu un formidable 
succès pratique, donnant lieu à de multiples variantes dont on trouvera une présentation
 moderne et synthétique dans l'ouvrage de (citation pierce).

\todo{Ne pas attendre la fin pour mettre les citations bibtex. Faire ça au fur et à mesure.}

\subsection{Présentation formelle}

\subsubsection{Syntaxe}
Le lambda calcul \todo{écrire $\lambda$-calcul} est composé uniquement de \(\lambda\)-termes dont voici la syntaxe

\newcommand{\Lam}[2]{\ensuremath{\lambda #1. #2}}
\newcommand{\App}[2]{\ensuremath{#1\:#2}}
\newcommand{\Var}[1]{\ensuremath{#1}}

\todo{Utiliser les commandes \verb!Lam!, \verb!App! et \verb!Var!
  pour construire des $\lambda$-termes. Cela permet de changer
  rapidement la mise en forme par la suite, si besoin. Penser HTML \&
  CSS : il faut découpler au maximum le contenu de la présentation.}

\begin{align*}
  t &::= & \mbox{(lambda terme)} \\
  &|\quad \Var{x} & \mbox{(variable)} \\
  &|\quad \Lam{x}{t} & \mbox{(abstraction)} \\
  &|\quad \App{t}{t}          & \mbox{(application)}
\end{align*}

Pour faire une analogie avec les mathématiques, une abstraction peut
être vue comme une définition de fonction anonyme.
 
\begin{example}
 La fonction identité est définie par le lambda terme \todo{écrire \(\lambda\)-terme} suivant :
  %
  \[ 
  \lambda x. x
  \]
\end{example}

On peut constater avec cette syntaxe que les abstractions ne prennent
qu'un seul argument. Cependant, l'ensemble des fonctions à plusieurs
arguments peut etre représenté, par curryfication, à l'aide une
succession de fonctions à un seul argument.

\begin{example}
Le \(\lambda\)-terme  \(\lambda x y. t\) correspond au terme
\(\lambda x.\lambda y.t\)   
\end{example} 
Dans la suite de cet article nous utiliserons des fonctions à un seul
argument.

\subsubsection{Variables libres et variables liées}

\newcommand{\IsFree}{\mathrm{isFree}}

Une variable est liée lorsque celle ci est déclarée dans le corps d'un lambda, 
dans l'exemple précédent x était une variable liée. 
Si la variable n'a pas été déclarée, elle est dite libre. 

\todo{Définir formellement un prédicat \(\IsFree\) qui calcule (récursivement)
  l'ensemble des variables libres d'un \(\lambda\)-terme.}
  \begin{align*}
    \IsFree(x) &\triangleq ? \\
    \IsFree(\lambda x. t) &\triangleq ? \\
    \IsFree(f s) &\triangleq ? \\
  \end{align*}


\begin{example}
  Dans le terme suivant \(\lambda x.\lambda y.x\:y\:z\) , les variables \Var{x} et 
  \Var{y} sont liées tandis que la variable \Var{z} est libre 
\end{example}


Un terme ne contenant aucune occurrence de variable libre est dit ``clos''.
\begin{example}
  \label{example:ouvert-clos}
  Dans le lambda terme \((\lambda x. \lambda y. x\: y)\: y\), la
  variable \(x\) est liée ainsi que la première occurence de la
  variable \(y\). Cependant, la variable \(y\) à l'extérieur des
  parenthèse est libre.
\end{example}

\todo{Utilise \texttt{label} et \texttt{ref} pour faire des références
  en LaTex. Cf. \texttt{example:ouvert-clos} ci-dessous.}

Un des problèmes introduit par cette représentation des variables est qu'il devient assez compliqué de déterminer si une variable est libre ou non, comme on peut le constater dans l'exemple ci-dessus (Exemple~\ref{example:ouvert-clos}). \attention{Il faut donc introduire la notion d'\(\alpha\)-équivalence}.

\subsubsection{$\alpha$-équivalence}

\newcommand{\equivAlpha}{\mathop{\equiv_\alpha}}

On considère que deux termes sont alpha équivalents \todo{écrire ``\(\alpha\)-équivalents''} si et seulement si ils sont 
égaux au renommage de leur variables liées près. 
\begin{example}
  Voici deux termes alpha équivalents 
  \begin{align*}
    & \lambda x.x \equivAlpha \lambda y.y \\
  \end{align*}
\end{example}
  
\subsection{Calculer dans le lambda calcul}

Dans le lambda calcul pur, il n'existe pas de primitive pour effectuer des 
calculs. Le seul moyen de calculer de nouveaux termes est de les appliquer 
entre eux. Mais il nous faut tout d'abord définir le mécanisme de substitution par lequel se réalise la notion de calcul.

\subsubsection{Substitution}

\newcommand{\subst}[3]{#1[#2 := #3]}

\todo{Utiliser la ``command'' substitution.}

La substitution est un mécanisme central dans le lambda calcul. Cela consiste 
à remplacer l'occurrence d'une variable liée par un \(\lambda\)-terme.
On note généralement la substitution de la variable x \todo{attention à ne pas mettre de variables ``mathématiques'' dans le corps du texte, sans l'entourer du mode math. Ici on écrira \Var{x}, pas x.} dans le terme t par le 
terme u avec la notation suivante. 
\[ 
\subst{t}{x}{u}
\]

\todo{Donner la définition formelle de la substitution ici.}

\begin{example}
  \attention{Cet exemple est étrange. La substitution se fait \emph{sous} le lambda?!}

  Soit le terme \(\lambda\)x.x[x:=\(\lambda\)y.y], après avoir effectué la
  substitution nous obtenons le terme \(\lambda\)x.\(\lambda\)y.y
\end{example}


\todo{Cf. remarque au-dessus.} Nous avons analysé un cas de
substitution cependant on peut etre confronté à devoir substituer dans
une application ou une abstraction, voici donc les règles pour la
substitution \attention{Il y a 2 cas pour le lambda : on substitue
  \Var{x} et le binder est \Var{y} avec $\Var{x} \neq \Var{y}$, ou on
  substitue \Var{x} et le binder est \Var{x}}

\attention{$\leadsto$ n'est pas le bon symbole : on utilisera ce
  symbole pour définir la relation de réduction. Ici, on veut utiliser
  le même symbole que l'on utilise habituellement lorsque l'on définit
  un prédicat mathématique, comme $\IsFree$ plus tôt}

\begin{align*}
&(u v)[x := z]\leadsto(u[x := z] v[x := z]) \\
&(\lambda .t)[x := z]\leadsto\lambda .t[x := z] \\
\end{align*}

%je ne sais pas exactement quel titre donner a cette partie normalisation 
%ou reduction 
\subsubsection{$\beta$-réduction}

Seules les applications dont le membre de gauche est une abstraction
peuvent être réduites, on appelle cela une \emph{redex}.
\attention{Pas clair :} C'est à dire que l'application (t u) ne peut
pas etre réduite à moins que le terme t ne s'évalue en une
abstraction, (nous verrons ceci plus en détail dans la section
suivante). \todo{Au lieu d'une vague définition, donner la définition
  formelle de la $\beta$-réduction.}

\begin{example}
  Soit le terme ((\(\lambda\)x.\(\lambda\)y.y x) z).  Ce terme est
  sous la forme d'une application ayant une abstraction comme membre
  de gauche. La réduction consiste à substituer la variable liée par
  l'abstraction par le membre droit de l'application. On obtient donc \(\lambda\)x.\(\lambda\)y.z x
  \todo{Écrire \emph{tous} les termes dans le math mode, par exemple le dernier terme devrait être \(\Lam{x}{\Lam{y}{\App{z}{x}}}\)}
\end{example}

\begin{example}
  Voici un autre exemple de réduction
  \begin{align*}
    & ((\lambda x .\lambda y. z) w) \leadsto \lambda x.\lambda y.z \\
  \end{align*}
  Ici z étant une variable libre il n'y a rien à réduire.
\end{example}


\subsubsection{Stratégie de réduction : appel par nom}

Un terme est dit en \emph{forme normale} si on ne peut plus lui
appliquer de réduction. La normalisation consiste donc à reduire
autant que possible notre terme. \todo{Expliquer que l'on a le choix
  des rédex : il faut donc choisir une stratégie de
  réduction. Préciser que l'on ne s'intéresse qu'à une stratégie :
  l'appel par nom, qui est garantie de trouver la forme normale si
  elle existe}

%changer les fleches 
\begin{example}
  \todo{Texte pas clair}
  Le terme (((\(\lambda\)x.x) (\(\lambda\)y.y)) z) \(\leadsto\) ((\(\lambda\)y.y) y) 
\(\leadsto\) y %saut de ligne
  Ici y n'est plus réductible c'est donc la forme normale du terme.
\end{example}

Le lambda calcul étant un modèle de calcul universel, il permet de 
d'écrire des termes/programmes qui ne terminent pas : ceux-ci n'ont pas 
de forme normale. 

\begin{example}
 
  Le terme suivant n'admet pas de forme normale :
  %
  \begin{align*}
  (\lambda x. x\: x) (\lambda x. x\: x) &\leadsto (x x)[x \mapsto \lambda x. x\: x] \\
                                        &\leadsto (\lambda x. x\: x) (\lambda x. x\: x) \\
                                        &\leadsto \ldots \\
  \end{align*}
\end{example}
%je sais pas si cette partie la est judicieuse je pense que oui ça permet d'
%introduire un peu la suite du rapport 
Dans les sections suivantes, nous verrons lorsque nous introduirons
les systèmes de type que l'on peut ne considérer que des termes qui
réduisent vers une forme normale (c'est une des propriétés
intéressante offerte par les systèmes de type)

\attention{Question classique : si tu ne peux plus écrire de
  programmes qui ne terminent pas, tu n'es plus Turing complet donc tu
  es strictement moins expressif que tous les langages de
  programmation existants. Est-ce gênant ?}

\todo{Cf. ma remarque plus haut : faire remonter cette explication.}
Il existe de nombreuses stratégies de normalisation des termes dans le
lambda calcul non typé, les plus connues étant l'\emph{appel par nom}
et l'\emph{appel par valeur}.  Pour le lambda calcul non typé la
stratégie la plus sûre \todo{``sûr'' n'est pas le mot le plus
  adapté. Sois plus précis.} est la call by value \todo{utiliser le
  terme français : appel par valeur}.  En effet, elle consiste à
réduire seulement le terme de gauche des redex, et où l'on ne reduit
pas à l'intérieur des abstractions. \todo{Donner la définition
  formelle de la réduction appel par valeur} Pour certains termes, on
ne peut pas atteindre une forme normale, cependant celle ci a moins de
risque \todo{``moins de risque'' n'est pas une définition
  formelle. Donner une explication plus précise.} de rentrer dans une
boucle d'évaluation infinie. Nous n'avons pas encore les propriétés
offertes par les systèmes de types qui garantirait qu'un terme bien
typé admet toujours une forme normale.

\begin{example}
  Voici un exemple d'évaluation avec la stratégie call by value
  \begin{align*}
    & ((\lambda x.\lambda y. x\: y)\: \lambda w.w)  \\
    \leadsto & (\lambda y. (\lambda w.w)\: y) 
  \end{align*}
\end{example}





\subsection{Enrichir le lambda calcul}

\attention{Ce n'est pas vraiment un ``enrichissement'' : toutes ces
  fonctionnalités existent déjà dans le calcul. Ce sont plutôt des
  ``encodages'' d'objets familiers dans le lambda calcul.}

Maintenant que le noyau de notre language a été défini, nous pouvons
introduire de nouvelles \todo{``nouvelles'' n'est pas le bon terme}
constructions qui vont nous permettre d'exprimer des concepts
familiers aux développeurs, tels que les entiers, les booléens, \etc

\subsubsection{Les booléens de Church}

\newcommand{\True}{\ensuremath{\mathrm{true}}}
\newcommand{\False}{\ensuremath{\mathrm{false}}}
\newcommand{\Ifte}{\ensuremath{\mathrm{ifte}}}

Nous allons ici voir une représentation des booléens accompagnée de la 
structure de contrôle \texttt{if ... then ... else ...}.
Voici les termes correspondants aux constructeurs True et False
\begin{align*}
  \True &\triangleq \lambda x.\lambda y. y  \\
  \False &\triangleq \lambda x.\lambda y. x
\end{align*}

\todo{Définir \Ifte immédiatement, histoire de rendre le paragraphe suivant compréhensible.}

On assimile ces deux termes aux booléens True \todo{comme toujours, écrire ces termes dans le math mode} et False car leur calcul au sein
de l'application d'un Ifte reproduit le comportement attendu.
Nous pouvons désormais introduire le terme correspondant à la structure de 
controle IfThenElse.
\begin{align*}
  \Ifte &\triangleq \lambda x.\lambda y.\lambda z. x\: y\: z  \\
\end{align*}

\begin{example}
  Voici un exemple de réduction du terme Ifte \todo{Mettre des variables nommées (et les étapes intermédiaires)}
  \begin{align*}
    &(\lambda .\lambda .\lambda . 2\: 1\: 0) \: (\lambda . \lambda . 0) \: x \: y  \\
    & %TODO:mettre les étapes intermediaires \\
    % & x 
  \end{align*}
\end{example}

Ici nous n'avons aucun moyen de vérifier avant normalisation que le premier
argument de Ifte est un booléen. \todo{Bof, je ne sais pas ce que cette remarque apporte} %broder un peu plus ?

\todo{Tu pourrais faire une petite remarque sur l'encodage objet des
  booléens, qui est effectivement utilisé dans des langages purement
  objets comme Self, Smalltalk ou Pharo.}

\subsubsection{Les entiers de Church}

Ici, nous allons voir comment créer
les entiers naturels \textit{ex nihilo} en utilisant un \emph{encodage à
  la Church}.

L'idée consiste à représenter le nombre \(n\) par une fonction d'ordre
supérieur prenant en argument une fonction \Var{f} et l'appliquant \(n\)
fois à un argument \Var{x}. On définira donc 
%
\begin{align*}
\mathsf{zero} &= \lambda f. \lambda x. x \\
\mathsf{un}   &= \lambda f. \lambda x. f\: x \\
\mathsf{deux} &= \lambda f. \lambda x. f\: (f\: x)
\end{align*}

Afin de construire tous les entiers naturels, on s'inspire alors de la
définition des entiers de Peano et définit le successeur d'un nombre \(n\)
comme
%
\[
\mathsf{successeur} = \lambda n. \lambda f. \lambda x. n\: f\: (f\: x)
\]
%
c'est-à-dire \(n\) applications de \(f\) précédées d'une première
application de \(f\), soit \(n+1\) applications.

De la même manière, on construit l'addition de deux nombres \(m\) et
\(n\) en faisant \(m\) applications répétées de \(f\) précédées par
\(n\) applications :
%
\[
\mathsf{plus} = \lambda m. \lambda n. \lambda f. \lambda x. m f (n f x)
\]


\subsection{Implementation}

Nous nous attarderons ici sur les choix d'implémentations et il sera question
d'analyser certaines parties du code et non sa totalité.

\subsubsection{Représentation des lambda termes}
%ici j'ai enlever la partie indices de de bruijn je la met ici mais je ne sais pas si le titre est bien 
 
Pour pallier au problème que nous énoncions précédement \todo{faire
  une référence explicite avec un \verb!label!/\verb!ref!}, nous
utilisons une représentation particulière pour les variables liées:
les indices de de Bruijn.  Nous allons ainsi représenter les variables
liées non pas par un nom mais par un entier naturel. \todo{Expliquer à
  quoi correspond l'entier naturel, sinon on ne comprend pas ton
  exemple.}

\begin{example}
  Le lambda terme représentant l'identité, que l'on écrivait \(\lambda x.x\), est représenté par \(\lambda.0\)
\end{example}

\todo{Avant de donner la définition OCaml, il faut aussi introduire la
  représentation des variables libres et donc citer les papiers
  standards sur la représentation ``locally nameless''}

\todo{Phrase un peu vague :} Pour représenter les types en Ocaml les
types sommes sont très intéressants car ils offrent une manipulation
souple à l'aide du pattern matching. \todo{Tu peux simplement dire de
  traduire naturellement la définition inductive des termes que tu
  avais donné dans le monde formel.}

\codefrom{untyped}{lambda}{untyped_term}

\todo{Il serait super cool de faire des références de l'implémentation
  vers la définition formelle. Tu pourrais utiliser une ``footnote''.}

Cette représentation se rapproche au plus de la spécification
formelle, seule la distinction entre les variables liées (BoundVar
\todo{comme pour les specs formels, ne pas écrire du code en mode
  normal. Écrire \lstinline!BoundVar! au lieu de BoundVar.}) et les
variables libres (FreeVar) diffère du fait que l'\attention{on utilise
  désormais la représentation avec les indices de de
  Bruijn}. \todo{C'est plus que ça : avoir \lstinline!FreeVar!
  signifie que tu es locally nameless, ce qui est plus que de Bruijn}.


\subsubsection{Parsing et pretty printing}
\todo{Phrase très longue :}
Afin de permettre de construire des termes rapidement et le plus lisible 
possible la création d'un parseur s'imposait.
La notation choisie a été la notation préfixe (notation polonaise inversée),
une syntaxe très proche du langage lisp qui en plus d'etre simple à comprendre
est assez facile à parser (à l'aide des bibliothèques de S-expression)
\begin{example}
  Voici un exemple de correspondance entre les termes avant et après parsing
  \begin{align*}
    (lambda\: x \: x) & \leadsto Abs(BoundVar\: 0) \\
    (x\: y) & \leadsto Appl(FreeVar\: 'x',FreeVar\: 'y')       
  \end{align*}
\end{example}

Comme on peut le constater dans l'exemple pour alléger la redaction des termes,
on utilise une représentation des variables classiques, c'est dans le parseur que 
l'on determine la valeur de l'indice d'une variable si celle ci est liée et son 
nom si celle ci est libre.
%Changer la derniere formulation
Pour l'affichage de nos termes on effectue l'opération inverse, c'est à dire que
les chaines de caractères en sortie seront elle memes des S-expressions.



\subsubsection{substitution}

On découvre ici un nouvel avantage de notre représentation avec les indices de
de Bruijn, car il n'est pas nécessaire de prendre des précautions quant au
nom des variables de notre terme substituant % à changer
qui rendrait liée une variable qui était libre. Cela nous permet de ne pas 
avoir besoin d'introduire l'\(\alpha\) convertion

\begin{example}
  Avec la représentation classique: 
  \[ 
  \lambda x.x[x := \lambda y.x]\leadsto\lambda x.\lambda y.x
  \]
  Avec les indices de de bruijn
  \[ 
  \lambda.0[0 := \lambda.x]\leadsto\lambda.\lambda.x
  \]
  On constate bien que dans la première représentation on pense que la variable
  x est liée alors que celle ci devrait en réalité etre libre comme dans la 
  représentation avec les indices de de Bruijn.
\end{example}


\codefrom{untyped}{lambda}{substitution}

L'argument \emph{term} correspond au terme dans lequel on va substituer le terme \emph{tsub} et 
l'argument \emph{var} est un entier qui va nous permettre de compter le nombre de binder \(\lambda\)
traversés. Si l'on recontre une BoundVar avec comme indice var on retourne donc \emph{tsub} à la 
place de celle ci.


\subsubsection{Reduction et évaluation}
La fonction de réduction consiste donc à trouver des redex afin de substituer le 
membre de droite de l'application dans le membre de gauche. Nous appelons la fonction
de réduction avec la valeur 0 car on souhaite substituer l'ensemble des variables
du binder \(\lambda\) en cour.

\codefrom{untyped}{lambda}{reduction}

Nous disposons de l'ensemble des fonctions nécéssaires afin de faire une évaluation 
correspondant à la stratégie d'évaluation call bu value. En voici une implémentation
possible:

\codefrom{untyped}{lambda}{evaluation}

Si l'on trouve une redex on reduit puis l'on evalue le resultat de la reduction,
et si le membre de gauche n'est pas une variable on evalue celui ci pour determiner
si celui ci peut nous donner une abstraction afin de pouvoir effectuer une réduction.
Conformément à la stratégie on n'évalue jamais le membre de gauche d'une application
pour les raisons énoncées dans la section d'évaluation.


\subsubsection{Les booléens}
Afin d'implémenter les boléens dans notre language un choix d'implémentation 
possible est de simplement définir de nouveaux termes True,False et Ifte
comme nous l'avons vu dans la section précédente. Cependant nous avons choisi 
d'enrichir le noyau de notre language en créant trois nouveaux constructeurs.
Cela permet de ne pas alourdir l'écriture de certains termes ainsi que 
d'améliorer la représentation et d'automatiser des opérations d'évaluation.

\codefrom{untyped}{lambda}{bool_term}

Pour la substitution des termes \emph{True} et \emph{False} les règles 
sont triviales. Pour le terme \emph{IfThenElse} il faut rappeler la 
fonction de substitution sur l'ensemble des arguments du constructeur.
Il n'est pas nécéssaire d'incrémenter la valeur de \emph{var} étant donné
que ce constructeur ne lie aucune variables.

\codefrom{untyped}{lambda}{bool_substitution}

Pour la réduction il n'y à pas de réduction possible pour nos termes
ce qui reviens donc a retourner le terme sans aucunes modifications.


Voici enfin la section correspondant à l'évaluation des booléens.
Encore une fois True et False s'évaluant simplement en True et False ils
ne représentent aucune difficulté d'implémentation. En ce qui concerne
le terme \emph{IfThenElse} si le premier argument est \emph{True}
on retourne alors le second argument et on retourne le troisième argument 
dans le cas où la condition serait un \emph{False}. Dans le cas 
où le premier argument ne sera pas un booléens on evalue celui ci pour 
essayer d'obtenir un booléens qui nous permettrait d'évaluer notre 
terme.

\codefrom{untyped}{lambda}{bool_evaluation}


\subsubsection{Les entiers}

Tout comme pour les booléens nous allons ajouté les trois constructeurs 
\emph{Zero},\emph{Succ} et \emph{Iter} à notre language.

\codefrom{untyped}{lambda}{nat_term}

Pour ce qui est de la substitution et la réduction le comportement est très
similaire à celui des boléens et ne nécessite pas d'explications supplémentaires.
%mettre un petit saut a la ligne 
Substitution:

\codefrom{untyped}{lambda}{nat_substitution}

Reduction:

\codefrom{untyped}{lambda}{nat_reduction}

En revanche l'évaluation du terme \emph{Iter(n,f,a)} est déja plus intéressante.
Si le premier argument est \emph{Zero} alors il faut retourner le terme \emph{a}.
Si \emph{n} est un \emph{Succ(num)} alors il faut d'abord evaluer l'application 
\emph{(f a)}. puis rappeler la fonction d'évaluation avec le terme 
\emph{Iter} avec ces nouveaux arguments.

\codefrom{untyped}{lambda}{nat_evaluation}

\section{Le lambda calcul simplement typé}

\section{Les types dépendants}

% pour l'implémentation quand je parle du parser ne pas montrer le code 
% mais expliquer la syntaxe lisp

% pour la prochaine introduction d'implémentation dire que la grosse nouveauté
% c'est le type checker et le fait que on 


%pour le simplement typé quand on introduit la première réduction on peut faire l'analogie avec le compilateur qui une fois que les
%termes on été type checker on peut maintenant oublier les types et maintenant réduire 



%Il faudrait que pour les booléens et tout ce genre de choses je fasse dans la partie formelle des spec correspondants aux evaluations ect..

\end{document}
