\documentclass {article}

%% ** Packages

\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsthm, amssymb, amsmath}
\usepackage{hyperref}
\usepackage{mathpartir}

%% ** OCaml listings

\usepackage{xcolor}
\usepackage{listings}
\lstset{
  language=[Objective]Caml,
  %% emph={[2]Nil,Cons,FZe,FSu,ze,su,Ze,Su},
  %% emphstyle={[2]\Constructor},
  %% emph={[3]lookup,failwith},
  %% emphstyle={[3]\Function},
  %% emph={[4]vec,fin,nat,list,tree,completeTree},
  %% emphstyle={[4]\Canonical},
  morecomment=[s]{(*}{*)},
  rangeprefix=\(\*\=,
  rangesuffix=\ \*\),
  includerangemarker=false,
  extendedchars=\true,
  inputencoding=utf8,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  basicstyle=\ttfamily\small,
  framesep=4mm,
  moredelim=*[s][\itshape]{(*}{*)},
  moredelim=[is][\textcolor{darkgray}]{§}{§},
  escapechar=°,
  keywordstyle=\color[rgb]{0.627451, 0.125490, 0.941176},
  stringstyle=\color[rgb]{0.545098, 0.278431, 0.364706},
  commentstyle=\color[rgb]{0.698039, 0.133333, 0.133333},
  numberstyle=\color[rgb]{0.372549, 0.619608, 0.627451},
  boxpos=t,
  literate= {'a}{{$\alpha$}}1%
    {->}{{${\to}$}}2
    {*}{{${\times}$}}1
    {::}{{${:\::}$}}1
}

\newcommand{\codefrom}[3]
           {\lstinputlisting[linerange={#3}-End]{../#1/#2.ml}}


%% ** Theorem styles 


\newtheorem{theorem}{Théorème}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemme}

\theoremstyle{definition}
\newtheorem{definition}{Définition}
\newtheorem{example}{Exemple}

\theoremstyle{remark}
\newtheorem{remark}{Remarque}
\newtheorem{para}{} 

%% ** commands

\newcommand{\todo}[1]{\textcolor{red}{#1}}
\newcommand{\attention}[1]{\textcolor{orange}{#1}}
\newcommand{\etc}{\textit{etc.}}

\newenvironment{bnf}
               {\[\begin{array}{lcl@{\qquad}r}}
               {\end{array}\]}

\newcommand{\fun}[1]{\lstinline!#1!}
%% ** Title

\title{Implémentation de la théorie des types dépendants}
\author{Roman Delgado}
\date{}


\begin{document}

\maketitle


%% ** Abstract 


\begin{abstract} 
  Ce document représente l'ensemble du travail effectué durant l'unité d'enseignement 3I013 de l'\textsc{upmc}. \attention{Cet abstract n'apporte pas grand chose : le supprimer ?}
\end{abstract}

\setcounter{tocdepth}{2}
\tableofcontents

\clearpage

%% ** Main

\section{Introduction}

\todo{Utilise ``ispell'' pour la correction orthographique.}
\todo{Remplace ``analyseur de type'' à la place de ``type checker''}

\attention{Introduction la plus bateau et alambiquée du monde :} Les languages de programmation sont des outils d'abstraction de plus en plus répandus. Cependant leur utilisation n'est pas possible 
sans un certains nombres de logiciels. Le compilateur est le logicielle centrale car c'est lui qui définit l'ensemble des 
composantes du language.

\attention{Parti pris pas inintéressant : présenter la chaîne de
  compilation d'un langage et se concentrer sur le typage. Pourquoi
  pas.}

Il sera donc question dans ce rapport de comprendre le typage, une des étapes de la chaine de compilation.
Pour résumé brievement le compilateur 
traduit d'abord le texte écris par le programmeur en un arbre de syntaxe abstraite. Cette représentation est ensuite analysable 
par un programme. %bof
Si le compilateur ne génère pas d'erreur durant cette étape on dit que le programme est syntaxiquement correcte. Cependant 
le programmeur à pu écrire des instructions tels que ``x = 2 + true''. Meme si cette instruction est syntaxiquement correcte, celle ci 
n'a aucun sens. Il lui faut maintenant à partir de l'arbre de syntaxe abstraite générer du code assembleur, un code compréhensible 
par les microprocesseurs. Le compilateur peut très bien générer une suite d'instructions assembleurs correspondant à l'expression 
précédente, c'est durant l'execution du programme que le processeur va interompre le programme. Lorsque ces erreurs surviennent il est 
très compliqué de trouver la source de celle ci car l'instruction fautive ne correspond pas au code écrit par le programmeur. 
Pour évitez ce genre d'erreurs qui peuvent survenirs très longtemps après le lancement du programme (les serveurs par exemple), 
il nous faut donc vérifier la validité de celui ci. Il faut donc rajouter une étape dans la chaine de compilation grace au typage 
assuré par le type-checker.
L'intéret du typage est donc de vérifier que le programme s'executera correctement, sans avoir besoins d'éxecuter celui ci. 
Il permet aussi d'obtenir des informations très précises sur la sources des erreurs.

\section{$\lambda$-calcul non typé}

\todo{Remplacer tous les ``lambda''s par ``$\lambda$''}

En 1936, Alonzo Church introduit le lambda calcul non typé
~\citep{church:lambda-calcul}. Le $\lambda$-calcul est
un modèle de calcul universel, tout comme les machines de Turing. Celui-ci repose
sur une syntaxe minimaliste et permet de formaliser le concept de fonction. Il est au coeur de nombreuses recherches dans le domaine de la 
programmation fonctionnelle. Le lambda calcul non typé a connu un formidable 
succès pratique, donnant lieu à de multiples variantes dont on trouvera une présentation
 moderne et synthétique dans l'ouvrage de ~\citet{pierce:tapl}.


\subsection{Présentation formelle}

\subsubsection{Syntaxe}
Le $\lambda$-calcul est composé uniquement de \(\lambda\)-termes dont voici la syntaxe

\newcommand{\Lam}[2]{\ensuremath{\lambda #1. #2}}
\newcommand{\App}[2]{\ensuremath{#1\:#2}}
\newcommand{\Var}[1]{\ensuremath{#1}}

\todo{Utiliser l'environement \texttt{bnf}}
\begin{align*}
  t &::= & \mbox{(lambda terme)} \\
  &|\quad \Var{x} & \mbox{(variable)} \\
  &|\quad \Lam{x}{t} & \mbox{(abstraction)} \\
  &|\quad \App{t}{t}          & \mbox{(application)}
\end{align*}

Pour faire une analogie avec les mathématiques, une abstraction peut
être vue comme une définition de fonction anonyme.
 
\begin{example}
 La fonction identité est définie par le $lambda$-terme suivant : $\Lam{x}{\Var{x}}$
\end{example}

On peut constater avec cette syntaxe que les abstractions ne prennent
qu'un seul argument. Cependant, l'ensemble des fonctions à plusieurs
arguments peut etre représenté, par curryfication, à l'aide une
succession de fonctions à un seul argument.

\begin{example}
  \label{example:id}
  Le \(\lambda\)-terme $\Lam{x\: y}{t}$ correspond au terme $\Lam{x}{\Lam{y}{t}}$  
\end{example} 

Dans la suite de cet article nous utiliserons des fonctions à un seul
argument.

\subsubsection{Variables libres et variables liées}

\newcommand{\IsFree}{\mathrm{isFree}}


\todo{Type-setter les termes nouvellement introduits avec
  \texttt{$\backslash$emph\{..\}}. Par exemple, ``liée'', ``libre'' et
  ``clos''.}

Une variable est liée lorsque celle ci est déclarée dans le corps d'un
lambda, dans l'Exemple~\ref{example:id}, $x$ était une variable liée.
Si la variable n'a pas été déclarée, elle est dite
libre. Formellement, l'ensemble des variables libres d'un terme est
défini récursivement de la façon suivante
%
\begin{align*}
  \IsFree(x) &\triangleq \{x\} \\
  \IsFree(\lambda x. t) &\triangleq \IsFree(t) \backslash \{x\} \\
  \IsFree(f s) &\triangleq \IsFree(f) \cup \IsFree(s) \\
\end{align*}


\begin{example}
  Dans le terme suivant \(\Lam{x}{\Lam{y}{\App{\App{\Var{x}}{\Var{y}}}{\Var{z}}}}\), 
  les variables $\Var{x}$ et $\Var{y}$ sont liées tandis que la variable $\Var{z}$ est libre 
\end{example}


Un terme ne contenant aucune occurrence de variable libre est dit \emph{clos}.

\begin{example}  
  \label{example:ouvert-clos}  
  Dans le $\lambda$-terme \App{(\Lam{x}{\Lam{y}{\App{x}{y}}})}{\Var{y}}, la
  variable \Var{x} est liée ainsi que la première occurence de la
  variable \Var{y}. Cependant, la variable \Var{y} à l'extérieur des
  parenthèse est libre.
\end{example}

\begin{remark}
\label{problemelibreliee}
\attention{Non, ce n'est pas ça le problème. Le problème, c'est que, a
  priori, \Lam{\Var{x}}{\Var{x}} et \Lam{\Var{y}}{\Var{y}} sont des
  termes distincts à cause du nom de variable différent alors que ce
  sont moralement les deux mêmes termes}
Un des problèmes introduit par cette représentation des variables est qu'il devient assez compliqué de déterminer si une variable est libre ou non, comme on peut le constater dans l'exemple ci-dessus (Exemple~\ref{example:ouvert-clos}). Il faut donc introduire la notion 
d'$\alpha$-équivalence.
\end{remark}

\subsubsection{$\alpha$-équivalence}
\label{alpha_equiv}

\newcommand{\equivAlpha}{\mathop{\equiv_\alpha}}

On considère que deux termes sont \(\alpha\)-équivalents si et seulement si ils sont 
égaux au renommage de leur variables liées près. 
\begin{example}
  Voici deux termes alpha équivalents 
  \begin{align*}
    & \Lam{x}{\Var{x}} \equivAlpha \Lam{y}{\Var{y}} \\
  \end{align*}
\end{example}

\subsubsection{Représentation concrète}
 
Pour pallier à la Remarque~\ref{problemelibreliee}, notre implémentation utilise une représentation
particulière pour les variables liées: les indices de de Bruijn.  Nous
allons ainsi représenter les variables liées non pas par un nom mais
par un entier naturel. Cette valeur est determiné à partir du nombre
d'abstractions entre la variable et l'abstraction qui l'introduit.

\begin{example}
  Le $\lambda$-terme représentant l'identité, que l'on écrivait \(\lambda x.x\), est représenté par \(\lambda.0\)
  et le terme $\Lam{x}{\Lam{y}{x}}$ s'écrira maintenant $\lambda.\lambda.1$ 
\end{example}

Tandis que les variables \emph{liées} seront representées par des
indices de de Bruijn, les variables \emph{libres} quant à elle seront
représentées par un (unique) nom de variable, comme dans la
présentation formelle. Une telle représentation est traditionnellement
appelée ``locally nameless''~\citep{chargueraud:locally-nameless}

\begin{example}
  \todo{Donner l'exemple de réduction sous un binder}
  Soit \Var{x} une variable libre.

  En théorie :
  \(\App{(\Lam{\Var{y}}{\Var{y}})}{\Var{x}} \leadsto \Var{x}\)

  En pratique avec des de Bruijn : \todo{montrer le problème et parler des shifts}

  En pratique avec du locally nameless : \todo{montrer l'absence de problème}

\end{example}

Voici le code Ocaml traduisant la définition inductive des termes que
nous avions définis :
%
\codefrom{untyped}{lambda}{untyped_term}

Cette représentation se rapproche au plus de la spécification formelle
: seule la distinction entre les variables liées \lstinline!BoundVar!
et les variables libres \lstinline!FreeVar! diffère.



  
\subsection{Calculer dans le lambda calcul}
\label{calculer_dans_le_lambda_calcul}

Dans le lambda calcul pur, il n'existe pas d'opérations primitives, comme l'addition ou la multiplication d'entiers. Le seul moyen de calculer de nouveaux termes est de les appliquer 
entre eux. Mais il nous faut tout d'abord définir le mécanisme de substitution par lequel se réalise la notion de calcul.

\subsubsection{Substitution}

\newcommand{\subst}[3]{#1[#2 := #3]}


La substitution est un mécanisme central dans le lambda calcul. Cela consiste 
à remplacer l'occurrence d'une variable liée par un \(\lambda\)-terme.
On note \(\subst{t}{x}{u}\) la substitution de la variable $\Var{x}$ dans le terme $\Var{t}$ par le 
terme u.

Formellement, la substitution est définie par récursion sur le $\lambda$-terme : \attention{cette définition est fausse !}
\begin{align*}
    \subst{x}{x}{u} &\triangleq u \\
    \subst{x}{y}{u} &\triangleq x & (x \neq y)\\
    \subst{\lambda x.t}{x}{u} &\triangleq \lambda x.\subst{t}{x}{u} \\
    \subst{\lambda y.t}{x}{u} &\triangleq \lambda x.t \\
    \subst{(t\: v)}{x}{u} &\triangleq \subst{t}{x}{u}\: \subst{v}{x}{u}
\end{align*}

\begin{example}
  Soit le terme $\Lam{x}{\subst{x}{x}{\Lam{y}{y}}}$, après avoir effectué la
  substitution nous obtenons le terme $\Lam{x}{\Lam{y}{\Var{y}}}$.
  \attention{Non, surtout pas !}
\end{example}


\paragraph{Implémentation :}
Implémentons donc la substitution dans notre programme: \todo{Il va
  falloir être plus descriptif : pourquoi tu incrémentes
  \lstinline!var! dans le cas \lstinline!Abs!? Pourquoi c'est la
  \lstinline!BoundVar v! pour \lstinline!v = var! que tu substitues ?
  Ne jette pas le code en pâture au lecteur. Suggestion : } La
substitution de la variable liée \lstinline!var! par le terme
\lstinline!tsub! dans \lstinline!term! est implémentée par :
%
\codefrom{untyped}{lambda}{substitution}

L'argument \emph{term} correspond au terme dans lequel on va substituer le terme \emph{tsub} et 
l'argument \emph{var} est un entier qui va nous permettre de compter le nombre de binder \(\lambda\)
traversés. Si l'on recontre une BoundVar avec comme indice var on retourne donc \emph{tsub} à la 
place de celle-ci.

\begin{example}
\todo{Dérouler l'exécution de cette fonction sur un exemple concret.}
\end{example}

\begin{proposition}
  \todo{Énoncer le lien entre l'implémentation et la spécification formelle.}
\end{proposition}


\subsubsection{$\beta$-réduction}
\label{reduction}


Seules les applications de la forme \(\App{(\Lam{\Var{x}}{t})}{u}\),
dont le membre de gauche est une abstraction, peuvent être réduites :
un tel terme s'appelle un
\emph{redex}~\citep{krivine:lambda-calculus}. Le terme
\(\subst{t}{x}{u}\), obtenu après réduction, est appelé son
\emph{contracté}.

\begin{example}
  Le terme \(\App{(\Lam{x}{x})}{u}\) est \attention{``un'' redex, pas ``une''} un redex tandis que le terme
  \(\App{x}{u}\) n'en est pas un.
\end{example}

\newcommand{\Red}{\leadsto}
\newcommand{\Conv}{\leadsto^{*}}

Formellement, on définit la \(\beta\)-réduction par induction sur les
termes :
\[\begin{array}{c}
  \inferrule{{}}
            {\App{(\Lam{\Var{x}}{t})}{u} \Red \subst{t}{x}{u}}
  \medskip\\
  \inferrule{t \Red t'}%
            {\Lam{\Var{x}}{t} \Red \Lam{\Var{x}}{t'}}
  \medskip\\
  \inferrule{t \Red t'}
            {\App{t}{u} \Red \App{t'}{u}}
  \medskip\\
  \inferrule{u \Red u'}
            {\App{t}{u} \Red \App{t}{u'}}
\end{array}\]

On obtient la \(\beta\)-conversion en prenant la clôture reflexive et
transitive \(t \Conv t'\) de la \(\beta\)-réduction : on a \(t \Conv
t'\) s'il existe une suite de \(\beta\)-réductions telles que \(t \Red
\ldots \Red t'\).

\begin{example}
  Soit le terme \attention{problème de parenthèse} \(\App{\Lam{x}{\Lam{y}{\App{y}{x}}}}{z}\).  Ce terme est
  sous la forme d'une application ayant une abstraction comme membre
  de gauche. La réduction consiste à substituer la variable liée dans
  la première abstraction par le membre droit de l'application. On obtient donc 
   \(\Lam{x}{\Lam{y}{\App{z}{x}}}\)
\end{example}

\begin{example}
  Voici un autre exemple de réduction
  \todo{Écrire avec les macros App, Lam, Var}
  \begin{align*}
    & (\lambda x .\lambda y. y) w \leadsto \lambda y.y \\
  \end{align*}
  \Var{x} n'étant pas utilisé dans la fonction, l'argument \Var{w} disparaît complètement.
\end{example}


\subsubsection{Stratégie de réduction : appel par nom}

\label{reduction:call_by_name}
Un terme est dit en \emph{forme
  normale} si on ne peut plus lui
appliquer de réduction: il ne contient aucun redex. La \emph{normalisation}
consiste à reduire autant que possible notre terme. En
particulier, on caractérise inductivement les formes normales de la
façon suivante :
%
\begin{itemize}
\item Une variable \(\Var{x}\) est en forme normale ;
\item Si \(t\) est en forme normale, alors \(\Lam{\Var{x}}{t}\) est en
  forme normale ;
\item Si \(t\) et \(u\) sont en formes normales et que \(u\) n'est pas
  une abstraction, alors \(\App{t}{u}\) est en forme normale.
\end{itemize}

On en déduit qu'un terme est en forme normale si et seulement s'il est
de la forme
\(\Lam{\Var{x_0}}\ldots\Lam{\Var{x_k}}\App{\App{\App{x_i}{t_0}}{\ldots}}{t_l}\)
où les \(t_j\) sont eux-mêmes des termes normaux.

\begin{example}[Terme en forme normale]
  \todo{\(\Lam{\Var{x}}{\Var{x}}\)}
\end{example}

On dira qu'un terme \(t\) est \emph{normalisable} s'il existe un terme
normal \(t'\) tel que \(t \Conv t'\). Un terme \(t\) est
\emph{fortement normalisable} s'il n'existe aucune suite infinie de
réduction à partir de \(t\). Un terme fortement normalisable est,
\textit{a fortiori}, un terme normalisable.

\begin{example}[Terme non normalisable]
  \todo{\(\omega = \Lam{\Var{x}}{\App{(\App{x}{x})}{(\App{x}{x})}}\)}
\end{example}

\begin{example}[Terme normalisable mais pas fortement normalisable]
  \todo{\(\App{(\Lam{\Var{x}}{0})}{\omega}\)}
\end{example}

Un terme normalisable (mais pas \emph{fortement} normalisable) pourra
donc diverger ou retourner une forme normale selon les réductions
effectuées lors de la conversion : l'ordre dans lequel sont effectuées
ces réductions est donc important. Nous considérons ici une
\emph{stratégie} de réduction qui, pour tout terme normalisable, est assurée d'obtenir une forme
normale : il s'agit de la réduction en
\emph{appel par nom}.

On remarque tout d'abord que tout terme \(t\) du \(\lambda\)-calcul
s'écrit sous la forme
%
\[
\Lam{\Var{x_0}}\Lam{\Var{x_m}}\App{\App{\App{k}{t_0}}{\ldots}}{t_n}
\]
%
où \(k\) est soit une variable soit un redex (le \emph{redex de tête})
tandis que les \(t_i\) sont des termes quelconques (et donc eux-même
de cette forme).


Un terme est en \emph{forme normale de tête} lorsque \(k\) est
nécessairement une variable : le redex le plus à gauche du terme est
``bloqué'' sur une variable et ne peut donc réduire.

La stratégie d'\emph{appel par nom} consiste à contracter
successivement le redex de tête (et uniquement ce redex). 

\todo{Donner la réduction en appel par nom ici.}

Crucialement, nous avons la propriété suivante~\citep[th.3,
  p.62]{krivine:lambda-calculus} :
%
\begin{proposition}
  Un terme \(t\) normalise vers une forme normale de tête si et
  seulement la stratégie d'appel par nom termine (donnant un terme en
  forme normale de tête).
\end{proposition}

Dans le contexte du \(\lambda\)-calcul non typé, où les termes ne sont
pas tous fortement normalisable, on privilégiera la réduction en appel
par nom.

\attention{Ceci n'est pas correct :} Cependant il
existe tout de meme deux formes normales, la faible qui considère
qu'un lambda est une valeur finale, et la forte où meme les redex à
l'intérieure d'une \emph{abstraction} doivent etre évaluées.  Il
existe donc plusieurs stratégies de réduction qui permettent
d'atteindre différents type de forme normale. \attention{fin.}

\begin{example}
  Le terme \attention{cette réduction est fausse}
  \begin{align*}
    (((\lambda x.x) (\lambda y.y)) z) &\leadsto ((\lambda y.y) y) \\
    & \leadsto y
  \end{align*}
  Ici \Var{y} n'est plus réductible c'est donc la forme normale du terme.
\end{example}

Le lambda calcul étant un modèle de calcul universel, il permet de 
d'écrire des termes/programmes qui ne terminent pas : ceux-ci n'ont pas 
de forme normale. 

\begin{example}
 
  Le terme suivant n'admet pas de forme normale :
  %
  \begin{align*}
  (\lambda x. x\: x) (\lambda x. x\: x) &\leadsto (x x)[x \mapsto \lambda x. x\: x] \\
                                        &\leadsto (\lambda x. x\: x) (\lambda x. x\: x) \\
                                        &\leadsto \ldots \\
  \end{align*}
\end{example}

\attention{Définition trop floue : voir la définition ci-dessus (et supprimer dès que tu es convaincu que l'on a rien perdu)} Elle consiste à
réduire les \emph{redex} sauf celle étant sous une \emph{abstraction}. \attention{fin.}

\newcommand{\CBN}{\mathop{\leadsto_N}}

\todo{Faire remonter (et introduire) la définition de l'appel par nom plus haut.}
\[\begin{array}{c}
  \inferrule{{}}
            {\App{(\Lam{\Var{x}}{t})}{u} \CBN \subst{t}{x}{u}}
  \medskip\\
  \inferrule{t \CBN t'}
            {\App{t}{u} \CBN \App{t'}{u}}

\end{array}\]

\attention{Les lambdas scope le plus à droite possible. Donc il faut parenthéser les applications.}

\begin{example}
  Voici une réduction en appel par nom:
  \begin{align*}
    & \App{(\Lam{x}{\Var{x}})}({\App{(\Lam{y}{\Var{y}})}({\Lam{z}{\App{(\Lam{x}{\Var{x}})}{\Var{z}}}}})) \\
    \rightarrow & \App{(\Lam{y}{\Var{y}})}({\Lam{z}{\App{(\Lam{x}{\Var{x}})}{\Var{z}}}})\\
    \rightarrow & \Lam{z}{\App{(\Lam{x}{\Var{x}})}{\Var{z}}}
  \end{align*}
  Ici il n'y a plus rien à réduire avec notre stratégie. On obtient une forme normale faible.
\end{example}

Dans les sections suivantes, nous verrons lorsque nous introduirons
les systèmes de type que l'on peut statiquement garantir que les
termes acceptés par l'analyse de type sont fortement normalisants.

\attention{Question classique : si tu ne peux plus écrire de
  programmes qui ne terminent pas, tu n'es plus Turing complet donc tu
  es strictement moins expressif que tous les langages de
  programmation existants. Est-ce gênant ?}


\paragraph{Implémentation :}
La fonction de $\beta$-réduction consiste donc à contracter une
application dont le membre de gauche est une abstraction. Le cas
échéant, l'opération échoue. Pour ce faire, nous appelons la fonction
de substitution pour substituer la première variable (d'indice \(0\))
par l'argument dans le corps de la fonction :
%
\codefrom{untyped}{lambda}{reduction}

\todo{Décrire ce programme}
\codefrom{untyped}{lambda}{evaluation}


\subsection{Encodages à la Church}

Le $\lambda$-calcul possède un noyeau de language minimaliste
cependant Church ~\citet{church:lambda-calcul} a montré que l'on peut
\emph{encoder} de nombreux types de donnés familiers aux développeurs, tels que
les entiers et les booléens.


\subsubsection{Les booléens de Church}
\label{church-bool}

\newcommand{\True}{\ensuremath{\mathit{true}}}
\newcommand{\False}{\ensuremath{\mathit{false}}}
\newcommand{\Ifte}{\ensuremath{\mathit{ifte}}}

Nous allons ici voir une représentation des booléens accompagnée de la 
structure de contrôle \texttt{if ... then ... else ...}.
Voici les termes correspondants aux constructeurs \True{}, \False{} et 
\Ifte{} :
\begin{align*}
  \True &\triangleq  \Lam{x}{\Lam{y}{\Var{y}}} \\
  \False &\triangleq \Lam{x}{\Lam{y}{\Var{x}}} \\
  \Ifte &\triangleq \Lam{l}{\Lam{m}{\Lam{n}{\App{\Var{l}}{\App{\Var{m}}{\Var{n}}}}}}  \\
\end{align*}

On assimile ces deux termes aux booléens \True{} et \False{} car leur calcul au sein
de l'application d'un \Ifte{} reproduit le comportement attendu.

\begin{example}
  \todo{Problème d'espaces dans le code maths}

  Voici un exemple de réduction du terme \Ifte{} appliqué à la condition \False{} :
  \begin{align*}
    \App{\App{\App{\Ifte}{\False}}{\Var{v}}}{\Var{w}}  \triangleq& \App{\App{\App{(\Lam{l}{\Lam{m}{\Lam{n}{\App{\App{l}{m}}{n}}}}})({\Lam{x}{\Lam{y}{y}}}}){v}}{w} \\
    \rightarrow & \App{\App{({\Lam{m}{\Lam{n}{\App{\App({\Lam{x}{\Lam{y}{y}}}){m}}{n}}}}}){v}}{w} \\
    \rightarrow & \App{(\Lam{n}{\App{\App({\Lam{x}{\Lam{y}{y}}}){v}}{n}})}{w} \\
    \rightarrow & \App{\App({\Lam{x}{\Lam{y}{y}}}){v}}{w}) \\
    \rightarrow & \App({\Lam{y}{y}}){w}) \\
    \rightarrow & \Var{w}
  \end{align*}
\end{example}

Ici nous n'avons aucun moyen de vérifier avant normalisation que le
premier argument de \Ifte{} est effectivement un booléen : nous ne
pouvons donc pas garantire la bonne évaluation de notre terme.

\todo{Tu pourrais faire une petite remarque sur l'encodage objet des
  booléens, qui est effectivement utilisé dans des langages purement
  objets comme Self, Smalltalk ou Pharo. Donner le code correspondant en Java.} 

\subsubsection{Les entiers de Church}

\newcommand{\Zero}{\mathit{zero}}
\newcommand{\Un}{\mathit{un}}
\newcommand{\Deux}{\mathit{deux}}
\newcommand{\Succ}{\mathit{successeur}}
\newcommand{\Plus}{\mathit{plus}}

\todo{Écrire le code avec les macros Lam, App et Var.}

Ici, nous allons voir comment créer les entiers naturels \textit{ex
  nihilo} en utilisant un encodage à la Church. L'idée consiste à
représenter le nombre \(n\) par une fonction d'ordre supérieur prenant
en argument une fonction \Var{f} et l'appliquant \(n\) fois à un
argument \Var{x}. On définira donc
%
\begin{align*}
\Zero &\triangleq \lambda f. \lambda x. x \\
\Un   &\triangleq \lambda f. \lambda x. f\: x \\
\Deux &\triangleq \lambda f. \lambda x. f\: (f\: x)
\end{align*}

Afin de construire tous les entiers naturels, on s'inspire alors de la
définition des entiers de Peano et définit le successeur d'un nombre \(n\)
comme
%
\[
\Succ \triangleq \lambda n. \lambda f. \lambda x. n\: f\: (f\: x)
\]
%
c'est-à-dire \(n\) applications de \(f\) précédée d'une première
application de \(f\), soit \(n+1\) applications.

De la même manière, on construit l'addition de deux nombres \(m\) et
\(n\) en faisant \(m\) applications répétées de \(f\) précédée par
\(n\) applications :
%
\[
\Plus \triangleq \lambda m. \lambda n. \lambda f. \lambda x. m f (n f x)
\]


\subsection{Extensions}

Nous nous attardons ici sur quelques choix d'implémentation et il
sera question d'analyser certaines parties du code et non sa totalité.

\subsubsection{Les booléens}

\newcommand{\NTrue}{\lstinline!True!}
\newcommand{\NFalse}{\lstinline!False!}
\newcommand{\NIfte}{\lstinline!IfThenElse!}

Afin d'implémenter les boléens dans notre language, une possibilité
consiste à exporter l'encodage à la Church des termes \True{},
\False{} et \Ifte{} définis en Section~\ref{church-bool}. Cependant
nous avons choisi d'enrichir le noyau de notre language afin de
supporter, de façon primitive, les entiers. Cela permet d'alléger
l'écriture des termes mais surtout de faciliter la représentation et,
par la suite, la compilation des programmes manipulant des expressions
booléennes.

\newcommand{\ifte}[3]{\ensuremath{\mathit{if}\: #1\: \mathit{then}\: #2\: \mathit{else}\: #3}}
\newcommand{\true}{\ensuremath{\mathit{true}}}
\newcommand{\false}{\ensuremath{\mathit{false}}}

\todo{Étendre la grammaire formelle avec \ifte{}{}{}, \true{} et \false{}}

\todo{Explique ce que tu fais là.}
%
\codefrom{untyped}{lambda}{bool_term}

Pour la substitution des constructeurs \NTrue{} et \NFalse{}, les règles
sont triviales. Pour le terme \NIfte{}, il faut rappeler la fonction de
substitution sur l'ensemble des arguments du constructeur.  En
particulier, il n'est pas nécéssaire d'incrémenter la valeur de
\lstinline!var! étant donné que ce constructeur ne lie aucune
variables.
\todo{Expliquer d'où vient / où va ce bout de code :}
\codefrom{untyped}{lambda}{bool_substitution}



La réduction est étendue au-delà de la \(\beta\)-réduction par une
relation de \(\iota\)-réduction, correspondant à la réduction du test
conditionnel \ifte{\ldots}{\ldots}{\ldots} face aux booléens \true{}
ou \false{} :
%
\[\begin{array}{c}
  \inferrule{{}}
            {\ifte{\true}{u}{v} \Red u}
  \medskip\\
  \inferrule{{}}
            {\ifte{\false}{u}{v} \Red v}
  \medskip\\
  \inferrule{t \Red t'}
            {\ifte{t}{u}{v} \Red \ifte{t'}{u}{v} }
\end{array}\]


L'implémentation de cette réduction ne présente pas de difficulté
particulière :
\codefrom{untyped}{lambda}{bool_evaluation}


\subsubsection{Les entiers}

\newcommand{\zero}{\ensuremath{\mathit{zero}}}
\newcommand{\succs}{\ensuremath{\mathit{succ}}}
\newcommand{\iter}{\ensuremath{\mathit{iter}}}

\newcommand{\NZero}{\lstinline!Zero!}
\newcommand{\NSucc}{\lstinline!Succ!}
\newcommand{\NIter}{\lstinline!Iter!}

Tout comme pour les booléens, nous allons ajouté les trois
constructeurs primitifs \zero{},\succs{} et \iter{} à notre
language. \todo{Les ajouter d'abord à la grammaire formelle
  \emph{puis} ajouter \NZero{}, \NSucc{} et \NIter{} à l'implémentation.}

\codefrom{untyped}{lambda}{nat_term}

On étend la substitution sans difficulté :
\codefrom{untyped}{lambda}{nat_substitution}

\todo{Définir et décrire la \(\iota\)-réduction (formelle) sur \iter.}

\todo{Expliquer l'implem en relation avec la spec ci-dessus.}
\codefrom{untyped}{lambda}{nat_evaluation}

\subsubsection{Les paires}

\todo{Introduire les paires (non typées) ici.}

\section{Le $\lambda$-calcul simplement typé}

\attention{bof : pas très clair.} Il nous faut maintenant définir un système formelle permettant de determiner si l'éxecution du programme,
c'est à dire la réduction de nos termes va bien se dérouler. Dans un premier temps nous introduirons les 
types, puis nous verrons comment les utiliser en définissant des règles de typage pour nos termes.

\subsection{Les types}
\label{simple_type}

\todo{Utiliser les macros bool et intg pour les types int et bool}

\newcommand{\intg}{\ensuremath{\mathit{int}}}
\newcommand{\bool}{\ensuremath{\mathit{bool}}}

Il est important avant tout de définir ce qu'est un type. Les types
que nous considérons dans cette partie sont décrits par la grammaire
suivante :
%
\begin{bnf}
  T &::=& &\mbox{(type)}\\
  &|& \intg{} &\mbox{(entiers)}\\ 
  &|& \bool{} &\mbox{(booléens)}\\
  &|& T \rightarrow T &\mbox{(fonction)}\\
  &|& T \times T &\mbox{(produit)}\\
\end{bnf}

\begin{example}
  Voici des exemples de type:
  \begin{eqnarray}
    int \rightarrow bool  \label{eq_1}  \\
    bool \times int \label{eq_2} 
  \end{eqnarray}
  Le type (\ref{eq_1}) est celui d'une fonction prenant un argument de type entier et 
  retournant un résultat de type booléen.
  Le second type (\ref{eq_2}) correspond a une paire donc le membre de gauche est un booléen
  et le membre de droite un entier.
\end{example}


\subsection{Système de type}

Il est maintenant temps d'introduire notre système de type. Celui-ci va nous permettre de vérifier que nos termes 
sont normalisables. Le but est donc de formaliser une règle de typage pour chacuns de nos termes.

\subsubsection{Spécification}

Afin de faciliter la lecture et la compréhension nous allons dans 
un premier temps donner les règles de typage pour les termes appartenants au noyau 
du language. Nous donnerons les autres règles dans les sections suivantes.

La vérification de type s'effectue dans un \emph{contexte} qui assigne
à chaque variable d'un programme son type. Le contexte est donc une
liste ordonnée de paires variable/type :
%

\begin{bnf}
  \Gamma &::=& &\mbox{(contexte)} \\
         &|& . & \mbox{(contexte vide)} \\
         &|& \Gamma, x : T & \mbox{(type de variable)} 
\end{bnf}


\begin{figure}
\[
\begin{array}{c}
\inferrule[(Var)]%
             {x:T\,\in\Gamma}%
             {\Gamma\vdash x:T} 
\medskip\\
\inferrule[(Abs)]%
          {\Gamma, x:A \vdash t:B}%
          {\Gamma \vdash \Lam{\Var{x}}{t} \,:\, A\rightarrow B}
\qquad
\inferrule[(App)]%
          {\Gamma \vdash f : A\rightarrow B \\
           \Gamma \vdash s : A}%
          {\Gamma\vdash \App{f}{s} : B}
\medskip\\
\inferrule[(true)]
          {{}}
          {\Gamma\vdash \true{} : \bool{}}
\qquad
\inferrule[(false)]
          {{}}
          {\Gamma\vdash \false{} : \bool{}}
\medskip\\
\inferrule[(If-else)]
          {t1:\bool{} \\
           t2:T \\
           t3:T}
         {\Gamma\vdash \ifte{t1}{t2}{t3} : T}
\end{array}
\]

\caption{Lambda calcul simplement typé}
\label{fig:typage-simple}
\end{figure} 

\todo{\textsc{Ne pas mettre de variables mathématiques en dehors du maths mode}}

Les règles de typage sont définies en
Figure~\ref{fig:typage-simple}. \attention{La figure en question
  introduit les booléens : les définir plus tard ou alors les
  expliquer maintenant.} La règle (\textsc{Var}) spécifie le typage
des variables. Cette expression se lit en partant du numérateur pour
déduire le dénumérateur : supposons que la variable \Var{x} de type
\Var{T} soit présente dans le contexte, alors on conclut que le type
de la variable \Var{x} est \Var{T}.  La règle (\textsc{Abs}) spécifie
le typage des lambda abstractions. L'abstraction construit un type de
la forme \(A \Rightarrow B\) : il faut donc que la variable associée
au lambda terme soit de type \(A\) et le résultat de type \(B\).  La
règle (\textsc{App}) spécifie le typage de l'application.  Dans la
Section~\ref{reduction:call_by_name}, nous avions vu que seul les
redex étaient réductible. Dans un language de programmation appliquer
un terme n'étant pas une fonction n'a pas de sens. C'est pour cette
raison qu'il nous faut vérifier que notre application est
\attention{confus : c'est quoi cette histoire de redex ?} bien une
\emph{redex} en vérifiant que \emph{f} est bien du type $A\rightarrow
B$ . De plus on vérifie que \emph{s} est bien du type \emph{A} pour
\attention{qu'est-ce que l'on garanti ?}  garantir l'application de
\emph{s} à notre fonction \emph{f}.


\begin{example}
  \label{probleme:type_simple}
  Voici donc quelques exemples de dérivations de type.  Ces
  dérivations se lisent du bas vers le haut.  \todo{Retirer les cfrac,
    utiliser inferrules. Utiliser les macros définies précédemment
    pour l'écriture des termes.}

  \begin{align*}
    \cfrac{
      \cfrac{
        \cfrac{
          \cfrac{x:Int\rightarrow Bool \in \Gamma}{\Gamma,x:Int\rightarrow Bool,y:Int\vdash x:Int\rightarrow Bool}\:\:\:\:%level3gaucheApp
          \cfrac{y:Int\in \Gamma}{\Gamma,x:Int\rightarrow Bool,y:Int\vdash y:Int}%level3droitApp
        }{\Gamma,x:Int\rightarrow Bool,y:Int\vdash \App{x}{y} : bool}%level2
      }{\Gamma,x:Int\rightarrow Bool\vdash \Lam{y}{\App{x}{y}}:Int \rightarrow Bool}%level1
    }{\Gamma\vdash \Lam{x}{\Lam{y}{\App{x}{y}}}:(Int\rightarrow Bool) \rightarrow Int \rightarrow Bool} %level0
  \end{align*}

  Ce terme est donc correctement typé.


  Tentons maintenant de type checker le terme suivant:   \attention{Qu'est-ce que c'est que ce truc ?!}
  \begin{align*}
    \cfrac{
      \cfrac{}{\Gamma,y:Int\vdash x:A\rightarrow B}%level1DroitApp
      \cfrac{}{\Gamma,y:Int\vdash y:A}%level1GaucheApp
    }{\Gamma,y:Int\vdash\App{x}{y}:Bool}%level0
  \end{align*}
  Nous ne parvenons pas à type checker ce terme pourtant celui ci est un terme de notre language.
\end{example}

%ici je pourrais dire que l'on doit annoter tous les termes mais que c'est trop lourd
%syntaxiquement donc que on préfère introduire le bi-directionnel
Comme nous avons pu le constater dans le dernier exemple, il nous
manque des informations \attention{non, pas ici : c'est la
  \emph{spécification}, on peut tout se permettre. Le problème qu'il
  faut faire passer : ``si on veut implémenter un algo qui fait ça,
  cette règle va être compliquée''} quand au type de \emph{f}. En
effet lorsque l'on vérifie une application il faut vérifier que le
membre de gauche est de type $A \rightarrow B$ alors que l'on ne
connait que \emph{B}. Nous allons donc introduire une nouvelle
représentation de nos termes afin de résoudre ce problème.

\subsubsection{Système de type bi-directionnel}

Les applications dont le membre de gauche est une abstractions posent
problème, comme vu dans l'Exemple~\ref{probleme:type_simple}.  Nous
allons donc partitionner les \(\lambda\)-termes en deux catégories :
d'une part, les termes dont on peut automatiquement synthétiser le
type (et que l'on peut donc placer à gauche d'une application) et ceux
pour lesquels il faudra fournir une annotation de type.


Nous nomerons les termes pouvant se trouver à gauche d'une application
les termes \emph{synthétisables} et les autres termes
\emph{vérifiables}.  Le problème étant le manque d'information quant
au type des termes inférables nous allons étendre le langage des
termes avec une \emph{annotation} permettant de spécifier cette
information.

\newcommand{\Inv}[1]{\ensuremath{\mathit{inv}(#1)}}
\newcommand{\Ann}[2]{\ensuremath{(#1\: :\: #2)}}

\todo{Utiliser l'environnement \texttt{bnf}. Utiliser les macros App, etc}
Voici donc notre représentation des termes:
\begin{align*}
  ex &::= & \mbox{(termes synthétisables)} \\
  &| ex\: in &\mbox{(application)} \\
  &| x &\mbox{(variable)} \\
  &| \Ann{in}{T}&\mbox{(annotation)} \\
  in &::= & \mbox{(termes inférables)} \\
  &|\lambda x.in &\mbox{(abstraction)} \\ 
  &|\Inv{ex} &\mbox{(inversion de phase)} \\
\end{align*}

\todo{Utiliser ``vérifiable'' plutôt que ``inférable''}
Les deux nouveaux termes sont donc l'inversion \Inv{-} qui permet d'inclure les 
\emph{termes synhtétisables} dans le monde des \emph{termes inférables}, l'annotation 
effectue la meme opération en fournissant l'information de typage manquante.


\begin{example}
  \todo{Re-phraser : il n'y avait pas vraiment de problème, la
    différence est juste que cette dérivation peut être
    automatiquement trouvée, sans devinettes.} \todo{Ne pas utiliser
    de cfrac} \attention{Cet example est aussi cassé que le précédant
    : réparer.} Voici maintenant la dérivation qui nous possait
  problème précédement.
  \begin{align*}
    \cfrac{
      \cfrac{
      }{\Gamma,y:Int\vdash (x:Int\rightarrow Bool) \in Int\rightarrow Bool}\:\:\:\:%level1GaucheApp
      \cfrac{
        \cfrac{y:Int \in \Gamma}{\Gamma,y:Int\vdash y \in Bool}%level2Droit
      }{\Gamma,y:Int\vdash Bool \ni y}%level1DroitApp
    }{\Gamma,y:Int\vdash \App{(x:Int\rightarrow Bool)}{y} \in Bool}%level0
  \end{align*}
\end{example}

À partir de cette nouvelle présentation de la syntaxe, on adapte
aisément les règles de typage
(Figure~\ref{fig:typage-simple-bi-direct}), qui sont désormais
entièrement dirigées par la syntaxe et donc purement algorithmique.

\todo{Écrire ``bidirectionnel'', pas ``bi-directionnel''}

\begin{figure}
\label{regles typage bidirectionnel}

\todo{Arrêter les cfracs. Utiliser les macros de construction de termes.}

\[\begin{array}{c}
\boxed{\Gamma\vdash T \ni t}
\bigskip\\
\cfrac{T = A \rightarrow B \: \Gamma, x:A \vdash B \ni t}
      {\Gamma \vdash T \ni \lambda x. t}\mbox{(Abs)}
\medskip\\
\cfrac{\Gamma \vdash t \in T' \:\: T=T'}
      {\Gamma\vdash T \ni inv(t)}\mbox{(Inv)} 
\bigskip\\
\boxed{\Gamma\vdash t \in T}
\bigskip\\
\cfrac{x:T \in \Gamma}
      {\Gamma \vdash x \in T }\mbox{(Var)}
\medskip\\
\cfrac{\Gamma \vdash f \in A\rightarrow B \quad \Gamma\vdash A \ni s }
      {\Gamma\vdash f\:s\in B}\mbox{(App)} 
\medskip\\
\cfrac{\Gamma\vdash T \ni t}
      {\Gamma\vdash (t:T) \in T}\mbox{(Ann)} 
\end{array}\]


\caption{Lambda calcul  bidirectionnel simplement typé}
\label{fig:typage-simple-bi-direct} 
\end{figure}   

\todo{\textsc{Remplace les emph bizarres par du maths mode}}

Les règles de la forme \(\Gamma\vdash T \ni t\) sont des règles de
vérification, celles de la forme \(\Gamma\vdash t \in T\) des règles
de synthèse.  Lors de la vérification, on connait le type \emph{T} et
l'on souhaite déterminer si le terme \emph{t} est bien de ce
type. Lors de la synthèse, on est en mesure, à partir d'un terme
\Var{t} quelconque, de déterminer son type sans ambiguïté.  On vérifie
aisément que ce système de type bi-directionnel est équivalent à celui
présenté en Figure~\ref{fig:typage-simple}.

\subsection{Normalisation} %en gros calculer dans le lambda calcul non typé

Dans cette section nous verrons certaines propriétés offertent par les systèmes de type, et nous parlerons 
de l'évaluation. Nous ne reviendrons pas sur la substitution ni la $\beta$-réduction car cela reste identique par 
rapport à la Section~\ref{calculer_dans_le_lambda_calcul}.

\subsubsection{Méta-théorie}

Le typage permet d'obtenir, à la compilation, des garanties quant à la
bonne exécution des programmes.  Formellement, ces garanties se traduisent en deux propriétés complementaires d'un système de type :
\begin{description}
\item[Progrès :] si un terme \(t\) est correctement typé alors soit \(t\) est une valeur, soit il
 existe une réduction telle que \(t \leadsto t'\)
\item[Préservation :] si un terme \emph{t} a le type \emph{T}
et que \emph{t} $\leadsto$ \emph{t'} alors \emph{t'} est de type \emph{T}
\end{description}

La conjonction de ces deux propriétés donne le slogan ``un programme
bien typé ne plante jamais'' \todo{(citation Milner)} tout programme
bien typé réduit vers une valeur de ce type.

\begin{example}
  Un programme de type \bool{} réduit vers une valeur de type \bool{}
  et donc ce programme réduit \emph{nécessairement} vers le
  constructeur \true{} ou le constructeur \false{}.
\end{example}

Nous avons désormais des garanties quant à la terminaison de nos programme.
Cela se traduit par le fait que l'on pourra systématiquement obtenir une 
forme normale forte pour nos termes contrairement au \(\lambda\)-calcul non typé.


\subsubsection{Reduction forte}

\label{reduction_forte}
Dans le \(\lambda\)-calcul non typé nous avions utilisé une stratégie d'évaluation \emph{Appel par nom}
car nous souhaitions évaluer les termes vers une forme normale faible. Nous ne pouvions pas implémenter 
une stratégie de réduction forte car dans certains cas cela aurait pu provoquer la non terminaison du 
programme.
D'après les propriétés de la section précédente nous disposons de la certitude que une fois 
acceptés par le type-checker nos termes réduisent tous vers une forme normale forte.
Nous allons donc implémenter une stratégie de réduction forte.

Les types ne sont pas utiles lors de l'évaluation. Nous allons donc tout d'abord implémenter
une fonction de réduction forte sur les \(\lambda\)-termes non typés.

Voici la spécification de notre réduction forte :
Voici donc les règles d'évaluations:
\begin{align*}
  &\cfrac{t \Downarrow t'}
  {t:T \Downarrow t'}&\mbox{(Ann)}&\: \\
  &\cfrac{}
  {x \Downarrow x}&\mbox{Var} \\
  &\cfrac{t \Downarrow \: \lambda x.v \:\: \subst{v}{x}{t'}\Downarrow v'}
  {t\:t'\Downarrow \: v'}&\mbox{Appl redex} \\
  &\cfrac{t \Downarrow \: n \:\: v \Downarrow v'}
  {t\:t'\Downarrow \: n \: v'}&\mbox{Appl} \\
  &\cfrac{e \Downarrow \: v}
  {\lambda x.t \Downarrow \: \lambda x.v}&\mbox{Abs}
\end{align*}

La traduction de nos termes bidirectionnels vers les termes non typés
est transparente, il suffit d'effacer les annotations de type.

\begin{example}
  Faire un exemple où avec l'ancien cela ne marchait pas et maintenant ça marche
\end{example}

\subsection{Extensions} 

Dans notre précédent language nous avions introduit les booléens ainsi que les entiers,
nous verrons ici la façon de les représenters ainsi que leurs règles de typage.
Nous introduirons aussi un nouveau type, le produit cartésien.

\subsubsection{Les entiers}
\label{entier_type}

Commençons cette fois-ci par les entiers étant donné que le type \emph{Nat}
est déja présent dans notre language.
Les constructeurs sont les memes que dans le \(\lambda\)-calcul non typé 
cependant maintenant que nous disposons de termes bi-directionnel il est important
de préciser où les placer.

%alors la il me faut une justification peut etre plus précise car j'en vois une pour les types dépendants mais pas pour ici
%Pour les types dépendants je dirais que ceux dans les exTm c'est parceque on veut pouvoir avoir de la dépendance
%sur eux mais je sais pas si ici je peux en parler
\emph{Succ} et \emph{Zero} sont des \emph{termes inférables} étant donné que l'on peut determiner leur 
type sans le synthétiser contrairement à \emph{Iter}.
Les règles d'évaluations restent inchangés depuis la précédente spécification.
Regardons maintenant les règles de typage de ces différents constructeurs:
\begin{align*}
  &\cfrac{\:}
  {\Gamma\vdash Nat \ni \mathrm{Zero}}&\mbox{(Zero)} \\
  &\cfrac{\Gamma\vdash Nat \ni t}
  {\Gamma\vdash Nat \ni \mathrm{Succ(t)}}&\mbox{(Succ)} \\
  &\cfrac{\Gamma\vdash Nat \ni n \:\: \Gamma\vdash a \in A \:\: \Gamma\vdash A\rightarrow A \ni f}
  {\Gamma\vdash \mathrm{iter}\: n\: f\: a \in A}&\mbox{(Iter)} \\
\end{align*}


\subsubsection{Les booléens}

Afin de pouvoir typer nos termes il nous faut introduire le type \emph{Bool}.


En suivant la meme demarche que  pour les entiers les 
constructeurs \emph{True} et \emph{False} sont désormais des \emph{termes inférables}
et le constructeur \emph{Ifte} un \emph{terme synthétisable}



Nous pouvons désormais typer nos booléens de la manière suivante:
\begin{align*}
  &\cfrac{}
  {\Gamma\vdash Bool \ni true}&\mbox{(True)} \\
  &\cfrac{}
  {\Gamma\vdash Bool \ni false}&\mbox{(False)} \\
  &\cfrac{\Gamma\vdash Bool \ni c \:\: \Gamma\vdash t \in C \:\: \Gamma\vdash e \in C}
  {\Gamma\vdash \mathrm{ifte}\: c\: t\: e\in C}&\mbox{(Ifte)}
\end{align*}

On constate ici un exemple d'utilisation concrète des types. En effet 
précédement avant evaluation de l'ensemble du terme nous ne pouvions 
pas savoir si le terme \emph{c} était \emph{True} ou \emph{False}.
Désormais nous avons la certitude avant execution que ce terme retourne 
le terme correspondant à la branche \emph{then} ou \emph{else}

\subsubsection{Le produit cartésien}
\label{produit_cartesien}

Le produit cartésien est un objet mathématique qui est définit comme
un ensemble composé de deux éléments.
Cela nous permettra de crée des collections d'éléments. 
Pour ce faire nous allons implémenter un nouveau constructeur:
les \emph{paires} sous la forme \emph{($a\,b$)}
Nous allons aussi rajouter deux éliminateurs, les projections:
\emph{$\pi 0$} qui appliqué à une paire 
permet de retourner son premier élément ainsi que \emph{$\pi 1$} pour le second élément.
Nous ne disposons actuellement pas d'un type permettant de caractériser nos \emph{paires},
introduisons donc ce le type \emph{produit} de la forme \emph{($a\times b$)}.

Nous allons maintenant évaluer nos termes, 
\begin{align*}
  &\cfrac{a \Downarrow a' \:\: b\Downarrow b'}
  {a,b \Downarrow a',b'}\\
  &\cfrac{a\Downarrow a'}
  {p.\pi0(a,b)\Downarrow a'}\\
  &\cfrac{b\Downarrow b'}
  {p.\pi1(a,b)\Downarrow b'}\\
\end{align*}


Règle de typages des paires:
\begin{align*}
  &\cfrac{\Gamma\vdash A\ni a \:\: \Gamma\vdash B\ni b}
  {\Gamma\vdash A\times B \ni a,b}&\mbox{(Paire)} \\
  &\cfrac{\Gamma\vdash p \in (A\times B)} 
  {\Gamma\vdash p.\pi 0 \in A}&\mbox{($\pi 0$)} \\
  &\cfrac{\Gamma\vdash p \in (A\times B)} 
  {\Gamma\vdash p.\pi 1 \in B}&\mbox{($\pi 1$)} \\
\end{align*}

%on peut parler du fait que de faire des paires de paires c'est long a checker c'est mieux de faire des vecteurs pour ça?

\subsection{Implémentation}

Certaines implémentations sont redondantes avec la précédente, nottament les 
entiers, les booléens ect.. seul leur intération au sein du vérificateur de type
est nouvelle. Nous regrouperons donc tout cela dans la Section~\ref{extensions_implem}.
Voici une implémentation du $\lambda$-calcule simplement typé.

\subsubsection{Représentation des termes et des types}

Comme nous précédement nous allons  
présenter l'implémentation du noyau de notre language, nous introduirons 
les différents extensions dans les sections suivantes.
Commençons tout d'abord par donné la représentation des \emph{inTermes}
ainsi que celle des \emph{exTermes}

\codefrom{typed}{lambda}{inTm}
\codefrom{typed}{lambda}{exTm}

Le type name permet ci dessous nous permettra de mettre des entiers à la place 
d'un string, nous en reparlerons dans l'implémentation de l'évaluation.
\codefrom{typed}{lambda}{name}

De la meme façon que nous avons représenté nos termes voici la 
représentation de nos types 

\codefrom{typed}{lambda}{Type}


\subsubsection{Type checker}

Le point centrale de cette nouvelle implémentation est le type-checker, 
il sera ici question de l'implémentation des règles bi-directionnelles.
Il nous faut donc traduire nos règles \ref{regles typage bidirectionnel} 
de façon algorithmique. Voici donc la correpondance entre l'implémentation et la spécification formelle.

Nous disposons d'une fonction de vérification \emph{Check} ayant pour 
paramètres: un contexte qui est une liste de paires de la forme \emph{(var,type)},
un \emph{inTerme} ainsi qu'un type. Elle retourne un booléens permettant de déterminer
si le terme est correctement typé.
La fonction de synthèse \emph{synth} prend un contexte et un \emph{exTerme} 
et renvoi le type de celui ci.

La fonction gensym utilisée ici permet de crée un nom de variable assurant que celui n'a encore jamais
été utilisé. 

\label{check}

\codefrom{typed}{lambda}{check_abs}
$\cfrac{T = A \rightarrow B \: \Gamma, x:A \vdash B \ni t}
         {\Gamma \vdash T \ni \lambda x. t}\mbox{(Abs)}$
Afin de pouvoir associé une variable à son type dans le contexte il nous faut un nom pour celle ci.
En effet avec notre représentation avec les indices de de Bruijn il est difficile de faire l'association entre 
une variable et son type étant donné que nous ne nommons plus les variables.
C'est pour cette raison que l'on génère une nouvelle variable libre et que l'on substitue les variables liées 
au $\lambda$ par celle ci. On peut donc insérer dans le contexte l'association variable type.
  
\codefrom{typed}{lambda}{check_inv}
$\cfrac{\Gamma \vdash t \in T' \:\: T=T'}
         {\Gamma\vdash T \ni inv(t)}\mbox{(Inv)}$
Ici pour l'égalité nous utilisons l'égalité d'ocaml car il s'agit d'un égalité syntaxique entre les temrmes.


\codefrom{typed}{lambda}{synth_ann}
$\cfrac{\Gamma\vdash T \ni t}
         {\Gamma\vdash (t:T) \in T}\mbox{(Ann)}$

\codefrom{typed}{lambda}{synth_var}
$\cfrac{x:T \in \Gamma}
         {\Gamma \vdash x \in T }\mbox{(Var)}$
Dans la spécification formelle on ne fait pas de distinction entre une variable libre ou liée.
Cependant il n'est pas possible de synthétiser une variable liée étant donné qu'elles sont libérés lors
de la vérification de l'abstraction.

\codefrom{typed}{lambda}{synth_appl}
$\cfrac{\Gamma \vdash f \in A\rightarrow B \quad \Gamma\vdash A \ni s }
         {\Gamma\vdash f\:s\in B}\mbox{(App)}$


Pour cette implémentation nous avons choisis générer des exeptions lorsque le terme
n'était pas correctement typé. Cela permet de terminer le programme directement car de toute
façon le terme serait refusé. Nous reviendrons cependant sur certains points négatifs de cette
méthode dans l'implémentation des types dépendants.


\subsubsection{Réduction forte à petits pas}
\label{reduction_petits_pas}


Nous allons donc implémenté une fonction de réduction 
On appelle cette implémentation de réduction ``à petits pas'' car 
on effectue les réductions étapes par étape. Cela se raproche fortement 
de l'implémentation que nous avons donné de la réduction dans le $\lambda$-calcul
non typé du point de vue de l'implémentation.

Les termes préfixés d'un \emph{S} sont équivalents aux $\lambda$-termes 
du $\lambda$-calcul non typé, l'annotation n'est donc plus présente.

\codefrom{typed}{lambda}{reduction_forte}

Pour l'application \emph{SAppl} si le terme est une \emph{SAbs} on 
effectue la substitution puis l'on évalue le terme obtenu.
Sinon on évalue d'abord celui ci, si l'on obtient une \emph{SAbs} 
on appel la réduction sur l'application de celui ci au terme de droite
sinon il ne nous reste plus qu'à évaluer le terme de droite.

Lorsque l'on réduit sous une \emph{SAbs} il nous faut d'abord libérer l'ensemble des
variables qui lui sont liées. Il nous faut les reliers une fois la réduction terminé 
nous avons donc implémenter une fonction pour effectuer cette opération RELIE LIBRE. %a changer
Elle prend en argument le nom de la variable libre, la valeur de son indice de de Bruijn 
et le terme. Son code est assez triviale nous ne le présenterons donc pas ici.

Les autres règles ne nécéssitent pas de commentaires particuliers.

\subsubsection{Réduction forte à grands pas}

\todo{expliquer plus en détail l'utilisation du type name}
%le type name prend tous son sens dans cette section car il nous permet....


Nous allons maintenant implémenté une nouvelle réduction. 
Comme nous l'avons vu dans la Section~\ref{reduction_forte} %peut etre dans la partie safety je ne me souviens plus a voir 
la réduction forte aboutie forcément à une forme normale, les termes que nous obtenons
sont donc les memes qu'avec la réduction précédente \ref{reduction_petits_pas}. Nous allons donc implémenter 
d'une nouvelle façon cette réduction. Le but de cette implémentation est d'exploiter 
les ressources mises à dispositions par les languages de programmation fonctionnelle.
Elle a aussi pour effet d'évaluer complètement les termes, on peut le constater du fait %a changer
que les fonctions prenenent des \emph{inTermes} ou des \emph{exTermes} en entrée et retourne des valeurs.
Les valeurs ne sont plus réinterprétées par la suite.

\begin{align*}
  v &::= &\mbox{Valeurs} \\
  &| \lambda x \rightarrow v &\mbox{Abstraction} \\
  &| n &\mbox{terme neutre} \\
  n &::= &\mbox{Neutres} \\
  &|x &\mbox{Variable} \\
  &|n v &\mbox{Application} \\
\end{align*}
Ici la représentation de l'abstraction sous la forme \(\lambda x\rightarrow v\)
est lié au fait qu'une abstraction avec ces termes est une fonction.
Voici donc le code correspondant en Ocaml:

\codefrom{typed}{lambda}{value}
\codefrom{typed}{lambda}{neutral}

La value \emph{VLam} est bien représenté par une fonction Ocaml
Pour ce qui est de l'évaluation les règles formelles sont les memes que pour 
la réduction à petit pas. 
Commençons par donner le code de celle ci, nous le commenterons après.


\codefrom{typed}{lambda}{big_step_eval_exTm_ann}
$\cfrac{t \Downarrow t'}
  {t:T \Downarrow t'}$

\codefrom{typed}{lambda}{big_step_eval_exTm_var}

$\cfrac{}
{x \Downarrow x}$

\codefrom{typed}{lambda}{big_step_eval_exTm_app}
\codefrom{typed}{lambda}{vapp}
$\cfrac{t \Downarrow \: \lambda x.v \:\: \subst{v}{x}{t'}\Downarrow v'}
{t\:t'\Downarrow \: v'}$

$\cfrac{t \Downarrow \: n \:\: v \Downarrow v'}
{t\:t'\Downarrow \: n \: v'}$
  

\codefrom{typed}{lambda}{big_step_eval_inTm_inv}

\codefrom{typed}{lambda}{big_step_eval_inTm_abs}

$\cfrac{e \Downarrow \: v}
  {\lambda x.t \Downarrow \: \lambda x.v}$


La règle d'abstraction consiste donc à crée une fonction anonyme Ocaml puis évaluons 
le terme sous le $\lambda$

%revoir ce paragraphe.
Cette représentation nous permet de reconsidérer la façon de voir la 
réduction d'une \emph{Abstraction}. En effet lorsque l'on applique une \emph{Abstraction}
à un terme nous avions introduit la substitution, qui consiste à remplacer les occurences 
des variables liée à ce terme. La transformation d'une \emph{Abstraction} consiste donc à 
crée une fonction anonyme puis à évaluer le terme contenue dans celle ci en ajoutant dans le 
contexte la variable liée à cette fonction. Lors de l'évaluation d'une variable liée, on va
retrouver dans le contexte l'argument correspondant. On aura donc bien le comportement attendu
lors de l'application de cette fonction anonyme, car cela va remplacer les occurences de la 
variable.

\begin{example}
  Soit le terme \(\App{\Lam{x}{\Var{x}}}{u}\), avec la méthode d'évaluation à petit pas,
  on évalue en effectuant $\subst{x}{x}{u}$ ce qui nous donne comme résultat
  \emph{u}. 
  Avec l'évaluation à grands pas on évalue le terme $\Lam{x}{x}$ en 
  \emph{function arg $\rightarrow$ arg} ce qui appliqué à \emph{u} nous renvoi bien celui ci.
\end{example}

Pour évaluer l'application d'un coup il est nécéssaire de crée une fonction externe \emph{vapp}.
Nous appelons donc cette fonction avec le couple formé de l'évaluation des deux membres de l'application.
Si le membre de gauche est une \emph{VLam}, il nous suffit d'appliquer celle ci avec l'application d'Ocaml
étant donné que c'est une fonction anonyme.

La fonction \emph{VFree} permet simplement à partir d'un nom de crée une \emph{NFree}
à l'intérieure d'un \emph{VNeutral}.
Elle permet simplement d'alléger le code de la fonction.

\codefrom{typed}{lambda}{vfree}



Une fois nos termes normalisés il nous faut maintenant un moyen de repasser nos termes
dans la représentation classique. Il nous faut donc implémenter cette fonction permettant de 
faire cette association, voici son code:

\codefrom{typed}{lambda}{value_to_inTm}
\codefrom{typed}{lambda}{neutral_to_exTm}

Revenons sur le type \emph{name} que nous avions introduit. Jusqu'a présent 
celui ci n'était pas utile. Maintenant il va nous permettre de faire la distinction 
entre les variables réellement libre et celles que nous souhaitons liée.
Afin de transformer une value \emph{VLam} en \emph{Abs} il nous faut 
appliquer la fonction \emph{f} à une variable libre, et celle ci se distinguera des
autres variables libres car celle ci possède un indice. 
Nous allons pouvoir exploiter ceci avec l'aide de la fonction \fun{boundfree} dont 
voici le code:
\codefrom{typed}{lambda}{boundfree}

\subsubsection{Produit cartésien}

Nous allons maintenant implémenté le produit cartésien afin d'enrichire notre 
language. Tout d'abord comme nous l'avons vu dans la Section~\ref{produit_cartesien}
il nous faut introduire trois nouveaux termes ainsi qu'un nouveau constructeurs de type.
\emph{Type}
\codefrom{typed}{lambda}{type_pair}
\emph{inTermes}
\codefrom{typed}{lambda}{inTm_pair}
\emph{exTermes}
\codefrom{typed}{lambda}{exTm_pair}
\emph{value}
\codefrom{typed}{lambda}{value_pair}

Il nous faut maintenant implémenter les règles de typage au sein de notre algotithme:

\emph{check}
\codefrom{typed}{lambda}{check_pair}
\emph{synth}
\codefrom{typed}{lambda}{synth_pair}

Rien à commenter,

\subsubsection{Extensions}
\label{extensions_implem}

\todo{je ne pense pas que je devrais faire cette section je n'ai rien à dire dessus}
Voici l'ensemble des intégration dans le vérificateurs de type pour les termes
n'ayant pas encore été présentée

\emph{check} 
\codefrom{typed}{lambda}{inTm_extensions}
\emph{synth} 
\codefrom{typed}{lambda}{exTm_extensions}

SI JE PEUX PEUT ETRE PARLER DE VITTER POUR LES ENTIERS MAIS CEST TOUT




%% Voici donc les règles d'évaluations:
%% \begin{align*}
%%   &\cfrac{t \Downarrow t'}
%%   {t:T \Downarrow t'}&\mbox{(Ann)}&\: \\
%%   &\cfrac{}
%%   {x \Downarrow x}&\mbox{Var} \\
%%   &\cfrac{t \Downarrow \: \lambda x.v \:\: \subst{v}{x}{t'}\Downarrow v'}
%%   {t\:t'\Downarrow \: v'}&\mbox{Appl redex} \\
%%   &\cfrac{t \Downarrow \: n \:\: v \Downarrow v'}
%%   {t\:t'\Downarrow \: n \: v'}&\mbox{Appl} \\
%%   &\cfrac{e \Downarrow \: v}
%%   {\lambda x.t \Downarrow \: \lambda x.v}&\mbox{Abs}
%% \end{align*}












%on veut maintenant montrer celle ou on transforme en mode normale et après mettre la big_step


\section{Les types dépendants}

Maintenant que les bases du $\lambda$-calcul ainsi que du typage à été présenté 
nous allons découvrir les types dépendants. 
 
\subsection{Automatisation de démonstration de preuve}
Durant les deux premières parties du rapport nous avons présenté le $\lambda$-calcul
qui nous à permis d'introduire un système de type. Cependant nous avions une vision 
informatique des type. En effet notre seul but était de vérifier que nos $\lambda$-termes
pouvaient se réduire. 
Un des aspects primordiale des système de type est la correspondance de Curry-Howard.
Celle ci permet de d'établire des relations entre la logique propositionnelle et les systèmes 
de type. Nous verrons que ``t est une preuve de P'' est équivalent à \emph{t:P} c'est à dire
t est de type P.
Tout d'abord intéressons nous aux bases de la logique propositionnelle.
\subsubsection{La logique propositionnelle}

Les règles de la logique propositionnelle associes à chaque constructeur 
une règle d'introduction qui permet de CREUSER, une élimination qui permet d'utiliser 
les hypothèse contenants ce constructeurs ainsi qu'une règle de calcul.

Tout comme les règles de typage on lire les règles suivantes de cette façon:''Si l'on suppose le numérateur
alors le dénominateur est vrai'' ou encore ``Pour prouver le dénominateur il nous faut prouver le numérateur''

Commençons par le connecteur $\Rightarrow$, représentant l'implication, sa règle d'introduction est la suivante:

La règle d'introduction:
\begin{align*}
  \cfrac{[x:A] \: t:B}
        {\lambda x:A.t\: :\: A\Rightarrow B}
\end{align*}
Ici la notation [x:A] signifie ``Supposons x:A montrons t:B''.
Voici maintenant la règle d'élimination:
\begin{align*}
  \cfrac{q\: :A\Rightarrow B\:\: a:A}
        {q\:a\: : B}
\end{align*}

On constate que la règle d'introduction de l'implication est presque identique à celle 
du typage de l'abstraction. De meme pour l'élination vis à vis de la règle de l'application.
La règle de calcul va nous permettre de confirmer notre intuition:
\begin{align*}
  \App{(\Lam{x:A}{t})}{a}\rightarrow \subst{t}{x}{a}
\end{align*}
On reconnait clairement l'évaluation d'une application. C'est cette intuition 
qu'on eu Haskell Curry et Alvin Howard ce qui à permis de prouver la correspondance
entre les systèmes de type et la logique propositionnelle.

Regardons maintenant un second exemple, le constructeur $\land$ signifiant le \emph{et} logique, dont voici la règle de 
formation:
\begin{align*}
\cfrac{A \:est\: un\: terme \:\: B\:est\:un\:terme}
{A\land B} 
\end{align*}
La règle d'introduction:
\begin{align*}
\cfrac{p:A\:\:q:B}
{p,q\: : A\land B}
\end{align*}
Si l'on veut prouver $A\land B$ il nous faut prouver d'une part A et d'autre part B
La règle d'élimination 
\begin{align*}
\cfrac{r\: : A\land B}
      {fst\:r:\:A} \:\:
      \cfrac{r\: : A\land B}
            {snd\:r:\:B}
\end{align*}

On reconnait ici le produit cartésien que l'on avait introduit dans notre $\lambda$-calcul simplement typé avec \emph{fst}
et \emph{snd} les projections.


Pour l'instant nous n'avons pas établie de lien réel entre ces connecteurs et nos termes, c'est l'enjeu de la
section suivante.

\subsubsection{correspondance de Curry Howard bis}

Dans la section précédente nous avons regarder quelques intuitions permettant de voir le lien entre la logique
et l'informatique au travers des systèmes de type.
Nous avons étudié le $\lambda$-calcul qui permet de faire le lien avec la déduction naturelle. Il existe d'autre
modèles de calculs permettants de faire des liens similaires comme par exemple les Système à la Hilbert et 
les systèmes de type de la logique combinatoire.

Voici un tableau montrant les différents liens entre la logique et le $\lambda$-calcul.

\todo{roman: mettre un tableau de correspondance (que j'ai en photo) mais je ne sais pas quelle est la meilleure présentation}


Le fait d'avoir séparé nos termes permets de rendre ces correspondances plus aisées. En effet les constructeur
correspondent aux \emph{termes inférables} tandis que les \emph{termes synthétisables} sont les destructeurs.

\todo{j'aurais des questions à posé jeudi pour finir cette partie}









\subsection{Système de type dépendant}

Comme nous allons le voir dans cette section les types dépendants vont nous permettre d'exprimer 
des termes inexistants, dans notre système précédent. Pour faire echo avec la section précédente,
nous allons introduire un nouveau lien entre la logique et notre système de type: le quantificateur $\forall$.

\subsubsection{Equivalence entre les types et les termes}
\label{presentation_type_dependants}

Jusqu'a présent nous avions d'une part l'ensemble des types et l'ensemble des termes. Cette séparation 
avait un sens car les termes et les types ne se comportaient pas de la meme façon. La plus grande différence 
était au niveau de l'évaluation, en effet nos types étant statiques il n'était pas nécéssaire de les réduires
ou d'effectuer des calculs sur eux %nul.
Cependant certains termes ne peuvent pas s'exprimer dans un système de type statique, prenons par exemple
la fonction identité. 
\begin{example}
  Dans notre système précédent il existait une fonction identité pour chaque type. 
  \begin{align*}
    &\Lam{x}{x}\: :Bool\rightarrow Bool \\
    &\Lam{x}{x}\: :Int\rightarrow Int \\
    & ... \\
  \end{align*}
On souhaiterais écrire une fonction polymorphe dont le type de retour est influencé par le type de retour.
\end{example}

Il existe différentes façon de permettre l'écriture de fonctions comme celles ci. Inspirons nous de la
logique, le quatifieur $\forall$ pourrait nous permettre d'écrire ce type de termes.
\begin{example}
  On souhaiterais pouvoir écrire une fonction identité de la manière suivante:
  \begin{align*}
    \Lam{x}{x}\::(\forall x:A \rightarrow A)
  \end{align*}
\end{example}

Avec des variables au sein de nos types nous pouvons désormais introduire un ensemble de termes, 
comme par exemple les vecteurs de taille \emph{n}.
\begin{example}  
  \label{example vecteur}
  Voici des vecteurs d'éléments de type $\alpha$ et de taille \emph{n}:
  \begin{align*}
    &[e] &: Vec\: 1\: \alpha \\
    &[(e:\alpha),(e:\alpha)] &: Vec\: 1\: \alpha \\
    &... \\
    &[.....] &: \forall n:Int\: \forall \alpha : A . Vec\: \alpha \: n \\
  \end{align*}
  Si nous souhaitons maintenant additionner deux vecteurs, il nous faut donc effectuer des calculs sur les types.
  PRESENTER UN PETIT TRUC EN VITESSE
\end{example}
On ressent de plus en plus l'intuition que en introduisant une dépendance dans nos types, ceux ci se comportent de la meme façon que 
les termes.
Il serait intérressant de considérés à la fois les termes et les types comme un unique ensemble régit par les meme propriétés.
C'est ce que certains systèmes comme \emph{Système F} et les types dépendants on formalisé. 
Meme si les termes sont maintenant des types et inversement il nous faut quand meme introduire un type pour les types.
\begin{example}
  Reprenons notre fonction identité, dire que:
  \begin{align*}
    \Lam{x}{x} : \forall x:A \rightarrow A
  \end{align*}
  Si l'on considère que A est le terme $\Lam{x}{x}$ cela n'a pas de sens.
\end{example}
Nous allons donc dorénavant noté \emph{*} le type des types.

\subsubsection{Formalisation}

Maintenant que nous avons l'intuition des nouveaux constructeurs nous pouvons maintenant enrichire notre language,
voici les nouvelles règles de typage en Figure~\ref{fig:typage dependant}.

\begin{figure}
  \center\boxed{\Gamma\vdash T \ni t}
  
  \begin{align*}
    &\cfrac{\Gamma,x:S\vdash T \ni t}
    {\Gamma \vdash \forall x:S.T \ni \lambda x. t}\mbox{(Abs)} \\
    &\cfrac{\Gamma \vdash t \in T' \:\: T=T'}
    {\Gamma\vdash T \ni inv(t)}\mbox{(Inv)} \\
    &\cfrac{}
    {\Gamma \vdash * \ni *}\mbox{(Star)} \\
    &\cfrac{\Gamma \vdash * \ni S\:\:\Gamma,x:S \vdash *\ni T}
    {\Gamma\vdash * \ni \forall x:S.T}\mbox{(Pi)}
  \end{align*}
  
  \center\boxed{\Gamma\vdash t \in T}
  
  \begin{align*}
    &\cfrac{x:T \in \Gamma}
    {\Gamma \vdash x \in T }\mbox{(Var)} \\
    &\cfrac{\Gamma \vdash f \in \forall x:S.T \quad \Gamma\vdash S \ni s }
    {\Gamma\vdash f\:s\in \subst{T}{s}{x}}\mbox{(App)} \\
    &\cfrac{\Gamma\vdash * \ni T \:\:\Gamma\vdash T \ni t}
    {\Gamma\vdash (t:T) \in T}\mbox{(Ann)} \\
  \end{align*}
  \caption{Typage Dépendant}
  \label{fig:typage dependant} 
\end{figure}

Les deux nouvelles constructions \emph{Pi} et \emph{Star} sont des \emph{termes inférables} étant donné
que l'on possède toute l'information nécéssaire pour les vérifier. De manière générale les types seront 
des \emph{termes inférables}.

Si l'introduction d'un système bi-directionnel dans le $\lambda$-calcul pouvait ne pas etre indispensable, elle prend tout son 
sens avec les types dépendants.
Cependant nous ne pouvons pas parler de types dépendants sans un système bi-directionnel, ce sont dans les 
\emph{termes inférables} que nous allons définir la dépendances que nous allons utilisé dans les 
\emph{termes synthétisables}.
Mis à part la dépendance introduite dans l'abstraction notre language ne comporte pas de termes exploitant 
l'expressivité des types dépendants. Nous verrons au fur et à mesur des extensions toute leur richesse.

En général le connecteur $\forall$ est appelé \emph{Pi} nous garderons cette convention.
Les deux notations suivantes sont équivalentes: 
\begin{align*}  
  \forall x:S.T \Leftrightarrow Pi\: x\: S\: T
\end{align*}
Afin d'alléger la syntaxe si l'on veut crée un \emph{Pi} anonyme on peut utiliser la notation suivante:
\begin{align*}
  & \forall x:Nat.Nat \Leftrightarrow Pi\: x\: Nat\: Nat \Leftrightarrow (Nat \rightarrow Nat) \\
\end{align*}

Avant de poursuivre il est important de nous convaincre que l'ensemble des termes exprimables avec un système 
de typage simple est inclus dans l'ensemble des termes des types dépendants.
\begin{example}
  On peut toujours exprimé une fonction identité applicable uniquement aux entiers de la manière suivante:
  \begin{align*}
    &\Lam{x}{x}\:\forall x:Int\:Int \\
  \end{align*}
\end{example}

\subsection{Extensions}

Comme nous l'avons vu dans l'Exemple~\ref{example vecteur} nous pouvons typé de nouveaux termes inexistants au paravant.
Nous commencerons par mettre a niveau les encodages précédents. Nous présenterons ensuite les vecteurs ainsi que l'égalité.

\subsubsection{Les entiers}

Il nous faut maintenant introduire de la dépendance au sein des entiers. 
Voici leurs nouvelles règles de typage:

\todo{roman:mieux présenter iter dans la spec} 
\begin{align*}
  &\cfrac{}
  {\Gamma\vdash * \ni Nat}&\mbox{(Nat)} \\
  &\cfrac{}
  {\Gamma\vdash Nat \ni Zero}&\mbox{(Zero)} \\
  &\cfrac{\Gamma\vdash Nat \ni n}
  {\Gamma\vdash Nat \ni Succ\:n}&\mbox{(Succ)} \\
  &\cfrac{\Gamma\vdash Nat\rightarrow *\ni P\: \Gamma\vdash Nat\ni n\: \Gamma\vdash \forall n:Nat.(P\:n\rightarrow P\:(succ\:n))\ni f\:
  \Gamma\vdash P\:Zero\ni a}
  {\Gamma\vdash iter \: P\: n\:f\:a\in P\:n}&\mbox{(Iter)}\\
\end{align*}
Comme nous l'énoncions précédement les types sont maintenant des termes, il nous faut donc ajouter une règle \emph{Nat}.

Dans le $\lambda$-calcul simplement typé \ref{entier_type} nous avions besoin que l'argument \emph{a} soit un \emph{terme synthétisable}
afin de déterminer le type de retour de cette construction.
Maintenant l'ensemble des arguments de iter sont des termes inférables car l'introduction d'un prédicat
\emph{P} nous permet de connaitre le type de retour de iter et donc de vérifier les autres termes. 
Ce prédicat nous permet d'une part de crée de la dépendance et d'autre part de rajouter de l'information.

Pour continuer l'analogie avec la logique propositionnelle, on constate que la règle de typage de iter correspond à un raisonnement par
\emph{induction}. En effet on vérifie d'abord que l'argument \emph{a} est bien du type du prédicat dans le cas de zero. 
Puis l'on vérifie que la fonction \emph{f} est définie pour tout \emph{n} vers \emph{n + 1}.

Nous allons maintenant définir un $\lambda$-terme permettant d'effectuer l'addition de deux nombres avec l'aide de notre syntaxe
lispienne présentée en Section~\ref{parsing}:
\begin{align*}
  plus\:=\: (lambda\:n\:(lambda\:a\:(iter\:(lambda\:x\:N)\:n\:(lambda\:ni\:(lambda\:x\:(succ\:x)))\:a)))
\end{align*}
Pour effectuer l'addition \emph{n\:+\:m} la stratégie consiste à iterer \emph{n} fois la fonction successeur sur \emph{m}.
Afin d'aléger la syntaxe nous utiliserons dorénavant ``(+ n m'' correspondant au terme \emph{plus} appliqué aux entiers \emph{n} et
\emph{m}.

\subsubsection{Les booléens}

\todo{Nous n'avons pas vu les booléens dans les types dépendants donc à voir si il y à un réel ajout}

\subsubsection{Les vecteurs}

Les vecteurs sont un très bon exemple d'encodage où l'on peut introduire de la dépendance. Nous avions vu une présentation assez informelle
des vecteurs afin de présenter les types dépendants, il sera donc question ici formaliser l'intuition de la
la Section~\ref{presentation_type_dependants}. 

Tout d'abord commençons par introduire le type des vecteurs:
\begin{align*}
  &\cfrac{\Gamma\vdash * \ni \alpha\:\:\Gamma\vdash Nat \ni n}
  {\Gamma\vdash * \ni Vec\: \alpha\:n }&\mbox{(Vec)} \\
\end{align*}

Ici $\alpha$ sera donc le type des éléments contenus dans le vecteur et \emph{n} sa taille. 
Cette représentation des vecteurs n'est pas familière aux programmeurs, en général si l'on veut appliquer une fonction sur des vecteurs 
de taille précise il faut effectuer un test à l'entrée de la fonction. C'est un des aspects très intéressant des types dépendants dans 
l'utilisation des types dépendants. Si l'on possédait ce genre de constructions dans un language comme Java par exemple, nous
pourrions crée une surchage sur des fonctions qui permettrait de traiter différement les vecteurs de grande taille pour le tri par exemple.
Certains tris étant beaucoup plus efficaces sur de grands vecteurs et inversements. 
Voici maintenant deux constructeurs pour les vecteurs:
\begin{align*}
  &\cfrac{}
  {\Gamma\vdash Vec\:\alpha\:n\ni dnil\:\alpha}&\mbox{(dnil)} \\
  &\cfrac{\Gamma\vdash Vec\:\alpha\:n\ni v \:\:\Gamma\vdash \alpha\ni a}
  {\Gamma\vdash Vec\:\alpha\:(succ\:n)\ni dcons\:a\:v}&\mbox{(dcons)} \\
\end{align*}

Le terme \emph{dnil} correspond au vecteur de taille zero, et \emph{dcons} qui nous permet avec d'ajouter un élément dans un vecteur.
\begin{example}
  Voici un vecteur de taille trois et dont les éléments sont des entiers:
  \begin{align*}
    dcons\:zero\:(dcons\:(succ\:zero)\:(dcons\:zero\:(dnil\:Nat)))
  \end{align*}  
\end{example}

Nous pouvons maintenant crée des vecteurs mais nous ne possédons pas encore d'éliminateur pour les utilisers. Nous allons 
implémenter une fonction bien connue des programmeurs fonctionnels, \emph{dfold} dont voici une définition intuitive:
\fun{fold f vec b} $\rightarrow$ \fun{f a1 (f a2(...(f an b)...))}.
Définissons maintenant l'éliminateur \emph{dfold} comme un \emph{terme synthétisable}:
\todo{modifier la présentation aussi}
\begin{align*}
  &\cfrac{\Gamma\vdash *\ni\alpha\:
    \Gamma\vdash Nat \ni n \: 
    \Gamma\vdash \forall n:Nat.\forall v:Vec\:\alpha\:n.*\ni P\:
    \Gamma\vdash Vec\:\alpha\:n\ni v\:
    \Gamma\vdash \forall n:N.\forall v:Vec\:\alpha\:n.\forall a:\alpha.(P\:n\:v\rightarrow P\:(succ\:n)\:(dcons\:a\:v))\ni f}
  {\Gamma\vdash dfold\:\alpha\:P\:n\:v\:f\:a\in P\:n\:v}&\mbox{(dfold)}
\end{align*}

De la meme manière que pour l'éliminateur des entiers naturels \emph{iter}, le prédicat \emph{p} nous permet 
de rendre le type de retour dépendant des différents arguments.

Il existe de nombreuses façon d'utiliser \emph{dfold}, une application assez simple consiste à faire la somme des éléments d'une liste.
Voici le terme correspondant à cette utilisation:
\begin{align*}
  somme_liste\:=\:(lambda\:v (lambda n(dfold\:N\:(lambda\:n\:(lambda\:xs\:N))\:n\:v\:(lambda\:n(lambda\:xs\:(lambda\:a\:(lambda\:x\:(+\:a\:x)))))\:zero)))
\end{align*}

\subsubsection{L'égalite} 

Pour implémenter l'égalité au sein de notre language il faut nous tourner vers la logique. 
Leibniz philosophe du XVII siècle énonça que deux éléments sont identiques si elles ont les memes propriétés.
\todo{expliquer plus en détail en faisant un parallèle avec la logique}

On peut maintenant introduire le type identité:
\begin{align*}
  &\cfrac{\Gamma\vdash *\ni A \:\: \Gamma\vdash A \ni a \:\: \Gamma\vdash A \ni b }
  {\Gamma\vdash * \ni Id\:A\:a\:b}&\mbox{(Id)}
\end{align*}

refl
\begin{align*}
  &\cfrac{\Gamma\vdash A \ni a}
  {\Gamma\vdash Id\:A\:a\:a\ni refl\:a}&\mbox{(refl)}
\end{align*}

et trans
\begin{align*}
  &\cfrac{
    \Gamma\vdash * \ni A
    \Gamma\vdash A\ni a
    \Gamma\vdash A \ni b
    \Gamma\vdash \forall a:A.\forall b:A.(Id\:A\:a\:b\rightarrow *)
    \Gamma\vdash Id\:A\:a\:b \ni q
    \Gamma\vdash P\:a\:a\:(refl\:a)\ni x}
    {\Gamma\vdash trans\:A\:P\:a\:b\:q\:x\in P\:a\:b\:q}&\mbox{(trans)}
\end{align*}

\todo{roman: a finir quand j'aurais mieux compris}

\subsection{Implémentation}

Etant donné que nous allons présenté l'implémentation finale de ce projet, nous verrons l'ensemble du code.
Nous ne rentrerons pas dans les détails pour l'explication des parties redondantes, mais il sera plus facile 
pour la lecture de disposer de l'intégralité des fonctions. 

\todo{je ne sais pas si c'est une bonne idée}



\subsubsection{Noyau du language}

Les termes synthétisables et inférables enrichies pour les types dépendants:
\codefrom{dependent}{lambda}{inTm}
\codefrom{dependent}{lambda}{exTm}

Les value et tout

\subsubsection{Type Checker}

Nous n'avons rajouter que deux nouveaux termes dans le noyeau de notre language mais 
le fait de ne plus faire la distinction entre les termes et les types change beaucoup de
choses dans l'architecture du programme. 

Dans l'implémentation du \fun{type_checker} du $\lambda$-calcul simplement typé lorsqu'un terme n'était pas
correctement typé la fonction stopait l'execution du programme en levant une exeption.
Nos programmes devenant de plus en plus complexe il peut etre intérressant de renvoyer un rapport detaillé
de l'echec. Voici la structure que nous allons utilisé:

\codefrom{dependent}{lambda}{debug}

Nous aurons aussi besoin des fonctions suivantes: 
-\fun{res_debug}: qui retourne le booléens présent dans le rapport.    
-\fun{create_report}: qui crée un rapport en prenant un argument pour chaque champs du \fun{report}
L'équivalent de ces fonctions pour le type \emph{debug synth} sont suivis de \fun{_synth}.
Cette assistance est nécéssaire pour aider les programmeurs à connaitre la source de l'erreur,
tout comme le font les compilateurs modernes. Cela nous aide aussi pour tester la validité de celui 
ci car on peut maintenant tester si la vérification d'un terme est fausse.

Nous avons désormais une forme normale pour les types, il est donc intérressant de 
fournire cette forme normale directement au type-checker. La fonction \fun{check} prend donc maintenat
un contexte, un \emph{terme inférable} ainsi qu'une value.


\codefrom{dependent}{lambda}{check_abs}
$\cfrac{\Gamma,x:S\vdash T \ni t}
    {\Gamma \vdash \forall x:S.T \ni \lambda x. t}$



\codefrom{dependent}{lambda}{check_inv}
$\cfrac{\Gamma \vdash t \in T' \:\: T=T'}
    {\Gamma\vdash T \ni inv(t)}$

Le principal changement de cette implémentation est le changement d'égalité. 
En effet ici nos termes peuvent contenirs des fonctions anonymes dont on ne peut 
tester l'égalité avec la simple fonction d'ocaml. Il nous faut donc d'abord transformer 
nos \emph{value} en \emph{termes inférables}. Le second problème est que le nom associé 
aux différents binder tels que le $\lambda$ ou le $\forall$ n'auront pas nécéssairement le 
meme nom. Comme nous l'avons vu dans la Section~\ref{alpha_equiv}sur l'$\alpha$-équivalence 
deux termes sont égaux meme si le nom de leur variables est différents. 
La fonction \fun{equal_inTm} parcour simplement les deux termes passé en arguments sans tenir compte
du nom de variable associé au binder. Par contre les variables libres doivent nécéssairement etre les memes.

\codefrom{dependent}{lambda}{check_star}
$\cfrac{}
    {\Gamma \vdash * \ni *}$



\codefrom{dependent}{lambda}{check_pi}
$\cfrac{\Gamma \vdash * \ni S\:\:\Gamma,x:S \vdash *\ni T}
    {\Gamma\vdash * \ni \forall x:S.T}$





\codefrom{dependent}{lambda}{synth_var}
$\cfrac{x:T \in \Gamma}
    {\Gamma \vdash x \in T }$
Tout comme dans l'implémentation précédente il n'est pas possible de rencontrer de variable 
liée lors de la vérification de type.

\codefrom{dependent}{lambda}{synth_app}

$\cfrac{\Gamma \vdash f \in \forall x:S.T \quad \Gamma\vdash S \ni s }
    {\Gamma\vdash f\:s\in \subst{T}{s}{x}}$



\codefrom{dependent}{lambda}{synth_ann}

$\cfrac{\Gamma\vdash * \ni T \:\:\Gamma\vdash T \ni t}
    {\Gamma\vdash (t:T) \in T}$

Etant donné que nos termes et nos types sont équivalents il faut maintenant vérifier que 
\emph{T} est bien un type. Il faut aussi évaluer celui ci afin de le mettre en forme normale.



\subsubsection{Substitution et Normalisation}
\todo{roman: ...}
Voici le code de la substitution:
\codefrom{dependent}{lambda}{substitution_inTm}
\codefrom{dependent}{lambda}{substitution_exTm}

Désormais nous utiliserons seulement la réduction à grand pas


%parler du fait que dans la règle inv on à maintenant une égalité qui n'est plus celle de Ocaml


\subsubsection{Les entiers}

\subsubsection{Les vecteurs}

Pour cette implémentation nous avons besoin d'intégrer les termes ainsi que les \emph{value} suivant:

\codefrom{dependent}{lambda}{terme_vector}
\codefrom{dependent}{lambda}{terme_dfold}
\codefrom{dependent}{lambda}{Value_Vector}


Passons à l'implémentation au sein du type checker:

\codefrom{dependent}{lambda}{check_vec}
\codefrom{dependent}{lambda}{check_dnil}
\codefrom{dependent}{lambda}{check_dcons}

\todo{Gros problème mes implémentations sont claires mais pas adaptables au format papier ....}


Commençons par implémenter l'évaluation des vecteurs.
\codefrom{dependent}{lambda}{big_step_vec}
Rien de plus classique en ce qui concerne nos trois constructeurs. 
En revanche l'évaluation de vfold nécéssite 



\codefrom{dependent}{lambda}{vfold}

Commençons tout d'abord par voir

\subsubsection{L'égalité}




\subsection{Exemples de preuves}














% pour l'implémentation quand je parle du parser ne pas montrer le code 
% mais expliquer la syntaxe lisp

% pour la prochaine introduction d'implémentation dire que la grosse nouveauté
% c'est le type checker et le fait que on 


%pour le simplement typé quand on introduit la première réduction on peut faire l'analogie avec le compilateur qui une fois que les
%termes on été type checker on peut maintenant oublier les types et maintenant réduire 



%Il faudrait que pour les booléens et tout ce genre de choses je fasse dans la partie formelle des spec correspondants aux evaluations ect..


%partie pour quand l'inspiration est partie

%pour introduire la fonctin d'égalité dans le type checker des types dépendants il faut dire que avant on pouvait comparer nos types directements avec la fonction d'égalité de ocaml car il n'y avait pas de variables dans nos types alors que maintenant oui

%Dans les types dépendants on pourra dire que l'on considère que nos termes sont des programmes 

%  pour l'agalité page 111 de thompson

%% * Outro

\clearpage

\bibliographystyle{abbrvnat}
\bibliography{prerapport.bib,rapport.bib}  

\end{document}

