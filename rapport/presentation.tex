\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsthm, amssymb, amsmath}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{color}
\setlength{\fboxsep}{0pt}
\newcommand{\highlight}[1]{\text{\colorbox{gray}{$#1$}}}


\usepackage{xcolor}
\usepackage{listings}
\lstset{
  language=[Objective]Caml,
  %% emph={[2]Nil,Cons,FZe,FSu,ze,su,Ze,Su},
  %% emphstyle={[2]\Constructor},
  %% emph={[3]lookup,failwith},
  %% emphstyle={[3]\Function},
  %% emph={[4]vec,fin,nat,list,tree,completeTree},
  %% emphstyle={[4]\Canonical},
  morecomment=[s]{(*}{*)},
  rangeprefix=\(\*\=,
  rangesuffix=\ \*\),
  includerangemarker=false,
  extendedchars=\true,
  inputencoding=utf8,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  basicstyle=\ttfamily,
  framesep=4mm,
  moredelim=*[s][\itshape]{(*}{*)},
  moredelim=[is][\textcolor{darkgray}]{§}{§},
  escapechar=°,
  keywordstyle=\color[rgb]{0.627451, 0.125490, 0.941176},
  stringstyle=\color[rgb]{0.545098, 0.278431, 0.364706},
  commentstyle=\color[rgb]{0.698039, 0.133333, 0.133333},
  numberstyle=\color[rgb]{0.372549, 0.619608, 0.627451},
  boxpos=t,
  literate= {'a}{{$\alpha$}}1%
    {->}{{${\to}$}}2
    {*}{{${\times}$}}1
    {::}{{${:\::}$}}1
    {lambda}{{$\lambda$}}1
}

\newcommand{\codefrom}[3]
           {\lstinputlisting[linerange={#3}-End]{../#1/#2.ml}}
           \newcommand{\fun}[1]{\lstinline!#1!}

\newcommand{\intg}{\ensuremath{\mathsf{int}}}
\newcommand{\bool}{\ensuremath{\mathsf{bool}}}
\newcommand{\Lam}[2]{\ensuremath{\lambda #1\: #2}}
\newcommand{\App}[2]{\ensuremath{#1\:#2}}
\newcommand{\Var}[1]{\ensuremath{#1}}
\newcommand{\Fst}[1]{\ensuremath{#1.\pi_0}}
\newcommand{\Snd}[1]{\ensuremath{#1.\pi_1}}
\newcommand{\Pair}[2]{\ensuremath{(#1, #2)}}
\newcommand{\ifte}[4]{\ensuremath{\mathsf{ifte}\:#1\: #2\:\:#3\:\: #4}}
\newcommand{\true}{\ensuremath{\mathsf{true}}}
\newcommand{\false}{\ensuremath{\mathsf{false}}}
\newcommand{\zero}{\ensuremath{\mathsf{zero}}} 
\newcommand{\succs}{\ensuremath{\mathsf{succ}}}
\newcommand{\iter}{\ensuremath{\mathsf{iter}}}
\newcommand{\subst}[3]{#1[#2 := #3]}
\newcommand{\Inv}[1]{\ensuremath{\mathsf{inv}(#1)}}
\newcommand{\Ann}[2]{\ensuremath{(#1\: :\: #2)}}
\newcommand{\equal}[3]{\ensuremath{#1 =_#2 #3}} 
\newcommand{\refl}{\ensuremath{\mathsf{refl}}}
\newcommand{\id}[3]{\ensuremath{\mathsf{id}\:#1\: #2\:\:#3}}

\setbeamertemplate{navigation symbols}{} 

\usetheme{Boadilla}

\title{Titre}

\author{Roman Delgado}

\institute[\textsc{Upmc}]{Université Pierre et Marie Curie}

\date{04/05/2016}


\begin{document}


\begin{frame}

\titlepage

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{Introduction}

  \begin{block}{Motivation}
    \begin{itemize}
    \item A
    \item B
    \item C
    \end{itemize}
  \end{block}

  \begin{block}{Objectif}
    \begin{itemize}
    \item A
    \item 2 + 2 = 4
    \item C
    \end{itemize}
  \end{block}  

\end{frame}
\newenvironment{bnf}
               {\[\begin{array}{lcl@{\qquad}r}}
               {\end{array}\]}


\begin{frame}[b,fragile]

\frametitle{Le $\lambda$-calcul non typé}
\framesubtitle{Présentation formelle} 

\vfill

\begin{block}{Un programme}
\begin{center}
\begin{minipage}{.5\linewidth}
\begin{lstlisting}
(lambda x (lambda y (x y))
\end{lstlisting}
\end{minipage}
\end{center}
\end{block}

\vfill

\begin{block}{Syntaxe}

\begin{bnf}
  t &::= & &\mbox{($\lambda$-terme)} \\
  &|& \Var{x} & \mbox{(variable)} \\
  &|& \Lam{x}{t} & \mbox{(abstraction)} \\
  &|& (\App{t}{t})          & \mbox{(application)}
\end{bnf}

%% Pierre: vérifier que tous les '\App{}{}' sont (bien) parenthésés.

\end{block}


%voici la définition inductive des lambda termes
\if 0
\begin{block}{Les $\lambda$-termes}
  \begin{itemize}
  \item $x$ \mbox{variable}
  \item $\lambda x.t$ \mbox{abstraction}
  \item $t\:u$ \mbox{application}
  \end{itemize}
\end{block}

\begin{block}{Exemple}
  $\Lam{x}{(\Lam{y}{(\App{x}{y})})}\equiv(lambda\:x\:(lambda\:y\:(x\:y)))$
\end{block}
\fi

\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Le $\lambda$-calcul non typé}
\framesubtitle{Réduction et évaluation}

%% Pierre: Faire comme dans le rapport
\begin{block}{Évaluation}
    $\:\:\:\:\:\:$evaluation ((lambda x (lambda y (x y))) t u) \\
    $\rightarrow$ evaluation (substitution (lambda y (x y) u) x t) \\
    $\rightarrow$ evaluation (substitution (t y) y u) \\
    $\rightarrow$ (t u)
\end{block}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[b,fragile]
\frametitle{Le $\lambda$-calcul non typé}
\framesubtitle{Extensions}

\begin{block}{Addition}
\begin{center}
\begin{minipage}{.9\linewidth}
\begin{lstlisting}
x + y = (lambda x (lambda y (iter x (lambda n (succ n)) y)))
\end{lstlisting}
\end{minipage}
\end{center}
\end{block}

\vfill

\begin{columns}
  \begin{column}{.45\linewidth}
    \begin{block}{Les booléens}
      \begin{itemize}
      \item $\true$ 
      \item $\false$
      \item $\ifte{}{c}{t}{u}$
      \end{itemize}
    \end{block}
  \end{column}
  \begin{column}{.45\linewidth}
    \begin{block}{Les entiers}
      \begin{itemize}
      \item $\zero$ 
      \item $\succs$ 
      \item $\iter\:n\:f\:a$ 
      \end{itemize}
    \end{block}
  \end{column}
\end{columns}

\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[b,fragile]
\frametitle{Le $\lambda$-calcul simplement typé}
\framesubtitle{Motivations} 

\begin{block}{exemple de fonction}
  \begin{minipage}{.5\linewidth}
    \begin{lstlisting}
      f = (lambda x (lambda y (lambda fu (ifte x (fu y) y))))
    \end{lstlisting}
  \end{minipage}
\end{block}


\vfill

\begin{columns}
  \begin{column}{.3\linewidth}
    \lstinline!f true 3! $\rightarrow$ \lstinline!4!
  \end{column}
  \begin{column}{.3\linewidth}
    \lstinline!f 3 true! $\not\rightarrow$
  \end{column}
\end{columns}

\vfill

\begin{flushright}
  \large{\textit{Peut-on rejeter ce programme à la compilation ?}}
\end{flushright}


\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{Le $\lambda$-calcul simplement typé}
  \framesubtitle{Exemple de dérivation de typage}
  
  %% Pierre: Régler problème de timiing
  %% Pierre: Utiliser ifte
  %% Pierre: Trouver un exemple avec une application
  %% Pierre: Expliciter la phase d'inversion

  \[
  \inferrule[]%
    {\visible<2->{
        \inferrule[]
           {\visible<3->{
               \inferrule[]              
                  {\visible<4->{
                     \inferrule[]{
                     \visible<5->{
                     \inferrule[]{\visible<6->{x:\bool\in\Delta}}{\Delta\vdash x \in \visible<6->{\bool}}}}                     
                           {\Delta\vdash \bool \ni x}%level4gauche
                  \inferrule[]{
                    \visible<7->{
                    \inferrule[]{\visible<8->{fu:(\intg \rightarrow \intg)\in \Delta}}{\Delta\vdash fu \in \visible<8->{(\intg \rightarrow \intg)}}}
                  \visible<9->{\inferrule[]{
                    \visible<10->{\inferrule[]{y:\intg\in\Delta}{\Delta\vdash y \in \intg}}
                  }{\Delta\vdash\intg \ni y}}}
                  {\inferrule[]{}
                            {\Delta\vdash \intg \ni (fu\:y)}}%level4midle
                  \inferrule[]{
                    \visible<11->{\inferrule[]{y:\intg\in\Delta}{\Delta\vdash y \in \intg}}
                  }{\Delta\vdash \intg \ni y}}}%level4droite 
                  {\Delta \vdash \intg \ni \ifte{\intg}{x}{(fu\:y)}{y}}}}%level3
           {\Gamma\vdash \intg \rightarrow (\intg \rightarrow \intg) \rightarrow \intg \ni \Lam{y}{(\Lam{fu}{(\ifte{\intg}{x}{(fu\:y)}{y}})})}}}%level1
    {\varnothing\vdash \bool \rightarrow \intg \rightarrow (\intg \rightarrow \intg) \rightarrow \intg \ni \Lam{x}{(\Lam{y}{(\Lam{fu}{(\ifte{\intg}{x}{(fu\:y)}{y)})})}}}%level0
    \]

    \begin{align*}
    \visible<2->{\Gamma &\triangleq x:\bool} \\
    \visible<3->{\Delta &\triangleq \Gamma,y:\intg,\:fu:\intg\rightarrow\intg} \\
  \end{align*}
  
  

\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[b,fragile]
  \frametitle{Le $\lambda$-calcul simplement typé}
  \framesubtitle{Les limites}

  Slide avec exemple du ``et'' logique entre deux vecteurs 
  dans un stystème de type simple

  %% Pierre: donner une entrée qui réussi et une entrée qui échoue

  \vfill

\begin{flushright}
  %% Pierre: mieux exprimer
  \large{\textit{Peut-on garantir la taille des listes à la compilation ?}}
\end{flushright}
  
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{Les types dépendants}
  \framesubtitle{Les vecteurs}

  %% Pierre: mettre l'exemple du && pour les vecteurs
  Parler de l'exemple avec maintenant les types dépendants

\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{Les types dépendants}
  \framesubtitle{Correspondance de Curry Howard}

   \begin{block}{}
     ``t est une preuve de P'' $\equiv$ ``t est de type P (t:P) ``
   \end{block}
  
   \visible<2->{\begin{block}{}
     \[
     \inferrule[]{
       \visible<3->{\inferrule[]{\:}{\varnothing\vdash\intg \ni 4}}
       \visible<4->{\inferrule[]{\:}{\varnothing\vdash(2+2)\equiv4}}
     }{\varnothing\vdash\id{\intg}{(2+2)}{4} \ni \refl}
     \]
   \end{block}}

   \visible<5->{\begin{block}{}
       \[
       \inferrule[]{
         \visible<6->{\inferrule[]{\:}{\varnothing\vdash\intg \ni 4}}
         \visible<7->{\inferrule[]{\:}{\varnothing\vdash(2+1)\not\equiv4}}
       }{\varnothing\vdash\id{\intg}{(2+1)}{4} \ni \refl}
       \]
   \end{block}}

  %Pierre: Trouver un autre titre
  
  %% Pierre: Tracer l'exécution de 'check (Id Nat (2 + 2) 4) refl'
  %% Pierre: Tracer l'exécution de 'check (Id Nat (2 + 1) 4) refl'
  
  

%% \if 0
%%   \begin{block}{}
%%     ``t est une preuve de P'' $\equiv$ ``t est de type P (t:P) ``
%%   \end{block}
  
%%   \begin{block}{Egalité}
%%   \[
%%   \begin{array}{cc}
    
%%     \inferrule[(Id)]{\Gamma\vdash *\ni A \:\: \Gamma\vdash A \ni a \:\: \Gamma\vdash A \ni b }
%%               {\Gamma\vdash * \ni Id\:A\:a\:b}
%%               \quad\quad
%%   \inferrule[(Refl)]{\Gamma\vdash A \ni a}
%%             {\Gamma\vdash Id\:A\:a\:a\ni refl\:a}
%%   \end{array}
%%   \]
%%   \end{block}
  
%%   \visible<2->{
%%   \begin{block}{\equal{2 + 2}{N}{4}}
%%     $Id(Nat,2 + 2,4)$ \\
%%     \visible<3->{$refl\:4$}
%%   \end{block}}
%%   \fi



\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \frametitle{Les types dépendants}
  \framesubtitle{Correspondance de Curry Howard}

  %% Pierre: attention aux types dans ifte
  
    \[
  \inferrule[]%
    {\visible<2->{
        \inferrule[]
           {\visible<3->{
               \inferrule[]              
                  {\visible<4->{
                     \inferrule[]
                       {\visible<5->{x:\bool\in \Delta}}
                       {\Delta \vdash \bool \ni x} \qquad
                     \inferrule[]
                       {\visible<6->{y:\intg\in \Delta}}
                       {\Delta \vdash y\in\intg}
                  \inferrule[]
                            {\visible<6->{
                                \inferrule[]
                                          {y:\intg\in\Delta}
                                          {\intg\ni y}
                            }}
                           {\Delta\vdash \succs\:y\in\intg}}}
                  {\Delta \vdash \intg \ni \ifte{x}{\succs\:y}{y}   }}}
           {\Gamma\vdash \intg \rightarrow \intg \ni \Lam{y}{\ifte{x}{\succs\:y}{y}}}}}
    {\varnothing\vdash \forall A:*(\forall a,b:A\:(id\:A\:a\:b \rightarrow id\:A\:b\:a)) \ni \Lam{x}{\Lam{y}{\ifte{x}{\succs\:y}{y}}}}
    \]

    \begin{align*}
    \Gamma &\triangleq x:\bool \\
    \Delta &\triangleq \Gamma,y:\intg \\
  \end{align*}
  

\end{frame}


\begin{frame}
  \frametitle{Conclusion}

  \begin{block}{Résumé}
    \begin{itemize}
     \item A 
     \item B
     \item C 
    \end{itemize}
  \end{block}

  \begin{block}{Extensions}
    \begin{itemize}
     \item A 
     \item B
     \item C
     \item Slow.fast typechecker
     \item Tactics
     \item Proofs \& complexity
     \item Untyped reduction: Krivine machine
     \item Rational bidirectionalisation
    \end{itemize}
  \end{block}


\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]

\frametitle{Autre titre}

%% Attention, pour écrire du code, il faut mettre "fragile" en option du slide
\begin{lstlisting}
 let test = foo
\end{lstlisting}

\begin{block}{}
  Foo.
\end{block}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
  \[
  \inferrule[]%
    {\visible<2->{
        \inferrule[]
           {\visible<3->{
               \inferrule[]              
                  {\visible<4->{
                     \inferrule[]
                       {\visible<5->{x:\intg\rightarrow \bool \in E}}
                       {E \vdash x:\intg\rightarrow \bool} \qquad
                     \inferrule[]
                       {\visible<6->{y:\intg\in E}}
                       {E \vdash y:\intg}}}
                  {E \vdash \App{x}{y} : \bool}}}
           {\Delta\vdash \Lam{y}{\App{x}{y}}:\intg \rightarrow \bool}}}
    {\Gamma\vdash \Lam{x}{\Lam{y}{\App{x}{y}}}:(\intg\rightarrow \bool) \rightarrow \intg \rightarrow \bool}
  \]

  \begin{align*}
    \Delta &\triangleq \Gamma,x:\intg\rightarrow \bool \\
    E &\triangleq \Gamma,x:\intg\rightarrow \bool,y:\intg \\
  \end{align*}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}

\begin{center}
\large{(Backup slides)}
\end{center}

\end{frame}

\begin{frame}
  \ldots
\end{frame}

\end{document}
